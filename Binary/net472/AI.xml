<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AI</name>
    </assembly>
    <members>
        <member name="T:AI.AISettings">
            <summary>
            Global settings
            </summary>
        </member>
        <member name="P:AI.AISettings.GlobalEps">
            <summary>
            Global epsilon (default = 1e-8)
            </summary>
        </member>
        <member name="P:AI.AISettings.FFTCore">
            <summary>
            Basic function for fft
            </summary>
        </member>
        <member name="M:AI.AISettings.GetProvider">
            <summary>
            Get a provider for a dot as decimal separator conversion 
            </summary>
        </member>
        <member name="M:AI.AISettings.GetProviderComa">
            <summary>
            Get a comma conversion provider
            </summary>
        </member>
        <member name="T:AI.Algebra.Gauss">
            <summary>
            Gauss method has computational complexity O(n^3)
            </summary>
        </member>
        <member name="M:AI.Algebra.Gauss.SolvingEquations(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Solve the SLAE
            </summary>
            <param name="A">Coefficient matrix</param>
            <param name="B">Free members vector</param>
        </member>
        <member name="T:AI.Algebra.Kramer">
            <summary>
            Cramer method
            </summary>
        </member>
        <member name="M:AI.Algebra.Kramer.SolvingEquations(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Solve the SLAE
            </summary>
            <param name="A">Coefficient matrix</param>
            <param name="B">Free members vector</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.ByteConverter">
            <summary>
            Static class providing methods for conversion between PCM bytes and float[] data.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.ToFloats8Bit(System.Byte[],System.Single[][],System.Boolean)">
            <summary>
            Convert Pcm_8bit to floats
            </summary>
            <param name="bytes"></param>
            <param name="floats"></param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.FromFloats8Bit(System.Single[][],System.Byte[],System.Boolean)">
            <summary>
            Convert floats to Pcm_8bit
            </summary>
            <param name="floats"></param>
            <param name="bytes"></param>
            <param name="normalized"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.ToFloats16Bit(System.Byte[],System.Single[][],System.Boolean,System.Boolean)">
            <summary>
            Convert Pcm_16bit to floats (little-endian or big-endian)
            </summary>
            <param name="bytes"></param>
            <param name="floats"></param>
            <param name="normalize"></param>
            <param name="bigEndian"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.FromFloats16Bit(System.Single[][],System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Convert floats to Pcm_16bit (little-endian or big-endian)
            </summary>
            <param name="floats"></param>
            <param name="bytes"></param>
            <param name="normalized"></param>
            <param name="bigEndian"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Channels">
            <summary>
            Most used channels are: left and right.
            Also we add the special case: interleaved channels
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Left">
            <summary>
            Left channel (=0)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Right">
            <summary>
            Right channel (=1)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Sum">
            <summary>
            Mono as sum of all channels
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Average">
            <summary>
            Mono as average from all channels
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Interleave">
            <summary>
            Interleaved channels
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer">
            <summary>
            Interface for sound containers
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer.Signals">
            <summary>
            Discrete signals contained in container's channels
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer.Item(AI.BackEnds.DSP.NWaves.Audio.Channels)">
            <summary>
            Indexing based on channel type
            </summary>
            <param name="channel">channel type (left, right or interleave)</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer">
            <summary>
            Interface for audio playback functionality
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Volume">
            <summary>
            Sound volume in range [0.0f, 1.0f]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.PlayAsync(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Int16)">
            <summary>
            Play samples contained in DiscreteSignal asynchronously
            </summary>
            <param name="signal">Signal to play</param>
            <param name="startPos">Number of the first sample to play</param>
            <param name="endPos">Number of the last sample to play</param>
            <param name="bitDepth">Number of bits per one sample</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.PlayAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Play samples contained in WAV file (or some other source) asynchronously
            </summary>
            <param name="source">WAV file (or other source) to play</param>
            <param name="startPos">Number of the first sample to play</param>
            <param name="endPos">Number of the last sample to play</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Pause">
            <summary>
            Pause playing audio
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Resume">
            <summary>
            Resume playing audio
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Stop">
            <summary>
            Stop playing audio
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder">
            <summary>
            Interface with functionality for audio recording
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder.StartRecording(System.Int32,System.Int16,System.Int16)">
            <summary>
            Start recording audio with specific settings
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="channelCount">Number of channels (1=mono, 2=stereo)</param>
            <param name="bitsPerSample">Number of bits per sample (8, 16, 24 or 32)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder.StopRecording(System.String)">
            <summary>
            Stop recording audio and save recorded sound to file or any other destination
            </summary>
            <param name="destination">Output file (destination) name</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.Mci">
            <summary>
            Static class containing MCI functions imported from winmm.dll
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer">
            <summary>
            Audio player based on MCI.
            
            MciAudioPlayer works only with Windows, since it uses winmm.dll and MCI commands.
            
            MciAudioPlayer lets MCI do all the heavy-lifting with sound playback.
            It launches MCI command and just awaits for amount of time 
            corresponding to the duration of a given segment.
            
            If the playback was paused, the player memorizes how many milliseconds
            it was "idle" and then adds this time to the total awaiting time.
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._alias">
            <summary>
            Hidden alias for an MCI waveaudio device
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._pauseDuration">
            <summary>
            Duration of pause in milliseconds
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._pauseTime">
            <summary>
            The exact time when playback was paused
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._isPaused">
            <summary>
            The flag indicating whether audio playback is currently paused
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Volume">
            <summary>
            Volume (measured in percents from the range [0.0f, 1.0f])
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.PlayAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Play audio contained in WAV file asynchronously
            </summary>
            <param name="source">WAV file to play</param>
            <param name="startPos">Number of the first sample to play</param>
            <param name="endPos">Number of the last sample to play</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.PlayAsync(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Int16)">
            <summary>
            Unfortunately, MCI does not provide means for playing audio from buffers in memory.
            Moreover, since NWaves library is portable, there's even no easy way to write the buffer 
            into temporary file and play it here (it could be a workaround for the problem).
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="bitDepth"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Pause">
            <summary>
            Pause audio playback
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Resume">
            <summary>
            Resume playing audio
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Stop">
            <summary>
            Stop playing audio and close MCI device
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder">
            <summary>
            Audio recorder based on MCI.
            
            MciAudioRecorder works only with Windows, since it uses winmm.dll and MCI commands.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder.StartRecording(System.Int32,System.Int16,System.Int16)">
            <summary>
            Start recording audio with specific settings
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="channelCount">Number of channels (1=mono, 2=stereo)</param>
            <param name="bitsPerSample">Number of bits per sample (8, 16, 24 or 32)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder.StopRecording(System.String)">
            <summary>
            Stop recording audio and save it to destination WAV-file
            </summary>
            <param name="destination">Output WAV file containing recorderd sound</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.WaveFile">
            <summary>
            WAV file container
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.Signals">
            <summary>
            Signals from all channels.
            Usually:
            
                Signals.Count = 1 (mono)
            or
                Signals.Count = 2 (stereo)
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.WaveFmt">
            <summary>
            Wav header struct
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFile.SupportedBitDepths">
            <summary>
            Supported bit depths
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            This constructor loads signals from a wave file.
            
            Since NWaves is .NET Standard 2.0 library, there's no universal FileStream class.
            So it's supposed that the client code will take care 
            for extracting the stream from a wave file.
            
            </summary>
            <param name="waveStream">Input stream</param>
            <param name="normalized">Normalization flag</param>
            <returns></returns>
            <exception>Possible null exception</exception>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(System.Collections.Generic.IList{AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal},System.Int16)">
            <summary>
            This constructor loads signals into container.
            </summary>
            <param name="signals">Signals to be loaded into container</param>
            <param name="bitsPerSample">Bit depth</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int16)">
            <summary>
            This constructor loads one signal into container.
            </summary>
            <param name="signal">Signal to be loaded into container</param>
            <param name="bitsPerSample">Bit depth</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.SaveTo(System.IO.Stream,System.Boolean)">
            <summary>
            Method saves the contents of a wave file to stream.
            </summary>
            <param name="waveStream">Output stream for saving</param>
            <param name="normalized">Normalization flag</param>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.Item(AI.BackEnds.DSP.NWaves.Audio.Channels)">
            <summary>
            Fancy indexer:
            
                waveFile[Channels.Left] -> waveFile.Signals[0]
                waveFile[Channels.Right] -> waveFile.Signals[1]
                waveFile[Channels.Average] -> returns channel-averaged (new) signal
                waveFile[Channels.Interleave] -> returns interleaved (new) signal
            
            </summary>
            <param name="channel">Channel enum</param>
            <returns>Signal from the channel or interleaved signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.WaveFormat">
            <summary>
            Standard WAVE header
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.AudioFormat">
            <summary>
            PCM = 1
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.ChannelCount">
            <summary>
            1 - mono, 2 - stereo
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.SamplingRate">
            <summary>
            8000 Hz, 11025 Hz, 16000 Hz, 22050 Hz, 44100 Hz
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.ByteRate">
            <summary>
            SamplingRate * NumChannels * BitsPerSample / 8
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.Align">
            <summary>
            ChannelCount * BitsPerSample / 8
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.BitsPerSample">
            <summary>
            8, 16, 24, 32
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor">
            <summary>
            Amplitude modulation spectra (AMS) extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.FeatureDescriptions">
            <summary>
            Feature descriptions.
            Initialized in constructor in the following manner (example):
            
                band_1_mf_0.5_Hz   band_1_mf_1.0_Hz   ...    band_1_mf_8.0_Hz
                band_2_mf_0.5_Hz   band_2_mf_1.0_Hz   ...    band_2_mf_8.0_Hz
                ...
                band_32_mf_0.5_Hz  band_32_mf_1.0_Hz  ...    band_32_mf_8.0_Hz
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._featuregram">
            <summary>
            The "featuregram": the sequence of (feature) vectors;
            if this sequence is given, then AmsExtractor computes 
            modulation spectral coefficients from sequences in each 'feature channel'.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._filterbank">
            <summary>
            Filterbank matrix of dimension [filterCount * (fftSize/2 + 1)]
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._envelopes">
            <summary>
            Signal envelopes in different frequency bands
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._fftSize">
            <summary>
            Size of FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._modulationFft">
            <summary>
            FFT transformer for modulation spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._modulationFftSize">
            <summary>
            Size of FFT applied to signal envelopes
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._modulationHopSize">
            <summary>
            Hop size for analysis of signal envelopes
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._block">
            <summary>
            Internal buffer for a signal block at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._filteredSpectrum">
            <summary>
            Internal buffer for filtered spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._modBlock">
            <summary>
            Internal buffer for modulation spectrum analysis
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor._modSpectrum">
            <summary>
            Modulation spectrum (in one band)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.AmsOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">AMS options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.ComputeFrom(System.Single[],System.Int32,System.Int32)">
            <summary>
            Method for computing modulation spectra.
            Each vector representing one modulation spectrum is a flattened version of 2D spectrum.
            </summary>
            <param name="samples">Samples for analysis</param>
            <param name="startSample">The number (position) of the first sample for processing</param>
            <param name="endSample">The number (position) of last sample for processing</param>
            <returns>List of flattened modulation spectra</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.MakeSpectrum2D(System.Single[])">
            <summary>
            Get 2D modulation spectrum from its flattened version.
            Axes are: [short-time-frequency] x [modulation-frequency].
            </summary>
            <param name="featureVector"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.VectorsAtHerz(System.Collections.Generic.IList{System.Single[]},System.Single)">
            <summary>
            Get sequence of short-time spectra corresponding to particular modulation frequency
            (by default, the most perceptually important modulation frequency of 4 Hz).
            </summary>
            <param name="featureVectors"></param>
            <param name="herz"></param>
            <returns>Short-time spectra corresponding to particular modulation frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.AmsExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            All logic is fully implemented in ComputeFrom() method
            </summary>
            <param name="block"></param>
            <param name="features"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor">
            <summary>
            Abstract class for all feature extractors.
            
            NOTE.
            All fields of FeatureExtractor class and its subclasses are made protected.
            Conceptually they should be private, especially internal buffers,
            but making them protected allows developers to extend extractors
            more efficiently by reusing memory already allocated in base classes.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.FeatureCount">
            <summary>
            Number of features to extract
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.FeatureDescriptions">
            <summary>
            String annotations (or simply names) of features
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.DeltaFeatureDescriptions">
            <summary>
            String annotations (or simply names) of delta features (1st order derivatives)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.DeltaDeltaFeatureDescriptions">
            <summary>
            String annotations (or simply names) of delta-delta features (2nd order derivatives)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.FrameDuration">
            <summary>
            Length of analysis frame (in seconds)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.HopDuration">
            <summary>
            Hop length (in seconds)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.FrameSize">
            <summary>
            Size of analysis frame (in samples)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.HopSize">
            <summary>
            Hop size (in samples)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.SamplingRate">
            <summary>
            Sampling rate that the processed signals are expected to have
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor._blockSize">
            <summary>
            Size of the block for processing at each step.
            This field is usually set in subclass methods.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor._preEmphasis">
            <summary>
            Pre-emphasis coefficient
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor._window">
            <summary>
            Type of the window function
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor._windowSamples">
            <summary>
            Window samples
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FeatureExtractorOptions)">
            <summary>
            Construct extractor from sampling rate, frame duration and hop duration (in seconds)
            </summary>
            <param name="samplingRate"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ComputeFrom(System.Single[],System.Int32,System.Int32,System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Compute the sequence of feature vectors from some part of array of samples.
            </summary>
            <param name="samples">Array of real-valued samples</param>
            <param name="startSample">The offset (position) of the first sample for processing</param>
            <param name="endSample">The offset (position) of last sample for processing</param>
            <param name="vectors">Pre-allocated sequence of feature vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ComputeFrom(System.Single[],System.Int32,System.Int32)">
            <summary>
            Compute the sequence of feature vectors from some part of array of samples.
            </summary>
            <param name="samples">Array of real-valued samples</param>
            <param name="startSample">The offset (position) of the first sample for processing</param>
            <param name="endSample">The offset (position) of last sample for processing</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.TimeMarkers(System.Int32,System.Double)">
            <summary>
            Time markers
            </summary>
            <param name="vectorCount">Number of feature vectors</param>
            <param name="startFrom">Starting time position</param>
            <returns>List of time markers</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Process one frame in block of data at each step
            (in general block can be longer than frame, e.g. zero-padded block for FFT)
            </summary>
            <param name="block">Block of data</param>
            <param name="features">Features computed in the block</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ComputeFrom(System.Single[])">
            <summary>
            Compute the sequence of feature vectors from the entire array of samples
            </summary>
            <param name="samples">Array of real-valued samples</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ComputeFrom(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Compute the sequence of feature vectors from some fragment of a signal
            </summary>
            <param name="signal">Discrete real-valued signal</param>
            <param name="startSample">The offset (position) of the first sample for processing</param>
            <param name="endSample">The offset (position) of the last sample for processing</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ComputeFrom(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Compute the sequence of feature vectors from the entire DiscreteSignal
            </summary>
            <param name="signal">Discrete real-valued signal</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.Reset">
            <summary>
            Reset feature extractor's state
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelChunksComputeFrom(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Parallel computation (returns chunks of fecture vector lists)
            </summary>
            <param name="samples"></param>
            <param name="startSample"></param>
            <param name="endSample"></param>
            <param name="parallelThreads"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelComputeFrom(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Parallel computation (joins chunks of feature vector lists into one list)
            </summary>
            <param name="samples"></param>
            <param name="startSample"></param>
            <param name="endSample"></param>
            <param name="parallelThreads"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelComputeFrom(System.Single[],System.Int32)">
            <summary>
            Parallel computation (joins chunks of feature vector lists into one list)
            </summary>
            <param name="samples"></param>
            <param name="parallelThreads"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelComputeFrom(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute the sequence of feature vectors from some fragment of a signal
            </summary>
            <param name="signal">Discrete real-valued signal</param>
            <param name="startSample">The offset (position) of the first sample for processing</param>
            <param name="endSample">The offset (position) of the last sample for processing</param>
            <param name="parallelThreads">Number of threads</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureExtractor.ParallelComputeFrom(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Compute the sequence of feature vectors from the entire DiscreteSignal
            </summary>
            <param name="signal">Discrete real-valued signal</param>
            <param name="parallelThreads">Number of threads</param>
            <returns>Sequence of feature vectors</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeaturePostProcessing">
            <summary>
            Class providing methods for additional processing of feature vector sequences.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeaturePostProcessing.NormalizeMean(System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Method for mean subtraction (in particular, CMN).
            </summary>
            <param name="vectors">Sequence of feature vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeaturePostProcessing.NormalizeVariance(System.Collections.Generic.IList{System.Single[]},System.Int32)">
            <summary>
            Variance normalization (divide by unbiased estimate of stdev)
            </summary>
            <param name="vectors">Sequence of feature vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeaturePostProcessing.AddDeltas(System.Collections.Generic.IList{System.Single[]},System.Collections.Generic.IList{System.Single[]},System.Collections.Generic.IList{System.Single[]},System.Boolean,System.Int32)">
            <summary>
            Method for complementing feature vectors with 1st and (by default) 2nd order derivatives.
            </summary>
            <param name="vectors"></param>
            <param name="previous"></param>
            <param name="next"></param>
            <param name="includeDeltaDelta"></param>
            <param name="N"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeaturePostProcessing.Join(System.Collections.Generic.IList{System.Single[]}[])">
            <summary>
            Join different collections of feature vectors.
            Time positions must coincide.
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Base.FeatureVectorExtensions.Statistics(System.Single[])">
            <summary>
            Dictionary with statistics
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor">
            <summary>
            This extractor computes in each frame
            spectral energies in frequency bands defined by a given filterbank (channel outputs).
            
            So it's like MFCC but without DCT-compressing of the filterbank-mapped spectrum.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "fb0", "fb1", "fb2", etc.)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.FilterBank">
            <summary>
            Filterbank matrix of dimension [filterbankSize * (_blockSize/2 + 1)].
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._nonLinearityType">
            <summary>
            Non-linearity type (logE, log10, decibel, cubic root)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._spectrumType">
            <summary>
            Spectrum calculation scheme (power/magnitude normalized/not normalized)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._logFloor">
            <summary>
            Floor value for LOG calculations
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._getSpectrum">
            <summary>
            Delegate for calculating spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._postProcessSpectrum">
            <summary>
            Delegate for post-processing spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor._bandSpectrum">
            <summary>
            Internal buffer for a post-processed band spectrum at each step
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FilterbankOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Filterbank options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Compute sequence of filter bank channel outputs
            </summary>
            <param name="block"></param>
            <param name="features"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.FilterbankExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor">
            <summary>
            Linear Prediction Cepstral Coefficients extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "lpcc0", "lpcc1", etc.)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._order">
            <summary>
            Order of an LPC-filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._lifterSize">
            <summary>
            Size of liftering window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._lifterCoeffs">
            <summary>
            Liftering window coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._convolver">
            <summary>
            Internal convolver
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._cc">
            <summary>
            Internal buffer for cross-correlation signal
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._lpc">
            <summary>
            Internal buffer for LPC-coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor._reversed">
            <summary>
            Internal buffer for reversed real parts of the currently processed block
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.LpccOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">LPCC options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Method for computing LPCC features.
            It essentially duplicates LPC extractor code 
            (for efficient memory usage it doesn't just delegate its work to LpcExtractor)
            and then post-processes LPC vectors to obtain LPCC coefficients.
            </summary>
            <param name="block">Samples for analysis</param>
            <param name="features">LPCC vector</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpccExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor">
            <summary>
            Linear Predictive Coding coefficients extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor.FeatureDescriptions">
            <summary>
            Descriptions ("error", "lpc1", "lpc2", etc.)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor._order">
            <summary>
            Order of an LPC-filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor._convolver">
            <summary>
            Internal convolver
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor._reversed">
            <summary>
            Internal buffer for reversed real parts of the currently processed block
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor._cc">
            <summary>
            Internal buffer for cross-correlation signal
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.LpcOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">LPC options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Standard method for computing LPC vector.
             
            Note:
                The first LP coefficient is always equal to 1.0.
                This method replaces it with the value of prediction error.
            
            </summary>
            <param name="block">Samples for analysis</param>
            <param name="features">LPC vector</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.LpcExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor">
            <summary>
            Mel Frequency Cepstral Coefficients extractor.
            
            Since so many variations of MFCC have been developed since 1980,
            this class is very general and allows customizing pretty everything:
            
             - filterbank (by default it's MFCC-FB24 HTK/Kaldi-style)
             
             - non-linearity type (logE, log10, decibel (librosa power_to_db analog), cubic root)
             
             - spectrum calculation type (power/magnitude normalized/not normalized)
             
             - DCT type (1,2,3,4 normalized or not): "1", "1N", "2", "2N", etc.
             
             - floor value for LOG-calculations (usually it's float.Epsilon; HTK default seems to be 1.0 and in librosa 1e-10 is used)
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "mfcc0", "mfcc1", "mfcc2", etc.)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.FilterBank">
            <summary>
            Filterbank matrix of dimension [filterbankSize * (fftSize/2 + 1)].
            By default it's mel filterbank.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._lifterSize">
            <summary>
            Size of liftering window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._lifterCoeffs">
            <summary>
            Liftering window coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._dct">
            <summary>
            DCT-II transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._dctType">
            <summary>
            DCT type ("1", "1N", "2", "2N", "3", "3N", "4", "4N")
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._nonLinearityType">
            <summary>
            Non-linearity type (logE, log10, decibel, cubic root)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._spectrumType">
            <summary>
            Spectrum calculation scheme (power/magnitude normalized/not normalized)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._logFloor">
            <summary>
            Floor value for LOG calculations
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._includeEnergy">
            <summary>
            Should the first MFCC coefficient be replaced with LOG(energy)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._logEnergyFloor">
            <summary>
            Floor value for LOG-energy calculation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._getSpectrum">
            <summary>
            Delegate for calculating spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._postProcessSpectrum">
            <summary>
            Delegate for post-processing spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._applyDct">
            <summary>
            Delegate for applying DCT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor._melSpectrum">
            <summary>
            Internal buffer for a post-processed mel-spectrum at each step
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.MfccOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">MFCC options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Standard method for computing MFCC features.
            According to default configuration, in each frame do:
            
                0) Apply window (base extractor does it)
                1) Obtain power spectrum X
                2) Apply mel filters and log() the result: Y = Log(X * H)
                3) Do dct: mfcc = Dct(Y)
                4) [Optional] liftering of mfcc
            
            </summary>
            <param name="block">Samples for analysis</param>
            <param name="features">MFCC vector</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.MfccExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor">
            <summary>
            Extractor of spectral features according to methodology described in MPEG7 standard.
            
            It's a flexible extractor that allows varying almost everything.
            
            The difference between Mpeg7SpectralExtractor and SpectralExtractor is that 
            former calculates spectral features from total energy in frequency BANDS
            while latter analyzes signal energy at particular frequencies (spectral bins).
            
            Also, optionally it allows computing harmonic features along with spectral features.
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.FeatureSet">
            <summary>
            Names of supported spectral features
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.HarmonicSet">
            <summary>
            Names of supported harmonic features
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.FeatureDescriptions">
            <summary>
            String annotations (or simply names) of features
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._filterbank">
            <summary>
            Filterbank from frequency bands
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._frequencyBands">
            <summary>
            Internal buffer for frequency bands
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._frequencies">
            <summary>
            Internal buffer for central frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._peakFrequencies">
            <summary>
            Internal buffer for harmonic peak frequencies (optional)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._peaks">
            <summary>
            Internal buffer for spectral positions of harmonic peaks (optional)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._extractors">
            <summary>
            Extractor functions
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._parameters">
            <summary>
            Extractor parameters
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._harmonicExtractors">
            <summary>
            Harmonic extractor functions (optional)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._spectrum">
            <summary>
            Internal buffer for magnitude spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._mappedSpectrum">
            <summary>
            Internal buffer for total energies in frequency bands
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._pitchEstimator">
            <summary>
            Pitch estimator function (optional)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._pitchTrack">
            <summary>
            Array of precomputed pitches (optional)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._pitchPos">
            <summary>
            Current position in pitch track
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor._peaksDetector">
            <summary>
            Harmonic peaks detector function (optional)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.MultiFeatureOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.IncludeHarmonicFeatures(System.String,System.Int32,System.Func{System.Single[],System.Single},System.Action{System.Single[],System.Int32[],System.Single[],System.Int32,System.Single},System.Single,System.Single)">
            <summary>
            Add set of harmonic features to calculation list
            </summary>
            <param name="featureList"></param>
            <param name="peakCount"></param>
            <param name="pitchEstimator"></param>
            <param name="lowPitch"></param>
            <param name="highPitch"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.AddHarmonicFeature(System.String,System.Func{System.Single[],System.Int32[],System.Single[],System.Single})">
            <summary>
            Add one more harmonic feature with routine for its calculation
            </summary>
            <param name="name"></param>
            <param name="algorithm"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.SetPitchTrack(System.Single[])">
            <summary>
            Set array of precomputed pitches
            </summary>
            <param name="pitchTrack"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.ComputeFrom(System.Single[],System.Int32,System.Int32,System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Compute the sequence of feature vectors from some fragment of a signal
            </summary>
            <param name="samples">Signal</param>
            <param name="startSample">The number (position) of the first sample for processing</param>
            <param name="endSample">The number (position) of last sample for processing</param>
            <param name="vectors">Output sequence of feature vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Compute MPEG7 spectral features in one frame
            </summary>
            <param name="block"></param>
            <param name="features"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.Mpeg7SpectralFeaturesExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor">
            <summary>
            Extractor of spectral features.
            It's a flexible extractor that allows setting frequencies of interest.
            At least one spectral feature MUST be specified.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.FeatureSet">
            <summary>
            Names of supported spectral features
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.FeatureDescriptions">
            <summary>
            String annotations (or simply names) of features
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._extractors">
            <summary>
            Extractor functions
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._parameters">
            <summary>
            Extractor parameters
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._frequencies">
            <summary>
            Center frequencies (uniform in Herz scale by default; could be uniform in mel-scale or octave-scale, for example)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._spectrum">
            <summary>
            Internal buffer for magnitude spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._mappedSpectrum">
            <summary>
            Internal buffer for magnitude spectrum taken only at frequencies of interest
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor._frequencyPositions">
            <summary>
            Internal buffer for spectral positions of frequencies of interest
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.MultiFeatureOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.AddFeature(System.String,System.Func{System.Single[],System.Single[],System.Single})">
            <summary>
            Add one more feature with routine for its calculation
            </summary>
            <param name="name"></param>
            <param name="algorithm"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Compute spectral features in one frame
            </summary>
            <param name="block"></param>
            <param name="features"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.SpectralFeaturesExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor">
            <summary>
            Extractor of time-domain features
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.FeatureDescriptions">
            <summary>
            String annotations (or simply names) of features
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor._extractors">
            <summary>
            Extractor functions
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor._parameters">
            <summary>
            Parameters
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.MultiFeatureOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.AddFeature(System.String,System.Func{AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single})">
            <summary>
            Add one more feature with routine for its calculation
            </summary>
            <param name="name"></param>
            <param name="algorithm"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.ComputeFrom(System.Single[],System.Int32,System.Int32,System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Compute the sequence of feature vectors from some fragment of a signal
            </summary>
            <param name="samples">Signal</param>
            <param name="startSample">The number (position) of the first sample for processing</param>
            <param name="endSample">The number (position) of last sample for processing</param>
            <param name="vectors">Pre-allocated sequence of feature vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            All logic is implemented in ComputeFrom() method
            </summary>
            <param name="block"></param>
            <param name="features"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Multi.TimeDomainFeaturesExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FeatureExtractorOptionsExtensions.SaveOptions(System.IO.Stream,AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FeatureExtractorOptions)">
            <summary>
            Simple JSON serialization
            </summary>
            <param name="stream"></param>
            <param name="options"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FeatureExtractorOptionsExtensions.LoadOptions``1(System.IO.Stream)">
            <summary>
            Simple JSON deserialization
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.FeatureExtractorOptionsExtensions.Cast``2(``0)">
            <summary>
            Cast options of one type to options of another type
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.NonLinearityType">
            <summary>
            Non-linear post-processing schemes
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.SpectrumType">
            <summary>
            Spectrum calculations
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.SpectrumType.Magnitude">
            <summary>
            Sqrt(re*re + im*im)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.SpectrumType.Power">
            <summary>
            re*re + im*im
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.SpectrumType.MagnitudeNormalized">
            <summary>
            Sqrt(re*re + im*im) / fftSize
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.SpectrumType.PowerNormalized">
            <summary>
            (re*re + im*im) / fftSize
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor">
            <summary>
            Pitch extractor calls autocorrelation method since it's best in terms of universality and quality.
            The feature vector contains 1 component : pitch.
            
            If there's a need to create pitch extractor based on other time-domain method (YIN or ZcrSchmitt),
            then TimeDomainFeatureExtractor can be used.
            
            If there's a need to create pitch extractor based on a certain spectral method (HSS or HPS),
            then SpectralDomainFeatureExtractor can be used.
            
            Example:
            
            var extractor = new TimeDomainFeaturesExtractor(sr, "en", 0.0256, 0.010);
            
            extractor.AddFeature("yin", (s, start, end) => { return Pitch.FromYin(s, start, end); });
            
            var pitches = extractor.ComputeFrom(signal);
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor.FeatureDescriptions">
            <summary>
            Names of pitch algorithms
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor._low">
            <summary>
            Lower pitch frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor._high">
            <summary>
            Upper pitch frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor._convolver">
            <summary>
            Internal convolver
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor._reversed">
            <summary>
            Internal buffer for reversed real parts of the currently processed block
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor._cc">
            <summary>
            Internal buffer for cross-correlation signal
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.PitchOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Pitch options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Pitch tracking
            </summary>
            <param name="block">Samples</param>
            <param name="features">Pitch</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor.IsParallelizable">
            <summary>
            Computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PitchExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor">
            <summary>
            Perceptual Linear Predictive Coefficients extractor (PLP-RASTA)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "plp0", "plp1", "plp2", etc.)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.FilterBank">
            <summary>
            Filterbank matrix of dimension [filterbankSize * (fftSize/2 + 1)].
            By default it's bark filterbank like in original H.Hermansky's work
            (although many people prefer mel bands).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._centerFrequencies">
            <summary>
            Filterbank center frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._rasta">
            <summary>
            RASTA coefficient (if zero, then no RASTA filtering)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._rastaFilters">
            <summary>
            RASTA filters for each critical band
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._lifterSize">
            <summary>
            Size of liftering window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._lifterCoeffs">
            <summary>
            Liftering window coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._includeEnergy">
            <summary>
            Should the first PLP coefficient be replaced with LOG(energy)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._logEnergyFloor">
            <summary>
            Floor value for LOG-energy calculation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._bandSpectrum">
            <summary>
            Internal buffer for a signal spectrum grouped to frequency bands
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._equalLoudnessCurve">
            <summary>
            Equal loudness weighting coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._lpcOrder">
            <summary>
            LPC order
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._lpc">
            <summary>
            Internal buffer for LPC-coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._idftTable">
            <summary>
            Precomputed IDFT table
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor._cc">
            <summary>
            Autocorrelation samples (computed as IDFT of power spectrum)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.PlpOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">PLP options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Standard method for computing PLP features.
            In each frame do:
            
                0) Apply window (base extractor does it)
                1) Obtain power spectrum
                2) Apply filterbank of bark bands (or mel bands)
                3) [Optional] filter each component of the processed spectrum with a RASTA filter
                4) Apply equal loudness curve
                5) Take cubic root
                6) Do LPC
                7) Convert LPC to cepstrum
                8) [Optional] lifter cepstrum
            
            </summary>
            <param name="block">Samples for analysis</param>
            <param name="features">PLP vectors</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.Reset">
            <summary>
            Reset state
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.IsParallelizable">
            <summary>
            In case of RASTA filtering computations can't be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PlpExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor">
            <summary>
            Power-Normalized Cepstral Coefficients extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "pncc0", "pncc1", "pncc2", etc.)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.M">
            <summary>
            Window length for median-time power (2 * M + 1)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.N">
            <summary>
            Window length for spectral smoothing (2 * N + 1)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.LambdaA">
            <summary>
            Lambdas used in asymmetric noise suppression formula (4)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.LambdaT">
            <summary>
            Forgetting factor in temporal masking formula
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.LambdaMu" -->
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.C">
            <summary>
            Threshold for detecting excitation/non-excitation segments
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.MuT" -->
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.FilterBank">
            <summary>
            Filterbank matrix of dimension [filterbankSize * (fftSize/2 + 1)].
            By default it's gammatone filterbank.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._power">
            <summary>
            Nonlinearity coefficient (if 0 then Log10 is applied)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._includeEnergy">
            <summary>
            Should the first PNCC coefficient be replaced with LOG(energy)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._logEnergyFloor">
            <summary>
            Floor value for LOG-energy calculation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._dct">
            <summary>
            DCT-II transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._gammatoneSpectrum">
            <summary>
            Internal buffers for gammatone spectrum and its derivatives
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._mean">
            <summary>
            Value for mean normalization
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._ringBuffer">
            <summary>
            Ring buffer for efficient processing of consecutive spectra
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor._step">
            <summary>
            Step of PNCC algorithm
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.PnccOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">PNCC options</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.ProcessFrame(System.Single[],System.Single[])" -->
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.Reset">
            <summary>
            Reset state
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.PnccExtractor.SpectraRingBuffer">
            <summary>
            Helper Ring Buffer class for efficient processing of consecutive spectra
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer">
            <summary>
            Class for simple CSV serialization of feature vectors
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer._vectors">
            <summary>
            List of feature vectors for serialization
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer._timeMarkers">
            <summary>
            List of time markers for serialization
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer._names">
            <summary>
            List of feature names for serialization
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer._delimiter">
            <summary>
            Delimiter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer.#ctor(System.Collections.Generic.IList{System.Single[]},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.String},System.Char)">
            <summary>
            Constructor accepting the list of feature vectors
            </summary>
            <param name="featureVectors">List of feature vectors for serialization</param>
            <param name="timeMarkers">List of time markers for serialization</param>
            <param name="featureNames">List of feature names for serialization</param>
            <param name="delimiter">Delimiter char</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.Serializers.CsvFeatureSerializer.SerializeAsync(System.IO.Stream,System.String,System.String)">
            <summary>
            Asynchronous method for feature vectors serialization
            </summary>
            <param name="stream"></param>
            <param name="format"></param>
            <param name="timeFormat"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor">
            <summary>
            Simplified Power-Normalized Cepstral Coefficients extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "spncc0", "spncc1", "spncc2", etc.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.LambdaMu" -->
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.FilterBank">
            <summary>
            Filterbank (gammatone by default)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._power">
            <summary>
            Nonlinearity coefficient (if 0 then Log10 is applied)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._includeEnergy">
            <summary>
            Should the first SPNCC coefficient be replaced with LOG(energy)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._logEnergyFloor">
            <summary>
            Floor value for LOG-energy calculation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._dct">
            <summary>
            DCT-II transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._spectrum">
            <summary>
            Internal buffer for a signal spectrum at each step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._filteredSpectrum">
            <summary>
            Internal buffer for gammatone spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor._mean">
            <summary>
            Value for mean normalization
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.PnccOptions)">
            <summary>
            Main constructor
            </summary>
            <param name="options">PNCC options</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.ProcessFrame(System.Single[],System.Single[])" -->
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.SpnccExtractor.Reset">
            <summary>
            Reset extractor
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor">
            <summary>
            Wavelet extractor
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor.FeatureDescriptions">
            <summary>
            Descriptions (simply "w0", "w1", etc.)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor._fwt">
            <summary>
            Fast Wavelet Transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor._waveletName">
            <summary>
            Wavelet name
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor._level">
            <summary>
            FWT level (0 = auto)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor._coeffs">
            <summary>
            Internal buffer for FWT coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor.#ctor(AI.BackEnds.DSP.NWaves.FeatureExtractors.Options.WaveletOptions)">
            <summary>
            Constructor
            </summary>
            <param name="options">Wavelet options</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor.ProcessFrame(System.Single[],System.Single[])">
            <summary>
            Compute FWT coeffs in each frame
            </summary>
            <param name="block"></param>
            <param name="features"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor.IsParallelizable">
            <summary>
            True if computations can be done in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.FeatureExtractors.WaveletExtractor.ParallelCopy">
            <summary>
            Copy of current extractor that can work in parallel
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Features.Harmonic">
            <summary>
            Harmonic features
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.Peaks(System.Single[],System.Int32[],System.Single[],System.Int32,System.Single)">
            <summary>
            Simple algorithm for detecting harmonic peaks in spectrum
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Array for peak positions</param>
            <param name="peakFrequencies">Array for peak frequencies</param>
            <param name="samplingRate">Sampling rate</param>
            <param name="pitch">Pitch is given if it is known</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.Centroid(System.Single[],System.Int32[],System.Single[])">
            <summary>
            Harmonic centroid
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Peak positions</param>
            <param name="peakFrequencies">Peak frequencies</param>
            <returns>Harmonic centroid</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.Spread(System.Single[],System.Int32[],System.Single[])">
            <summary>
            Harmonic spread
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Peak positions</param>
            <param name="peakFrequencies">Peak frequencies</param>
            <returns>Harmonic spread</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.Inharmonicity(System.Single[],System.Int32[],System.Single[])">
            <summary>
            Inharmonicity
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Peak positions</param>
            <param name="peakFrequencies">Peak frequencies</param>
            <returns>Inharmonicity</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.OddToEvenRatio(System.Single[],System.Int32[])">
            <summary>
            Harmonic Odd-to-Even Ratio
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Peak positions</param>
            <returns>Odd-to-Even Ratio</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Harmonic.Tristimulus(System.Single[],System.Int32[],System.Int32)">
            <summary>
            Tristimulus (nth component)
            </summary>
            <param name="spectrum">Spectrum</param>
            <param name="peaks">Peak positions</param>
            <param name="n">Tristimulus component: 1, 2 or 3</param>
            <returns>Tristimulus</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Features.Perceptual">
            <summary>
            Perceptual features
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Perceptual.Loudness(System.Single[])">
            <summary>
            Perceptual loudness (is the sum of specific loudnesses: N'(z) = E(z)^0.23)
            </summary>
            <param name="spectralBands"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Perceptual.Sharpness(System.Single[])">
            <summary>
            Perceptual sharpness (is essentially the equivalent of spectral centroid).
            
            According to the original formula, the weights are slightly different 
            for bark bands with index >= 15, but this implementation assumes
            that there will be no more than 15 bands.
            </summary>
            <param name="spectralBands"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Features.Pitch">
            <summary>
            Class for pitch estimation and tracking
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromAutoCorrelation(System.Single[],System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation by autocorrelation method
            </summary>
            <param name="signal"></param>
            <param name="samplingRate"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromAutoCorrelation(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation by autocorrelation method (overloaded for DiscreteSignal)
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromZeroCrossingsSchmitt(System.Single[],System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation from zero crossing rate (based on Schmitt trigger)
            </summary>
            <param name="signal"></param>
            <param name="samplingRate"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="lowSchmittThreshold"></param>
            <param name="highSchmittThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromZeroCrossingsSchmitt(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation from zero crossing rate (overloaded for DiscreteSignal)
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="lowSchmittThreshold"></param>
            <param name="highSchmittThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromYin(System.Single[],System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            YIN algorithm for pitch estimation
            De Cheveigné, A., Kawahara, H. YIN, a fundamental frequency estimator for speech and music.
            The Journal of the Acoustical Society of America, 111(4). - 2002.
            </summary>
            <param name="signal"></param>
            <param name="samplingRate"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="cmdfThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromYin(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            YIN algorithm for pitch estimation (overloaded for DiscreteSignal)
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="cmdfThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromHss(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Pitch estimation: Harmonic Sum Spectrum
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromHss(System.Single[],System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation: Harmonic Sum Spectrum (given pre-computed spectrum)
            </summary>
            <param name="spectrum"></param>
            <param name="samplingRate"></param>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromHps(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Pitch estimation: Harmonic Product Spectrum
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromHps(System.Single[],System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation: Harmonic Product Spectrum (given pre-computed spectrum)
            </summary>
            <param name="spectrum"></param>
            <param name="samplingRate"></param>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromSpectralPeaks(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Pitch estimation: from spectral peaks
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromSpectralPeaks(System.Single[],System.Int32,System.Single,System.Single)">
            <summary>
            Pitch estimation: from spectral peaks (given pre-computed spectrum)
            </summary>
            <param name="spectrum"></param>
            <param name="samplingRate"></param>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Pitch.FromCepstrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Pitch estimation from signal cepstrum
            </summary>
            <param name="signal"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <param name="low"></param>
            <param name="high"></param>
            <param name="cepstrumSize"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Features.Spectral">
            <summary>
            Spectral features
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Centroid(System.Single[],System.Single[])">
            <summary>
            Spectral centroid
            </summary>
            <param name="spectrum">Magnitude spectrum</param>
            <param name="frequencies">Centre frequencies</param>
            <returns>Spectral centroid</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Spread(System.Single[],System.Single[])">
            <summary>
            Spectral spread
            </summary>
            <param name="spectrum"></param>
            <param name="frequencies"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Decrease(System.Single[])">
            <summary>
            Spectral dicrease
            </summary>
            <param name="spectrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Flatness(System.Single[],System.Single)">
            <summary>
            Spectral flatness
            </summary>
            <param name="spectrum">Magnitude spectrum</param>
            <param name="minLevel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Noiseness(System.Single[],System.Single[],System.Single)">
            <summary>
            Spectral noiseness
            </summary>
            <param name="spectrum"></param>
            <param name="frequencies"></param>
            <param name="noiseFrequency"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Rolloff(System.Single[],System.Single[],System.Single)">
            <summary>
            Spectral rolloff frequency
            </summary>
            <param name="spectrum"></param>
            <param name="frequencies">Centre frequencies</param>
            <param name="rolloffPercent"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Crest(System.Single[])">
            <summary>
            Spectral crest
            </summary>
            <param name="spectrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Contrast(System.Single[],System.Single[],System.Single,System.Int32)">
            <summary>
            Spectral contrast (array of *bandCount* values)
            </summary>
            <param name="spectrum"></param>
            <param name="frequencies"></param>
            <param name="minFrequency"></param>
            <param name="bandCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Contrast(System.Single[],System.Single[],System.Int32,System.Single)">
            <summary>
            Spectral contrast in one particular spectral band (#bandNo).
            This function is called from SpectralFeatureExtractor.
            </summary>
            <param name="spectrum"></param>
            <param name="frequencies"></param>
            <param name="bandNo"></param>
            <param name="minFrequency"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Features.Spectral.Entropy(System.Single[])">
            <summary>
            Shannon entropy of a spectrum (spectrum is treated as p.d.f.)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter">
            <summary>
            Base abstract class for adaptive filters
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.Init(System.Single[])">
            <summary>
            Init weights
            </summary>
            <param name="weights"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.Process(System.Single,System.Single)">
            <summary>
            Process one sample of input signal and one sample of desired signal
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter">
            <summary>
            Adaptive filter (Least-Mean-Fourth algorithm)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter">
            <summary>
            Adaptive filter (Least-Mean-Squares algorithm)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter">
            <summary>
            Adaptive filter (Normalized Least-Mean-Fourth algorithm + Epsilon)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._eps">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="eps"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter">
            <summary>
            Adaptive filter (Normalized Least-Mean-Squares algorithm + Epsilon)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._eps">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="eps"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter">
            <summary>
            Adaptive filter (Recursive-Least-Squares algorithm)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._lambda">
            <summary>
            Lambda
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._p">
            <summary>
            Inverse corr matrix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._gains">
            <summary>
            Matrix of gain coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._dp">
            <summary>
            Temporary matrices for calculations
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._tmp">
            <summary>
            Temporary matrices for calculations
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="lambda"></param>
            <param name="initCoeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter">
            <summary>
            Adaptive filter (Sign Least-Mean-Squares algorithm)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter">
            <summary>
            Adaptive filter (Least-Mean-Squares with variable steps)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter._leakage">
            <summary>
            Leakage
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter.#ctor(System.Int32,System.Single[],System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter.Process(System.Single,System.Single)">
            <summary>
            Process input and desired samples
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64">
            <summary>
            Class representing Finite Impulse Response filters
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Kernel">
            <summary>
            Filter kernel (impulse response)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._b">
            <summary>
            
            Numerator part coefficients in filter's transfer function 
            (non-recursive part in difference equations).
            
            Note.
            This array is created from duplicated filter kernel:
            
              kernel                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Such memory layout leads to significant speed-up of online filtering.
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._kernelSize">
            <summary>
            Kernel length
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._tf">
            <summary>
            Transfer function (created lazily or set specifically if needed)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.KernelSizeForBlockConvolution">
            <summary>
            If _kernelSize exceeds this value, 
            the filtering code will always call Overlap-Save routine.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._delayLine">
            <summary>
            Internal buffer for delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._delayLineOffset">
            <summary>
            Current offset in delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Constructor accepting the 64-bit kernel of a filter
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Constructor accepting the transfer function.
            
            Coefficients (used for filtering) will be cast to doubles anyway,
            but filter will store the reference to TransferFunction object for FDA.
            
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Process(System.Double)">
            <summary>
            FIR online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ProcessAllSamples(System.Double[])">
            <summary>
            Process all signal samples in loop.
            The Process() code is inlined in the loop for better performance
            (especially for smaller kernels).
            </summary>
            <param name="samples"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ChangeKernel(System.Double[])">
            <summary>
            Change filter kernel online
            </summary>
            <param name="kernel">New kernel</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.IFilter64">
            <summary>
            Interface for any kind of filter:
            a filter can be applied to any signal transforming it to some output signal.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements offline filtering algorithm
            </summary>
            <param name="signal">Signal for filtering</param>
            <param name="method">General filtering strategy</param>
            <returns>Filtered signal</returns>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._b">
            <summary>
            Numerator part coefficients in filter's transfer function 
            (non-recursive part in difference equations)
            
            Note.
            This array is created from duplicated coefficients:
            
             numerator              _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Such memory layout leads to speed-up of online filtering.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._a">
            <summary>
            Denominator part coefficients in filter's transfer function 
            (recursive part in difference equations).
            
            Note.
            This array is created from duplicated coefficients:
            
             denominator             _a
             [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Such memory layout leads to speed-up of online filtering.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._numeratorSize">
            <summary>
            Number of numerator coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._denominatorSize">
            <summary>
            Number of denominator (feedback) coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._tf">
            <summary>
            Transfer function (created lazily or set specifically if needed)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.DefaultImpulseResponseLength">
            <summary>
            Default length of truncated impulse response
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineA">
            <summary>
            Internal buffers for delay lines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineOffsetA">
            <summary>
            Current offsets in delay lines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Parameterized constructor (from arrays of 64-bit coefficients)
            </summary>
            <param name="b">TF numerator coefficients</param>
            <param name="a">TF denominator coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parameterized constructor (from transfer function).
            
            Coefficients (used for filtering) will be cast to doubles anyway,
            but filter will store the reference to TransferFunction object for FDA.
            
            </summary>
            <param name="tf">Transfer function</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Process(System.Double)">
            <summary>
            IIR online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ChangeNumeratorCoeffs(System.Double[])">
            <summary>
            Change filter coefficients online (numerator part)
            </summary>
            <param name="b">New coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ChangeDenominatorCoeffs(System.Double[])">
            <summary>
            Change filter coefficients online (denominator / recursive part)
            </summary>
            <param name="a">New coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Normalize">
            <summary>
            Divide all filter coefficients by _a[0] and normalize TF
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64">
            <summary>
            Interface for all objects that support online filtering
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64.Process(System.Double)">
            <summary>
            Method implements online filtering (sample-by-sample)
            </summary>
            <param name="input">Input sample</param>
            <returns>Output sample</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64.Reset">
            <summary>
            Method for resetting state
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._b">
            <summary>
            Numerator part coefficients in filter's transfer function 
            (non-recursive part in difference equations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._a">
            <summary>
            Denominator part coefficients in filter's transfer function 
            (recursive part in difference equations).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._zi">
            <summary>
            State vector
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._tf">
            <summary>
            Transfer function
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Parameterized constructor (from arrays of 64-bit coefficients)
            </summary>
            <param name="b">TF numerator coefficients</param>
            <param name="a">TF denominator coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parameterized constructor (from transfer function).
            </summary>
            <param name="tf">Transfer function</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Init(System.Double[])">
            <summary>
            Init filter
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Process(System.Double)">
            <summary>
            Online filtering with initial conditions
            </summary>
            <param name="input">Input sample</param>
            <returns>Output sample</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.ZeroPhase(System.Double[],System.Int32)">
            <summary>
            Zero-phase filtering (analog of filtfilt() in MATLAB/sciPy)
            </summary>
            <param name="signal"></param>
            <param name="padLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain">
            <summary>
            Chain of filters
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain._filters">
            <summary>
            List of filters in the chain
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.#ctor(System.Collections.Generic.IEnumerable{AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter})">
            <summary>
            Constructor
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.#ctor(System.Collections.Generic.IEnumerable{AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction})">
            <summary>
            Constructor from collection of transfer functions (e.g., SOS sections).
            This constructor will create IIR (!) filters.
            </summary>
            <param name="tfs"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Add(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Add filter to the chain
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Insert(System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Insert filter at specified index into the chain
            </summary>
            <param name="idx"></param>
            <param name="filter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.RemoveAt(System.Int32)">
            <summary>
            Remove filter at specified index from the chain
            </summary>
            <param name="idx"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Process(System.Single)">
            <summary>
            Process sample by the chain of filters
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Reset">
            <summary>
            Reset state of all filters
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod">
            <summary>
            General filtering strategy
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.Auto">
            <summary>
            Filtering strategy is dynamically defined by NWaves library
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.DifferenceEquation">
            <summary>
            Filtering in time domain based on difference equations
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.OverlapAdd">
            <summary>
            Filtering in frequency domain based on OLA algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.OverlapSave">
            <summary>
            Filtering in frequency domain based on OLS algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.Custom">
            <summary>
            Filtering strategy is defined fully in code by user
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter">
            <summary>
            Class representing Finite Impulse Response filters
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Kernel">
            <summary>
            Filter kernel (impulse response)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._b" -->
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._kernelSize">
            <summary>
            Kernel length
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._tf">
            <summary>
            Transfer function (created lazily or set specifically if needed)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.KernelSizeForBlockConvolution">
            <summary>
            If _kernelSize exceeds this value, 
            the filtering code will always call Overlap-Save routine.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._delayLine">
            <summary>
            Internal buffer for delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._delayLineOffset">
            <summary>
            Current offset in delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Constructor accepting the 32-bit kernel of a filter
            </summary>
            <param name="kernel"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double})" -->
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Constructor accepting the transfer function.
            
            Coefficients (used for filtering) will be cast to floats anyway,
            but filter will store the reference to TransferFunction object for FDA.
            
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Process(System.Single)">
            <summary>
            FIR online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ProcessAllSamples(System.Single[])">
            <summary>
            Process all signal samples in loop.
            The Process() code is inlined in the loop for better performance
            (especially for smaller kernels).
            </summary>
            <param name="samples"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ApplyFilterDirectly(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            The most straightforward implementation of the difference equation:
            code the difference equation as it is (it's slower than ProcessAllSamples)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ChangeKernel(System.Single[])">
            <summary>
            Change filter kernel online
            </summary>
            <param name="kernel">New kernel</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Sequential combination of two FIR filters (also an FIR filter)
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter)">
            <summary>
            Sequential combination of an FIR and IIR filter
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Parallel combination of two FIR filters
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter)">
            <summary>
            Parallel combination of an FIR and IIR filter
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IFilter">
            <summary>
            Interface for any kind of filter:
            a filter can be applied to any signal transforming it to some output signal.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements offline filtering algorithm
            </summary>
            <param name="signal">Signal for filtering</param>
            <param name="method">General filtering strategy</param>
            <returns>Filtered signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IFilterExtensions.Process(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method implements online filtering for discrete signals
            </summary>
            <param name="filter">Some filter</param>
            <param name="input">Input signal</param>
            <param name="method">General filtering strategy</param>
            <returns>Filtered signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IFilterExtensions.Process(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method implements online filtering (frame-by-frame)
            </summary>
            <param name="input">Input block of samples</param>
            <param name="output">Block of filtered samples</param>
            <param name="count">Number of samples to filter</param>
            <param name="inputPos">Input starting position</param>
            <param name="outputPos">Output starting position</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IFilterExtensions.ProcessChunks(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            NOTE. For educational purposes and for testing online filtering.
            
            Implementation of offline filtering in time domain frame-by-frame.
            
            </summary>
            <param name="signal"></param>
            <param name="frameSize"></param>
            <param name="method"></param>
            <returns></returns>        
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter">
            <summary>
            Class representing Infinite Impulse Response filters
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._b" -->
        <!-- Badly formed XML comment ignored for member "F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._a" -->
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._numeratorSize">
            <summary>
            Number of numerator coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._denominatorSize">
            <summary>
            Number of denominator (feedback) coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._tf">
            <summary>
            Transfer function (created lazily or set specifically if needed)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.DefaultImpulseResponseLength">
            <summary>
            Default length of truncated impulse response
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineA">
            <summary>
            Internal buffers for delay lines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineOffsetA">
            <summary>
            Current offsets in delay lines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Parameterized constructor (from arrays of 32-bit coefficients)
            </summary>
            <param name="b">TF numerator coefficients</param>
            <param name="a">TF denominator coefficients</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})" -->
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parameterized constructor (from transfer function).
            
            Coefficients (used for filtering) will be cast to floats anyway,
            but filter will store the reference to TransferFunction object for FDA.
            
            </summary>
            <param name="tf">Transfer function</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Process(System.Single)">
            <summary>
            IIR online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ApplyFilterDirectly(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            The most straightforward implementation of the difference equation:
            code the difference equation as it is
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ChangeNumeratorCoeffs(System.Single[])">
            <summary>
            Change filter coefficients online (numerator part)
            </summary>
            <param name="b">New coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ChangeDenominatorCoeffs(System.Single[])">
            <summary>
            Change filter coefficients online (denominator / recursive part)
            </summary>
            <param name="a">New coefficients</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Normalize">
            <summary>
            Divide all filter coefficients by _a[0] and normalize TF
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter)">
            <summary>
            Sequential combination of an IIR filter and any LTI filter.
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter)">
            <summary>
            Parallel combination of an IIR and any LTI filter.
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IMixable.Wet">
            <summary>
            Wet mix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IMixable.Dry">
            <summary>
            Dry mix
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter">
            <summary>
            Interface for all objects that support online filtering
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter.Process(System.Single)">
            <summary>
            Method implements online filtering (sample-by-sample)
            </summary>
            <param name="input">Input sample</param>
            <returns>Output sample</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter.Reset">
            <summary>
            Method for resetting state
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter">
            <summary>
            Base class for all kinds of LTI filters.
            
            Provides abstract TransferFunction property
            and leaves methods ApplyTo() and Process() abstract.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Tf">
            <summary>
            Transfer function.
            
            It's made abstract as of ver.0.9.2 to allow subclasses using memory more efficiently.
            It's supposed that subclasses will generate TransferFunction object on the fly from filter coeffs
            OR aggregate it in internal field (only if it was set specifically from outside).
            
            The example of the latter case is when we really need double precision for FDA
            or when TF was generated from precomputed poles and zeros.
            
            The general rule is:
            
            "Use LtiFilter subclasses for FILTERING;
             Use TransferFunction class for FILTER DESIGN AND ANALYSIS".
             
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            The offline filtering algorithm that should be implemented by particular subclass
            </summary>
            <param name="signal">Signal for filtering</param>
            <param name="method">General filtering strategy</param>
            <returns>Filtered signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Process(System.Single)">
            <summary>
            The online filtering algorithm should be implemented by particular subclass
            </summary>
            <param name="input">Input sample</param>
            <returns>Output sample</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Reset">
            <summary>
            Reset filter (clear all internal buffers)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter">
            <summary>
            The base class for all filters working by the STFT overlap-add scheme:
            
            - short-time frame analysis
            - short-time frame processing
            - short-time frame synthesis (overlap-add)
            
            Subclasses must implement ProcessSpectrum() method
            that corresponds to the second stage.
            
            Also, it implements IMixable interface,
            since audio effects can be built based on this class.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Wet">
            <summary>
            Wet mix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Dry">
            <summary>
            Dry mix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._hopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._fftSize">
            <summary>
            Size of FFT for analysis and synthesis
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._gain">
            <summary>
            ISTFT normalization gain
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._overlapSize">
            <summary>
            Size of frame overlap
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._window">
            <summary>
            Window coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._dl">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._inOffset">
            <summary>
            Offset in the input delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._outOffset">
            <summary>
            Offset in the output buffer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._re">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constuctor
            </summary>
            <param name="hopSize"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Process(System.Single)">
            <summary>
            Online processing (sample after sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ProcessFrame">
            <summary>
            Process one frame (FFT block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ProcessSpectrum(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Process one spectrum at each STFT step
            </summary>
            <param name="re">Real parts of input spectrum</param>
            <param name="im">Imaginary parts of input spectrum</param>
            <param name="filteredRe">Real parts of output spectrum</param>
            <param name="filteredIm">Imaginary parts of output spectrum</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Reset">
            <summary>
            Reset filter internals
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline processing
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.A">
            <summary>
            State matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.B">
            <summary>
            Input-to-state matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.C">
            <summary>
            State-to-output matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.D">
            <summary>
            Feedthrough matrix
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter">
            <summary>
            Filter for filtering data in interleaved stereo buffers
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._filterLeft">
            <summary>
            Filter for signal in left channel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._filterRight">
            <summary>
            Filter for signal in right channel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._isRight">
            <summary>
            Internal flag for switching between left and right channels
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Constructor
            </summary>
            <param name="filterLeft"></param>
            <param name="filterRight"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.Process(System.Single)">
            <summary>
            Online filtering
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.Reset">
            <summary>
            Reset filters
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction">
            <summary>
            Class providing methods related to the transfer function of an LTI filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Numerator">
            <summary>
            Numerator of transfer function
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Denominator">
            <summary>
            Denominator of transfer function
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.CalculateZpIterations">
            <summary>
            Max iterations for calculating zeros/poles (roots of polynomials): 25000 by default
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction._zeros">
            <summary>
            Zeros of TF
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction._poles">
            <summary>
            Poles of TF
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Gain">
            <summary>
            Gain ('k' in 'zpk' notation)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(System.Double[],System.Double[])">
            <summary>
            TF constructor from numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            TF constructor from zeros/poles
            </summary>
            <param name="zeros">Zeros</param>
            <param name="poles">Poles</param>
            <param name="gain">Gain</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace)">
            <summary>
            TF constructor from state space
            </summary>
            <param name="stateSpace"></param>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.StateSpace">
            <summary>
            Get state-space representation
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Zi">
            <summary>
            Initial state 'zi' for filtering that corresponds to the steady state of the step response
            </summary>
            <returns>Initial state</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ImpulseResponse(System.Int32)">
            <summary>
            Evaluate impulse response
            </summary>
            <param name="length">Ignored for FIR filters (where IR is full copy of numerator)</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.FrequencyResponse(System.Int32)">
            <summary>
            Evaluate frequency response
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.GroupDelay(System.Int32)">
            <summary>
            Group delay calculated from TF coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.PhaseDelay(System.Int32)">
            <summary>
            Phase delay calculated from TF coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.NormalizeAt(System.Double)">
            <summary>
            Normalize frequency response at given frequency
            (normalize coefficients to map frequency response onto [0, 1])
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Normalize">
            <summary>
            Normalize numerator and denominator by Denominator[0]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ZpToTf(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method for converting zeros(poles) to TF numerator(denominator)
            </summary>
            <param name="zp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ZpToTf(System.Double[],System.Double[])">
            <summary>
            Method for converting zeros(poles) to TF numerator(denominator).
            Zeros and poles are given as double arrays of real and imaginary parts of zeros(poles).
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.TfToZp(System.Double[],System.Int32)">
            <summary>
            Method for converting TF numerator(denominator) to zeros(poles)
            </summary>
            <param name="tf"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction,AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Sequential connection
            </summary>
            <param name="tf1"></param>
            <param name="tf2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction,AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parallel connection
            </summary>
            <param name="tf1"></param>
            <param name="tf2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.FromCsv(System.IO.Stream,System.Char)">
            <summary>
            Load TF numerator and denominator from csv file
            </summary>
            <param name="stream"></param>
            <param name="delimiter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ToCsv(System.IO.Stream,System.Char)">
            <summary>
            Serialize TF numerator and denominator to csv file
            </summary>
            <param name="stream"></param>
            <param name="delimiter"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter">
            <summary>
            LTI filter based on state space representation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._b">
            <summary>
            Numerator part coefficients in filter's transfer function 
            (non-recursive part in difference equations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._a">
            <summary>
            Denominator part coefficients in filter's transfer function 
            (recursive part in difference equations).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._zi">
            <summary>
            State vector
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._tf">
            <summary>
            Transfer function
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Parameterized constructor (from arrays of 32-bit coefficients)
            </summary>
            <param name="b">TF numerator coefficients</param>
            <param name="a">TF denominator coefficients</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})" -->
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parameterized constructor (from transfer function).
            </summary>
            <param name="tf">Transfer function</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Init(System.Single[])">
            <summary>
            Init filter
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Init(System.Double[])">
            <summary>
            Init filter (cast double precision to single precision)
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter to entire signal (offline)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.FilterIc(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Offline filtering with initial conditions (for tests)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Process(System.Single)">
            <summary>
            Online filtering with initial conditions
            </summary>
            <param name="input">Input sample</param>
            <returns>Output sample</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.ZeroPhase(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Zero-phase filtering (analog of filtfilt() in MATLAB/sciPy)
            </summary>
            <param name="signal"></param>
            <param name="padLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter">
            <summary>
            Band-pass Bessel filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter">
            <summary>
            Band-stop Bessel filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter">
            <summary>
            High-pass Bessel filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter">
            <summary>
            Low-pass Bessel filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.PrototypeBessel.Reverse(System.Int32,System.Int32)">
            <summary>
            k-th coefficient of n-th order Bessel polynomial
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.PrototypeBessel.Poles(System.Int32)">
            <summary>
            Analog poles of Bessel filter
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter">
            <summary>
            BiQuad all-pass filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Change(System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter">
            <summary>
            BiQuad BP filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Change(System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter">
            <summary>
            BiQuad filter base class
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter._in1">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor for user-defined TF
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="a0"></param>
            <param name="a1"></param>
            <param name="a2"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.Process(System.Double)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter">
            <summary>
            BiQuad HP filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Change(System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter">
            <summary>
            BiQuad high-shelving filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Gain">
            <summary>
            Gain
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter">
            <summary>
            BiQuad LP filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Change(System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter">
            <summary>
            BiQuad low-shelving filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Gain">
            <summary>
            Gain
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter">
            <summary>
            BiQuad notch filter.
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Change(System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter">
            <summary>
            BiQuad peaking EQ filter.
            
            The coefficients are calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Gain">
            <summary>
            Gain
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter">
            <summary>
            Class for Butterworth IIR BP filter.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter">
            <summary>
            Class for Butterworth IIR BS filter.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter">
            <summary>
            Class for Butterworth IIR HP filter.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter">
            <summary>
            Class for Butterworth IIR LP filter.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter">
            <summary>
            Band-pass Chebyshev-II filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter">
            <summary>
            Band-stop Chebyshev-II filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter">
            <summary>
            High-pass Chebyshev-II filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter">
            <summary>
            Low-pass Chebyshev-II filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter">
            <summary>
            Band-pass Chebyshev-I filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter">
            <summary>
            Band-stop Chebyshev-I filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter">
            <summary>
            High-pass Chebyshev-I filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter">
            <summary>
            Low-pass Chebyshev-I filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter">
            <summary>
            Feedback comb filter:
            
                y[n] = b0 * x[n] - am * y[n - m]
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter._delay">
            <summary>
            Delay (m)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="m">Delay</param>
            <param name="b0">Coefficient b0</param>
            <param name="am">Coefficient am</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.Change(System.Double,System.Double)">
            <summary>
            Change coefficients (preserving the state)
            </summary>
            <param name="b0"></param>
            <param name="am"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter">
            <summary>
            Feedforward comb filter:
            
                y[n] = b0 * x[n] + bm * x[n - m]
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter._delay">
            <summary>
            Delay (m)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.#ctor(System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="m">Delay</param>
            <param name="b0">Coefficient b0</param>
            <param name="bm">Coefficient bm</param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.MakeKernel(System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Kernel generator
            </summary>
            <param name="m">Delay</param>
            <param name="b0">Coefficient b0</param>
            <param name="bm">Coefficient bm</param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.Change(System.Double,System.Double)">
            <summary>
            Change coefficients (preserving the state)
            </summary>
            <param name="b0"></param>
            <param name="bm"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter">
            <summary>
            DC removal IIR filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter._r">
            <summary>
            R parameter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter._in1">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.#ctor(System.Double)">
            <summary>
            Constructor creates simple 1st order recursive filter
            </summary>
            <param name="r">R coefficient (usually in [0.9, 1] range)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.DeEmphasisFilter">
            <summary>
            Standard de-emphasis IIR filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DeEmphasisFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="a">De-emphasis coefficient</param>
            <param name="normalize">Normalize freq response to unit gain</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.HighPassFilter.#ctor(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.LowPassFilter.#ctor(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic">
            <summary>
            Orfanidis, S. J. (2007). Lecture notes on elliptic filter design.
            URL: http://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Poles(System.Int32,System.Double,System.Double)">
            <summary>
            Poles 
            </summary>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Landen(System.Double,System.Int32)">
            <summary>
            Landen sequence
            </summary>
            <param name="k"></param>
            <param name="iterCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Cde(System.Numerics.Complex,System.Double[])">
            <summary>
            cde function
            </summary>
            <param name="x"></param>
            <param name="landen"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Sne(System.Numerics.Complex,System.Double[])">
            <summary>
            sne function
            </summary>
            <param name="x"></param>
            <param name="landen"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Asne(System.Numerics.Complex,System.Double,System.Int32)">
            <summary>
            Inverse sne function
            </summary>
            <param name="x"></param>
            <param name="k"></param>
            <param name="iterCount"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter" -->
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinLp(System.Int32,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Method for ideal lowpass FIR filter design using sinc-window method
            </summary>
            <param name="order"></param>
            <param name="freq"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinHp(System.Int32,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Method for ideal highpass FIR filter design using sinc-window method
            </summary>
            <param name="order"></param>
            <param name="freq"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinBp(System.Int32,System.Double,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Method for ideal bandpass FIR filter design using sinc-window method
            </summary>
            <param name="order"></param>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinBs(System.Int32,System.Double,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Method for ideal bandstop FIR filter design using sinc-window method
            </summary>
            <param name="order"></param>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleLp(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple LP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fp">Passband edge frequency</param>
            <param name="fa">Stopband edge frequency</param>
            <param name="wp">Passband weight</param>
            <param name="wa">Stopband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleHp(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple HP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fa">Stopband edge frequency</param>
            <param name="fp">Passband edge frequency</param>
            <param name="wa">Stopband weight</param>
            <param name="wp">Passband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleBp(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple BP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fa1">Left stopband edge frequency</param>
            <param name="fp1">Passband left edge frequency</param>
            <param name="fp2">Passband right edge frequency</param>
            <param name="fa2">Right stopband edge frequency</param>
            <param name="wa1">Left stopband weight</param>
            <param name="wp">Passband weight</param>
            <param name="wa2">Right stopband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleBs(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple BS FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fp1">Left passband edge frequency</param>
            <param name="fa1">Stopband left edge frequency</param>
            <param name="fa2">Stopband right edge frequency</param>
            <param name="fp2">Right passband edge frequency</param>
            <param name="wp1">Left passband weight</param>
            <param name="wa">Stopband weight</param>
            <param name="wp2">Right passband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,System.Double[],System.Double[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method
            </summary>
            <param name="order">Filter order</param>
            <param name="magnitudeResponse">Magnitude response</param>
            <param name="phaseResponse">Phase response</param>
            <param name="window">Window</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method
            </summary>
            <param name="order">Filter order</param>
            <param name="frequencyResponse">Complex frequency response</param>
            <param name="window">Window</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,System.Single[],System.Single[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method (32-bit precision)
            </summary>
            <param name="order">Filter order</param>
            <param name="magnitudeResponse">Magnitude response</param>
            <param name="phaseResponse">Phase response</param>
            <param name="window">Window</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirLpToHp(System.Double[])">
            <summary>
            Method for making HP filter from the linear-phase LP filter
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirHpToLp(System.Double[])">
            <summary>
            Method for making LP filter from the linear-phase HP filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirBpToBs(System.Double[])">
            <summary>
            Method for making BS filter from the linear-phase BP filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirBsToBp(System.Double[])">
            <summary>
            Method for making BP filter from the linear-phase BS filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirLpTf(System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for low-pass pole filter
            </summary>
            <param name="freq">Cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Transfer function</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirHpTf(System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for high-pass pole filter
            </summary>
            <param name="freq">Cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Transfer function</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirBpTf(System.Double,System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for band-pass pole filter
            </summary>
            <param name="freq1">Left cutoff frequency in range [0, 0.5]</param>
            <param name="freq2">Right cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Transfer function</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirBsTf(System.Double,System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for band-reject pole filter
            </summary>
            <param name="freq1">Left cutoff frequency in range [0, 0.5]</param>
            <param name="freq2">Right cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Transfer function</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.SosToTf(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction[])">
            <summary>
            Second-order sections to zpk.
            </summary>
            <param name="sos"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.TfToSos(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Zpk to second-order sections.
            </summary>
            <param name="tf">Transfer function</param>
            <returns>Array of SOS transfer functions</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.RemoveConjugated(System.Collections.Generic.List{System.Numerics.Complex})">
            <summary>
            Leave only one of two conjugated numbers in the list of complex numbers
            </summary>
            <param name="arr"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks">
            <summary>
            Static class with methods providing general shapes of filter banks:
            
                - triangular
                - rectangular
                - FIR bandpass (close to trapezoidal, slightly overlapping)
                - BiQuad bandpass
            
            ...and methods for obtaining the most widely used frequency bands:
            
                - Herz bands
                - Mel bands (HTK and Slaney)
                - Bark bands (uniform and Slaney)
                - Critical bands
                - ERB filterbank
                - Octaves (from MPEG-7)
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Triangular(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns universal triangular filterbank weights based on given frequencies.
            </summary>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel) used here only for proper weighting</param>
            <returns>Array of triangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Rectangular(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns universal rectangular filterbank weights based on given frequencies.
            </summary>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel)</param>
            <returns>Array of rectangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Trapezoidal(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns FIR bandpass (close to trapezoidal) filterbank based on given frequencies.
            </summary>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel)</param>
            <returns>Array of rectangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BiQuad(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[])">
            <summary>
            Method returns BiQuad bandpass overlapping filters based on given frequencies.
            </summary>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <returns>Array of BiQuad bandpass filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.UniformBands(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            This general method returns frequency tuples for uniformly spaced frequency bands on any scale.
            </summary>
            <param name="scaleMapper">The function that converts Hz to other frequency scale</param>
            <param name="inverseMapper">The function that converts frequency from alternative scale back to Hz</param>
            <param name="filterCount">Number of filters</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.HerzBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Herz scale.
            </summary>
            <param name="combFilterCount">Number of filters</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Herz filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Mel scale.
            </summary>
            <param name="melFilterCount">Number of mel filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Mel filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBandsSlaney(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Mel scale
            (according to M.Slaney's formula).
            </summary>
            <param name="melFilterCount">Number of mel filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Mel filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Bark scale (Traunmueller, 1990).
            </summary>
            <param name="barkFilterCount">Number of bark filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Bark filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBandsSlaney(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Bark scale (Wang, 1992).
            </summary>
            <param name="barkFilterCount">Number of bark filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Bark filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.CriticalBands(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Method returns frequency tuples for critical bands.
            </summary>
            <param name="filterCount">Number of filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <returns>Array of frequency tuples for each Critical Band filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.OctaveBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for octave bands.
            </summary>
            <param name="octaveCount">Number of octave filters to create</param>
            <param name="samplingRate">Assumed sampling rate of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each octave filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBankSlaney(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper)">
            <summary>
            Method creates overlapping triangular mel filters (as suggested by Malcolm Slaney).
            </summary>
            <param name="erbFilterCount">Number of mel filters</param>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="normalizeGain">True if gain should be normalized; false if all filters should have same height 1.0</param>
            <param name="vtln">VTLN frequency warper</param>
            <returns>Array of mel filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBankSlaney(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Method creates overlapping trapezoidal bark filters (as suggested by Malcolm Slaney).
            </summary>
            <param name="filterCount"></param>
            <param name="fftSize"></param>
            <param name="samplingRate"></param>
            <param name="lowFreq"></param>
            <param name="highFreq"></param>
            <param name="width">Constant width of each band in Bark</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Erb(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method creates overlapping ERB filters (ported from Malcolm Slaney's MATLAB code).
            </summary>
            <param name="erbFilterCount">Number of ERB filters</param>
            <param name="fftSize">Assumed size of FFT</param>
            <param name="samplingRate">Assumed sampling rate</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="normalizeGain">True if gain should be normalized; false if all filters should have same height 1.0</param>
            <returns>Array of ERB filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Normalize(System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],System.Single[][])">
            <summary>
            Normalize weights (so that energies in each band are approx. equal)
            </summary>
            <param name="filterCount"></param>
            <param name="frequencies"></param>
            <param name="filterBank"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Apply(System.Single[][],System.Single[],System.Single[])">
            <summary>
            Method applies filters to spectrum and fills resulting filtered spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Apply(System.Single[][],System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Method applies filters to sequence of spectra
            </summary>
            <param name="filterbank"></param>
            <param name="spectrogram"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndLog(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does Ln() on resulting spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="floor">log floor</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndLog10(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does Log10() on resulting spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="floor">log floor</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndToDecibel(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does 10*Log10() on resulting spectrum
            (added to compare MFCC coefficients with librosa results)
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="minLevel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndPow(System.Single[][],System.Single[],System.Single[],System.Double)">
            <summary>
            Method applies filters to spectrum and then does Pow(x, power) on resulting spectrum.
            In PLP: power=1/3 (cubic root).
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="power"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez">
            <summary>
            Optimal equiripple filter designer based on Remez (Parks-McClellan) algorithm.
            
            Example:
            
                var order = 57;
                var freqs = new double[] { 0, 0.15, 0.17, 0.5 };
                var response = new double[] { 1, 0 };
                var weights = new double[] { 0.01, 0.1 };
                
                var remez = new Remez(order, freqs, response, weights);
                
                var kernel = remez.Design();
                
                // We can monitor the following properties:
            
                remez.Iterations
                remez.ExtremalFrequencies
                remez.InterpolatedResponse
                remez.Error
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Order">
            <summary>
            Filter order
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Iterations">
            <summary>
            Number of iterations
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.K">
            <summary>
            Number of extremal frequencies (K = Order/2 + 2)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.InterpolatedResponse">
            <summary>
            Interpolated frequency response
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Error">
            <summary>
            Array of errors
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.ExtremalFrequencies">
            <summary>
            Extremal frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Tolerance">
            <summary>
            Tolerance (for computing denominators)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._extrs">
            <summary>
            Indices of extremal frequencies in the grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._grid">
            <summary>
            Grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._freqs">
            <summary>
            Band edge frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._desired">
            <summary>
            Desired frequency response on entire grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._weights">
            <summary>
            Weights on entire grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._points">
            <summary>
            Points for interpolation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._gammas">
            <summary>
            Gamma coefficients used in Lagrange interpolation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._cosTable">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.#ctor(System.Int32,System.Double[],System.Double[],System.Double[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="freqs"></param>
            <param name="desired"></param>
            <param name="weights"></param>
            <param name="gridDensity"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.MakeGrid(System.Double[],System.Double[],System.Int32)">
            <summary>
            Make grid (uniform in each band)
            </summary>
            <param name="gridDensity"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.InitExtrema">
            <summary>
            Uniform initialization of extremal frequencies
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Design(System.Int32)">
            <summary>
            Design optimal equiripple filter
            </summary>
            <param name="maxIterations">Max number of iterations</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.UpdateCoefficients">
            <summary>
            Update gamma coefficients, interpolation points and delta
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.ImpulseResponse">
            <summary>
            Reconstruct impulse response from interpolated frequency response
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Gamma(System.Int32)">
            <summary>
            Compute gamma coefficient
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Lagrange(System.Double)">
            <summary>
            Barycentric Lagrange interpolation
            </summary>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.DbToPassbandWeight(System.Double)">
            <summary>
            Convert ripple decibel value to passband weight
            </summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.DbToStopbandWeight(System.Double)">
            <summary>
            Convert ripple decibel value to stopband weight
            </summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.EstimateOrder(System.Double,System.Double,System.Double,System.Double)" -->
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.EstimateOrder(System.Double[],System.Double[])">
            <summary>
            Estimate order of a filter with custom bands.
            
            Parameters are give in conventional format. For example:
            
            freqs: { 0, 0.2, 0.22, 0.32, 0.33, 0.5 }
            deltas: { 0.01, 0.1, 0.06 }
            
            </summary>
            <param name="freqs"></param>
            <param name="deltas"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper">
            <summary>
            Vocal Tract Length Normalization (VTLN) similar to Kaldi implementation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._lowFreq">
            <summary>
            Lower frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._highFreq">
            <summary>
            Upper frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._lowVtln">
            <summary>
            Lower frequency for VTLN
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._highVtln">
            <summary>
            Upper frequency for VTLN
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._scale">
            <summary>
            Some intermediate parameters for calculations
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="alpha">Warping factor</param>
            <param name="lowFreq">Lower frequency</param>
            <param name="highFreq">Upper frequency</param>
            <param name="lowVtln">Lower frequency for VTLN</param>
            <param name="highVtln">Upper frequency for VTLN</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper.Warp(System.Double)">
            <summary>
            Warp frequency
            </summary>
            <param name="freq">Frequency</param>
            <returns>Warped frequency</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter">
            <summary>
            Hilbert filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.Size">
            <summary>
            Size of the filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.MakeKernel(System.Int32)">
            <summary>
            Kernel generator
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MedianFilter">
            <summary>
            Nonlinear median filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Size">
            <summary>
            The size of median filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements median filtering algorithm
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter">
            <summary>
            Class providing non-recursive implementation of N-sample MA filter.
            
            Actually MA filter belongs to FIR filters (so it's inherited from FirFilter);
            however it can be realized also (and more efficiently) as a recursive filter (see below).
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.Size">
            <summary>
            Size of the filter: number of samples for averaging
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.MakeKernel(System.Int32)">
            <summary>
            Kernel generator
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter">
            <summary>
            Class providing recursive implementation of N-sample MA filter:
            
                y[n] = x[n] / N - x[n - N] / N + y[n - 1]
            
            i.e. 
                B = [1/N, 0, 0, 0, 0, ... , 0, -1/N]
                A = [1, -1]
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Size">
            <summary>
            Size of the filter: number of samples for averaging
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter._out1">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.MakeNumerator(System.Int32)">
            <summary>
            TF generator
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Apply filter by fast recursive strategy
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter">
            <summary>
            Class for one-pole high-pass filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.SetCoefficients(System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.Change(System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter">
            <summary>
            Class for one-pole low-pass filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.Freq">
            <summary>
            Frequency
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.SetCoefficients(System.Double)">
            <summary>
            Set filter coefficients
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.Change(System.Double)">
            <summary>
            Change filter parameters (preserving its state)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter">
            <summary>
            One-Pole filter base class
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter._prev">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.#ctor(System.Double,System.Double)">
            <summary>
            Constructor for user defined coefficients
            </summary>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.Reset">
            <summary>
            Reset filter
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem">
            <summary>
            System of polyphase filters
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Filters">
            <summary>
            Polyphase filters with transfer function E(z^k).
            
            Example:
            h = [1, 2, 3, 4, 3, 2, 1],  k = 3
            
            e0 = [1, 0, 0, 4, 0, 0, 1]
            e1 = [0, 2, 0, 0, 3, 0, 0]
            e2 = [0, 0, 3, 0, 0, 2, 0]
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.MultirateFilters">
            <summary>
            Polyphase filters with transfer function E(z) used for multi-rate processing.
            
            h = [1, 2, 3, 4, 3, 2, 1],  k = 3
            
            e0 = [1, 4, 1]
            e1 = [2, 3, 0]
            e2 = [3, 2, 0]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="filterCount"></param>
            <param name="type">1 or 2</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Polyphase decimation (for type-I systems)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Polyphase interpolation (for type-II systems)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Process(System.Single)">
            <summary>
            Online processing.
            Inefficient, but helps understanding how polyphase filters work
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline processing
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter">
            <summary>
            Standard pre-emphasis FIR filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter._prevSample">
            <summary>
            Delay line
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Constructor computes simple 1st order kernel
            </summary>
            <param name="a">Pre-emphasis coefficient</param>
            <param name="normalize">Normalize freq response to unit gain</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.Process(System.Single)">
            <summary>
            Online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.RastaFilter">
            <summary>
            RASTA filter (used for robust speech processing)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.RastaFilter.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter">
            <summary>
            Savitzky-Golay filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.Size">
            <summary>
            Size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size of the filter, window length (must be odd number)</param>
            <param name="deriv"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.MakeKernel(System.Int32,System.Int32)">
            <summary>
            Kernel generator.
            It simply gives coefficient from precomputed arrays
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter">
            <summary>
            N-th order Thiran allpass interpolation filter for delay 'Delta' (samples)
            
            N = 13
            Delta = 13 + 0.4
            
            https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.#ctor(System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="order"></param>
            <param name="delta"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.MakeTf(System.Int32,System.Double)">
            <summary>
            TF generator
            </summary>
            <param name="order"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.ThiranCoefficient(System.Int32,System.Int32,System.Double)">
            <summary>
            k-th coefficient in TF denominator
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.WienerFilter">
            <summary>
            Wiener filter.
            Implementation is identical to scipy.signal.wiener().
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.WienerFilter._size">
            <summary>
            Size of the Wiener filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.WienerFilter._noise">
            <summary>
            Estimated noise power
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.WienerFilter.#ctor(System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
            <param name="noise"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver">
            <summary>
            Class responsible for complex-valued convolution.
            
            ComplexConvolver does not participate in heavy calculations,
            so it does not contain internal buffers.
            
            Memory is allocated for each operation ad-hoc.
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.Convolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast convolution via FFT for general complex-valued case
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.Deconvolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast deconvolution via FFT for general complex-valued case.
             
            NOTE!
            
            Deconvolution is an experimental feature.
            It's problematic due to division by zero.
            
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver">
            <summary>
            Class responsible for real-valued convolution
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver._fftSize">
            <summary>
            FFT size
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="fftSize">FFT size</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.PrepareMemory(System.Int32)">
            <summary>
            Prepare all necessary arrays for calculations
            </summary>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.Convolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Convolution
            </summary>
            <param name="signal">Signal of length N</param>
            <param name="kernel">Kernel of length M</param>
            <returns>Convolution signal of length N + M - 1</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.Convolve(System.Single[],System.Single[],System.Single[])">
            <summary>
            Fast convolution via FFT for arrays of samples (maximally in-place).
            This version is best suited for block processing when memory needs to be reused.
            Input arrays must have size equal to the size of FFT.
            FFT size MUST be set properly in constructor!
            </summary>
            <param name="input">Real parts of the 1st signal (zero-padded)</param>
            <param name="kernel">Real parts of the 2nd signal (zero-padded)</param>
            <param name="output">Real parts of resulting convolution (zero-padded)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.CrossCorrelate(System.Single[],System.Single[],System.Single[])">
            <summary>
            Fast cross-correlation via FFT for arrays of samples (maximally in-place).
            This version is best suited for block processing when memory needs to be reused.
            Input arrays must have size equal to the size of FFT.
            FFT size MUST be set properly in constructor!
            </summary>
            <param name="input1">Real parts of the 1st signal (zero-padded)</param>
            <param name="input2">Real parts of the 2nd signal (zero-padded)</param>
            <param name="output">Real parts of resulting cross-correlation (zero-padded if center == 0)</param>
            <param name="center">Position of central sample for the case of 2*CENTER-1 cross-correlation 
            (if it is set then resulting array has length of CENTER)</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver">
            <summary>
            Class responsible for OLA block convolution.
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._kernel">
            <summary>
            Filter kernel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._fftSize">
            <summary>
            FFT size (also the size of one analyzed chunk)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._bufferOffset">
            <summary>
            Offset in the input delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._outputBufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._kernelSpectrumRe">
            <summary>
            internal buffers
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.Process(System.Single)">
            <summary>
            OLA online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLA filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.Reset">
            <summary>
            Reset filter internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64">
            <summary>
            Class responsible for OLA block convolution (double precision).
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._kernel">
            <summary>
            Filter kernel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._fftSize">
            <summary>
            FFT size (also the size of one analyzed chunk)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._bufferOffset">
            <summary>
            Offset in the input delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._outputBufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._kernelSpectrumRe">
            <summary>
            internal buffers
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.Process(System.Double)">
            <summary>
            OLA online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLA filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.Reset">
            <summary>
            Reset filter internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver">
            <summary>
            Class responsible for OLS block convolution.
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._kernel">
            <summary>
            Filter kernel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._fftSize">
            <summary>
            FFT size (also the size of one analyzed chunk)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._bufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._outputBufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._kernelSpectrumRe">
            <summary>
            internal buffers
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.Process(System.Single)">
            <summary>
            OLS online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLS filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.Reset">
            <summary>
            Reset filter internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64">
            <summary>
            Class responsible for OLS block convolution (double precision).
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._kernel">
            <summary>
            Filter kernel
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._fftSize">
            <summary>
            FFT size (also the size of one analyzed chunk)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._bufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._outputBufferOffset">
            <summary>
            Offset in the delay line
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._kernelSpectrumRe">
            <summary>
            internal buffers
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.Process(System.Double)">
            <summary>
            OLS online filtering (sample-by-sample)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLS filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.Reset">
            <summary>
            Reset filter internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower">
            <summary>
            Envelope follower (detector)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._attackTime">
            <summary>
            Attack time
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._releaseTime">
            <summary>
            Release time
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._env">
            <summary>
            Current envelope sample
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._ga">
            <summary>
            Attack coefficient
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._gr">
            <summary>
            Release coefficient
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._fs">
            <summary>
            Sampling rate
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="samplingRate"></param>
            <param name="attackTime"></param>
            <param name="releaseTime"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.Process(System.Single)">
            <summary>
            Envelope following is essentialy a low-pass filtering
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor">
            <summary>
            Class for reconstructing signal from a given power / magnitude spectrogram
            based on Griffin-Lim iterative algorithm.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor._stft">
            <summary>
            STFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor._magnitudes">
            <summary>
            Magnitude part of the spectrogram
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.#ctor(System.Collections.Generic.List{System.Single[]},AI.BackEnds.DSP.NWaves.Transforms.Stft,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="spectrogram"></param>
            <param name="stft"></param>
            <param name="power"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.Iterate(System.Single[])">
            <summary>
            One iteration of reconstruction
            </summary>
            <param name="signal">Signal reconstructed at previous iteration</param>
            <returns>Reconstructed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.Reconstruct(System.Int32)">
            <summary>
            Reconstruct iteratively
            </summary>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator">
            <summary>
            HPS based on median filtering.
            
            D.Fitzgerald. Harmonic/percussive separation using median filtering.
            13th International Conference on Digital Audio Effects (DAFX10), Graz, Austria, 2010.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._stft">
            <summary>
            Internal STFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._mask">
            <summary>
            Masking function
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._medianHarmonic">
            <summary>
            Median filter for time axis
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._medianPercussive">
            <summary>
            Median filter for frequency axis
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Operations.HpsMasking)">
            <summary>
            Constructor
            </summary>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
            <param name="harmonicWinSize"></param>
            <param name="percussiveWinSize"></param>
            <param name="masking"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.EvaluateSpectrograms(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Evaluate harmonic and percussive mag-phase spectrograms from given signal.
            Both spectrogram objects share the same phase array.
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.EvaluateSignals(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Evaluate harmonic and percussive signals from given signal
            </summary>
            <param name="signal"></param>
            <returns>Harmonic signal and percussive signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.HpsMasking">
            <summary>
            Masking mode for HPS algorithm
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Modulator">
            <summary>
             Class providing modulation methods:
            
                - ring
                - amplitude
                - frequency
                - phase
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Ring(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Ring modulation (RM)
            </summary>
            <param name="carrier">Carrier signal</param>
            <param name="modulator">Modulator signal</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Amplitude(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single)">
            <summary>
            Amplitude modulation (AM)
            </summary>
            <param name="carrier">Carrier signal</param>
            <param name="modulatorFrequency">Modulator frequency</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <returns>AM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Frequency(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single,System.Single)">
            <summary>
            Frequency modulation (FM)
            </summary>
            <param name="baseband">Baseband signal</param>
            <param name="carrierAmplitude">Carrier amplitude</param>
            <param name="carrierFrequency">Carrier frequency</param>
            <param name="deviation">Frequency deviation</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.FrequencySinusoidal(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sinusoidal frequency modulation (FM)
            </summary>
            <param name="carrierFrequency">Carrier signal frequency</param>
            <param name="carrierAmplitude">Carrier signal amplitude</param>
            <param name="modulatorFrequency">Modulator frequency</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <param name="length">Length of FM signal</param>
            <param name="samplingRate">Sampling rate</param>
            <returns>Sinusoidal FM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.FrequencyLinear(System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Linear frequency modulation (FM)
            </summary>
            <param name="carrierFrequency">Carrier signal frequency</param>
            <param name="carrierAmplitude">Carrier signal amplitude</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <param name="length">Length of FM signal</param>
            <param name="samplingRate">Sampling rate</param>
            <returns>Sinusoidal FM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Phase(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single,System.Single)">
            <summary>
            Phase modulation (PM)
            </summary>
            <param name="baseband">Baseband signal</param>
            <param name="carrierAmplitude">Carrier amplitude</param>
            <param name="carrierFrequency">Carrier frequency</param>
            <param name="deviation">Frequency deviation</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.DemodulateAmplitude(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Simple amplitude demodulation based on Hilbert transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.DemodulateFrequency(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Simple frequency demodulation based on Hilbert transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Operation">
            <summary>
            Main operations implemented:
            
                - convolution
                - cross-correlation
                - block convolution
                - deconvolution
                - resampling
                - time-stretching
                - rectification
                - envelope detection
                - spectral subtraction
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast convolution via FFT of real-valued signals.
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Fast convolution via FFT for general complex-valued case
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(System.Double[],System.Double[])">
            <summary>
            Fast convolution for double arrays (used mainly in filter design)
            </summary>
            <param name="input"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Fast complex cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.BlockConvolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements block convolution of signals (using either OLA or OLS algorithm)
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Deconvolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Deconvolution via FFT for general complex-valued case.
             
            NOTE!
            
            Deconvolution is an experimental feature.
            It's problematic due to division by zero.
            
            </summary>
            <param name="signal">Signal</param>
            <param name="kernel">Kernel</param>
            <returns>Deconvolved signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Interpolation followed by low-pass filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Decimation preceded by low-pass filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Resample(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Band-limited resampling
            </summary>
            <param name="signal"></param>
            <param name="newSamplingRate"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.ResampleUpDown(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Simple resampling (as the combination of interpolation and decimation)
            </summary>
            <param name="signal"></param>
            <param name="up"></param>
            <param name="down"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.TimeStretch(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Double,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm)">
            <summary>
            Time stretching with parameters set by user
            </summary>
            <param name="signal">Signal</param>
            <param name="stretch">Stretch factor (ratio)</param>
            <param name="windowSize">Window size (for vocoders - FFT size)</param>
            <param name="hopSize">Hop size</param>
            <param name="algorithm">Algorithm for TSM (optional)</param>
            <returns>Time stretched signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.TimeStretch(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Double,AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm)">
            <summary>
            Time stretching with auto-derived parameters
            </summary>
            <param name="signal">Signal</param>
            <param name="stretch">Stretch factor (ratio)</param>
            <param name="algorithm">Algorithm for TSM (optional)</param>
            <returns>Time stretched signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Envelope(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single)">
            <summary>
            Method for extracting the envelope of a signal
            </summary>
            <param name="signal">Signal</param>
            <param name="attackTime"></param>
            <param name="releaseTime"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.FullRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Full rectification
            </summary>
            <param name="signal">Signal</param>
            <returns>Fully rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.HalfRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Half rectification
            </summary>
            <param name="signal">Signal</param>
            <returns>Half rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.SpectralSubtract(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Spectral subtraction
            </summary>
            <param name="signal"></param>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.ConvolveDirect(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct convolution by formula in time domain
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelateDirect(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct cross-correlation by formula in time domain
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Resampler">
            <summary>
            Class responsible for sampling rate conversion
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Resampler.MinResamplingFilterOrder">
            <summary>
            The order of FIR LP resampling filter (minimally required).
            This constant should be used for simple up/down ratios.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Interpolation followed by low-pass filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Decimation preceded by low-pass filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Resample(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Band-limited resampling
            </summary>
            <param name="signal"></param>
            <param name="newSamplingRate"></param>
            <param name="filter"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.ResampleUpDown(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Simple resampling as the combination of interpolation and decimation.
            </summary>
            <param name="signal"></param>
            <param name="up"></param>
            <param name="down"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor">
            <summary>
            Class that implements Spectral subtraction algorithm according to
            
            [1979] M. Berouti, R. Schwartz, J. Makhoul
            "Enhancement of Speech Corrupted by Acoustic Noise".
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor._noiseEstimate">
            <summary>
            Noise estimate
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.#ctor(System.Single[],System.Int32,System.Int32)">
            <summary>
            Constructor from float[] noise
            </summary>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.#ctor(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Constructor from DiscreteSignal noise
            </summary>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.ProcessSpectrum(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Process one spectrum at each STFT step
            </summary>
            <param name="re">Real parts of input spectrum</param>
            <param name="im">Imaginary parts of input spectrum</param>
            <param name="filteredRe">Real parts of output spectrum</param>
            <param name="filteredIm">Imaginary parts of output spectrum</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.EstimateNoise(System.Single[],System.Int32,System.Int32)">
            <summary>
            Estimate noise power spectrum
            </summary>
            <param name="noise"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.EstimateNoise(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Estimate noise power spectrum
            </summary>
            <param name="noise"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch">
            <summary>
            TSM processor based on Paul stretch algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch._rand">
            <summary>
            Randomizer for phases
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.ProcessSpectrum">
            <summary>
            Process spectrum at each STFT step: simply randomize phases
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.Reset">
            <summary>
            Reset (nothing to do here)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder">
            <summary>
            Phase vocoder with identity phase locking [Puckette].
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._mag">
            <summary>
            Array of spectrum magnitudes (at current step)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._phase">
            <summary>
            Array of spectrum phases (at current step)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._delta">
            <summary>
            Array of phase deltas
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._peaks">
            <summary>
            Array of peak positions (indices)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
            <param name="phaseLocking"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder.ProcessSpectrum">
            <summary>
            Process spectrum with phase-locking at each STFT step
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder">
            <summary>
            Conventional Phase Vocoder
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._hopAnalysis">
            <summary>
            Hop size at analysis stage (STFT decomposition)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._hopSynthesis">
            <summary>
            Hop size at synthesis stage (STFT merging)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._fftSize">
            <summary>
            Size of FFT for analysis and synthesis
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._stretch">
            <summary>
            Stretch ratio
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._window">
            <summary>
            Window coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._gain">
            <summary>
            ISTFT normalization gain
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._omega">
            <summary>
            Linearly spaced frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._re">
            <summary>
            Internal buffer for real parts of analyzed block
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._im">
            <summary>
            Internal buffer for imaginary parts of analyzed block
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._prevPhase">
            <summary>
            Array of phases computed at previous step
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._phaseTotal">
            <summary>
            Array of new synthesized phases
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Phase Vocoder algorithm
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.ProcessSpectrum">
            <summary>
            Process one spectrum at each STFT step.
            This routine is different for different PV-based techniques.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.Reset">
            <summary>
            Reset phase vocoder
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm">
            <summary>
            Algorithm for time scale modification
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PhaseVocoder">
            <summary>
            Phase vocoder
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PhaseVocoderPhaseLocking">
            <summary>
            Phase vocoder with phase-locking
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.Wsola">
            <summary>
            Waveform similarity-based Synchrnoized Overlap-Add
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PaulStretch">
            <summary>
            Paul stretch
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola">
            <summary>
            Waveform-Synchronized Overlap-Add
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._stretch">
            <summary>
            Stretch ratio
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._windowSize">
            <summary>
            Window size
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._hopAnalysis">
            <summary>
            Hop size at analysis stage (STFT decomposition)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._hopSynthesis">
            <summary>
            Hop size at synthesis stage (STFT merging)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._maxDelta">
            <summary>
            Maximum length of the fragment for search of the most similar waveform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._userParameters">
            <summary>
            True if parameters were set by user (not by default)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._convolver">
            <summary>
            Internal convolver
            (will be used for evaluating auto-correlation if the window size is too big)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._cc">
            <summary>
            Cross-correlation signal
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.#ctor(System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor with detailed WSOLA settings
            </summary>
            <param name="stretch">Stretch ratio</param>
            <param name="windowSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.#ctor(System.Double)">
            <summary>
            Constructor with smart parameter autoderivation 
            </summary>
            <param name="stretch"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.PrepareConvolver">
            <summary>
            For large window sizes prepare the internal convolver
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            WSOLA algorithm
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.WaveformSimilarityPos(System.Single[],System.Single[],System.Int32)">
            <summary>
            Position of the best found waveform similarity
            </summary>
            <param name="current"></param>
            <param name="prev"></param>
            <param name="maxDelta"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.AdsrBuilder">
            <summary>
            ASDR envelope builder
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.AdsrBuilder._a">
            <summary>
            One-pole filter coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.AdsrBuilder._b">
            <summary>
            One-pole filter coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.AdsrBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for ADSR parameters in terms of sample count
            </summary>
            <param name="attack"></param>
            <param name="decay"></param>
            <param name="sustain"></param>
            <param name="release"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.AdsrBuilder.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor for ADSR parameters in terms of time duration (in sec)
            </summary>
            <param name="attack"></param>
            <param name="decay"></param>
            <param name="sustain"></param>
            <param name="release"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.AwgnBuilder">
            <summary>
            Average White Gaussian Noise
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.AwgnBuilder._mu">
            <summary>
            Mean
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.AwgnBuilder._sigma">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.AwgnBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.AwgnBuilder.NextSample">
            <summary>
            Method generates additive white gaussian noise by Box-Muller transform.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder">
            <summary>
            Class for generating chirp signals
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder._f0">
            <summary>
            Start frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder._f1">
            <summary>
            End frequency
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.ChirpBuilder.NextSample">
            <summary>
            Method for generating chirp signal according to formula:
            
                y[n] = A * cos(2 * pi * (f0 + k * n) / fs * n)
            
            The same could be achieved via:
            
                new Modulator().FrequencyLinear(f, amp, k, Length, SamplingRate);
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder">
            <summary>
            Class for a simple generator of one sinusoid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder._frequency">
            <summary>
            Frequency of the sinusoid (as a fraction of sampling frequency)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder._phase">
            <summary>
            Initial phase of the sinusoid (in radians)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.CosineBuilder.NextSample">
            <summary>
            Method for generating one cosine according to simple formula:
            
                y[n] = A * cos(2 * pi * f / fs * n + phase)
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.KarplusStrongBuilder">
            <summary>
            Class providing implementation of Karplus-Strong algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.KarplusStrongBuilder._frequency">
            <summary>
            Frequency in Hz
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.KarplusStrongBuilder._stretchFactor">
            <summary>
            Stretch factor (0, +INF]
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.KarplusStrongBuilder._feedback">
            <summary>
            Feedback coefficient [0, 1]
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.PadSynthBuilder">
            <summary>
            Class providing implementation of the PADSynth algorithm by Nasca Octavian Paul
            (https://zynaddsubfx.sourceforge.io/doc/PADsynth/PADsynth.htm)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder">
             <summary>
             Perlin noise (improved, 1D simplex noise)
             
             Implementation of 1D Perlin Noise ported from Stefan Gustavson's code:
             
                https://github.com/stegu/perlin-noise/blob/master/src/noise1234.c
            
             </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder._scale">
            <summary>
            Scale
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder._permutation">
            <summary>
            Table of permutations
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.GenerateSample(System.Double)">
            <summary>
            1D simplex noise
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.Gradient(System.Int32,System.Double)">
            <summary>
            Gradient
            </summary>
            <param name="hash"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.Fade(System.Double)">
            <summary>
            Improved interpolator
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Linear interpolator
            </summary>
            <param name="t"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PerlinNoiseBuilder.NextSample">
            <summary>
            Method for generating Perlin noise
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.PinkNoiseBuilder">
            <summary>
            Class for a pink noise generator
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PinkNoiseBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PinkNoiseBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PinkNoiseBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PinkNoiseBuilder.NextSample">
            <summary>
            Method implements Paul Kellet's algorithm.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder">
            <summary>
            Class for the generator of periodic pulse waves
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder._pulse">
            <summary>
            Pulse duration
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder._period">
            <summary>
            Period of pulse wave
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.PulseWaveBuilder.NextSample">
            <summary>
            Method generates simple sequence of rectangular pulses.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.RampBuilder">
            <summary>
            Class for a simple generator of a straight line signal
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.RampBuilder._slope">
            <summary>
            Slope
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.RampBuilder._intercept">
            <summary>
            Intercept
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.RampBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.RampBuilder.NextSample">
            <summary>
            Method for generating one straight line according to simple formula:
            
                y[n] = slope * n + intercept
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.RedNoiseBuilder">
            <summary>
            Class for a red (Brownian) noise generator
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.RedNoiseBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.RedNoiseBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.RedNoiseBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.RedNoiseBuilder.NextSample">
            <summary>
            Method implements fancy filtering for obtaining the red noise.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder">
            <summary>
            Class for the generator of sawtooth waves
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder._frequency">
            <summary>
            Frequency of the sawtooth wave
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SawtoothBuilder.NextSample">
            <summary>
            Method generates sawtooth wave according to the formula:
            
                s[n] = LO + (HI - LO) * (i / N)
            
            where i = n % N
                  N = fs / freq
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder">
            <summary>
            Abstract class for representing any signal builder (generator)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder._delay">
            <summary>
            Number of delay samples
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder._repeatTimes">
            <summary>
            Number of times to repeat the signal
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder._toSuperimpose">
            <summary>
            List of signals to be superimposed with the resulting signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.Signal">
            <summary>
            Resulting signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.Length">
            <summary>
            The length of the signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.SamplingRate">
            <summary>
            Sampling rate of the signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.ParameterSetters">
            <summary>
            Dictionary of setters for each parameter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.GetParametersInfo">
            <summary>
            Brief descriptions of parameters (list of their names)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.SetParameter(System.String,System.Double)">
            <summary>
            Method for setting parameter values
            </summary>
            <param name="parameterName"></param>
            <param name="parameterValue"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.NextSample">
            <summary>
            Method for online sample generation (must be implemented in subclasses)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.Reset">
            <summary>
            Reset online builder
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.Generate">
            <summary>
            Method for generating signal of particular shape 
            </summary>
            <returns>Generated signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.Build">
            <summary>
            Final or intermediate build step
            </summary>
            <returns>The signal that is currently built</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.OfLength(System.Int32)">
            <summary>
            
            </summary>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.SampledAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="samplingRate"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.DelayedBy(System.Int32)">
            <summary>
            
            </summary>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.SuperimposedWith(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SignalBuilder.RepeatedTimes(System.Int32)">
            <summary>
            
            </summary>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder">
            <summary>
            Class for a simple generator of a sinc-signal
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder._frequency">
            <summary>
            Frequency of the sinc (as a fraction of sampling frequency)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SincBuilder.NextSample">
            <summary>
            Method for generating sinc signal according to simple formula:
            
                y[n] = A * sinc(f/fs * n)
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder">
            <summary>
            Class for a simple generator of one sinusoid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder._frequency">
            <summary>
            Frequency of the sinusoid (as a fraction of sampling frequency)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder._phase">
            <summary>
            Initial phase of the sinusoid (in radians)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SineBuilder.NextSample">
            <summary>
            Method for generating one sinusoid according to simple formula:
            
                y[n] = A * sin(2 * pi * f / fs * n + phase)
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder">
            <summary>
            Class for the generator of triangle waves
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder._frequency">
            <summary>
            Frequency of the triangle wave
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.SquareWaveBuilder.NextSample">
            <summary>
            Method generates square wave
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder">
            <summary>
            Class for the generator of triangle waves
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder._frequency">
            <summary>
            Frequency of the triangle wave
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.TriangleWaveBuilder.NextSample">
            <summary>
            Method generates triangle wave according to the formula:
            
                s[n] = LO + 2 * (HI - LO) * (i / N)          when i is less than N / 2
                       HI + 2 * (LO - HI) * ((i - N/2) / N)  when i is less than N
            
            where i = n % N
                  N = fs / freq
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.WaveTableBuilder">
            <summary>
            Wave table builder
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.Builders.WhiteNoiseBuilder">
            <summary>
            Class for a white noise generator
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.WhiteNoiseBuilder._low">
            <summary>
            Lower amplitude level
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Signals.Builders.WhiteNoiseBuilder._high">
            <summary>
            Upper amplitude level
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.WhiteNoiseBuilder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.Builders.WhiteNoiseBuilder.NextSample">
            <summary>
            Method generates white noise by simply generating 
            consecutive decorrelated random samples.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal">
            <summary>
            Base class for finite complex-valued discrete-time signals.
            
            Any finite complex DT signal is stored as two arrays of data (real parts and imaginary parts)
            sampled at certain sampling rate.
            
            See also ComplexDiscreteSignalExtensions for additional functionality of complex DT signals.
            
            Note.
            1) I intentionally do not implement reusable code mechanisms (like generics or inheritance) 
               for coding DiscreteSignals and ComplexDiscreteSignals. Also for better performance 
               I did not use Complex type (instead we just work with 2 plain arrays).
               The reason is that currently ComplexDiscreteSignal is more like a helper class used in DSP internals.
               For all tasks users will most likely use real-valued DiscreteSignal or simply an array of samples.
               However they can switch between complex and real-valued signals anytime.
            
            2) Method implementations are LINQ-less for better performance.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.SamplingRate">
            <summary>
            Number of samples per unit of time (1 second)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Real">
            <summary>
            Array or real parts of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Imag">
            <summary>
            Array or imaginary parts of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Length">
            <summary>
            Length of the signal
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Double[],System.Double[],System.Boolean)">
            <summary>
            The most efficient constructor for initializing complex signals
            </summary>
            <param name="samplingRate">Sampling rate of the signal</param>
            <param name="real">Array of real parts of the complex-valued signal</param>
            <param name="imag">Array of imaginary parts of the complex-valued signal</param>
            <param name="allocateNew">Set to true if new memory should be allocated for data</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Constructor for initializing complex signals with any float enumerables
            </summary>
            <param name="samplingRate"></param>
            <param name="real"></param>
            <param name="imag"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Constructor creates the complex signal of specified length filled with specified values
            </summary>
            <param name="samplingRate"></param>
            <param name="length"></param>
            <param name="real"></param>
            <param name="imag"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
            <summary>
            Constructor for initializing complex signals with any integer enumerables
            </summary>
            <param name="samplingRate"></param>
            <param name="samples"></param>
            <param name="normalizeFactor"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Copy">
            <summary>
            Method for creating the deep copy of a complex signal
            </summary>
            <returns>New copied signal</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Item(System.Int32)">
            <summary>
            Indexer works only with array of real parts of samples. Use it with caution.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Item(System.Int32,System.Int32)">
            <summary>
            Slice the signal (Python-style)
            
                var middle = signal[900, 1200];
            
            Implementaion is LINQ-less, since Skip() would be less efficient:
                            
                return new DiscreteSignal(SamplingRate, 
                                          Real.Skip(startPos).Take(endPos - startPos),
                                          Imag.Skip(startPos).Take(endPos - startPos));
            </summary>
            <param name="startPos">Position of the first sample</param>
            <param name="endPos">Position of the last sample (exclusive)</param>
            <returns>Slice of the signal</returns>
            <exception>Overflow possible if endPos is less than startPos</exception>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Magnitude">
            <summary>
            Get real-valued signal containing magnitudes of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Power">
            <summary>
            Get real-valued signal containing squared magnitudes of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Phase">
            <summary>
            Get real-valued signal containing phases of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.PhaseUnwrapped">
            <summary>
            Get unwrapped phase
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Overloaded + (superimpose signals)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Superimposed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            Overloaded + (add constant)
            </summary>
            <param name="s">Signal</param>
            <param name="constant">Constant to add to each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            Overloaded - (subtract constant)
            </summary>
            <param name="s">Signal</param>
            <param name="constant">Constant to subtract from each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Multiply(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Single)">
            <summary>
            Overloaded * (signal amplification)
            </summary>
            <param name="s">Signal</param>
            <param name="coeff">Amplification coefficient</param>
            <returns>Amplified signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions">
            <summary>
            Any finite complex DT signal is simply two arrays of data (real and imaginary parts)
            sampled at certain sampling rate.
            
            This arrays of samples can be:
                - delayed (shifted) by positive or negative number of samples
                - superimposed with another arrays of samples (another signal)
                - concatenated with another arrays of samples (another signal)
                - repeated N times
            
            Note.
            Method implementations are LINQ-less and do Buffer.BlockCopy() for better performance.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Delay(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            Method delays the signal
                either by shifting it to the right (positive, e.g. Delay(1000))
                    or by shifting it to the left (negative, e.g. Delay(-1000))
            <param name="signal"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Superimpose(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1">Object signal</param>
            <param name="signal2">Argument signal</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Concatenate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method concatenates two signals.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Repeat(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Method returns repeated n times copy of the signal
            </summary>
            <param name="signal"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Amplify(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            In-place signal amplification by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Attenuate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            In-place signal attenuation by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.First(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Last(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            More or less efficient LINQ-less version.
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.ZeroPadded(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Method creates new zero-padded complex discrete signal from the current signal.
            </summary>
            <param name="signal">Signal</param>
            <param name="newLength">The length of a zero-padded signal.
            By default array is zero-padded to have length of next power of 2.</param>
            <returns>Zero padded complex discrete signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Multiply(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method performs the complex multiplication of two signals
            (with normalization by length)
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Divide(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method performs the complex division of two signals
            (with normalization by length)
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Unwrap(System.Double[],System.Double)">
            <summary>
            Just another way for calling Unwrap() function
            </summary>
            <param name="phase"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Magnitude(System.Tuple{System.Single[],System.Single[]})">
            <summary>
            Magnitude of complex numbers given in tuple of float arrays (re and im)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Phase(System.Tuple{System.Single[],System.Single[]})">
            <summary>
            Phase of complex numbers given in tuple of float arrays (re and im)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.ToComplexNumbers(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal">
            <summary>
            Base class for finite real-valued discrete-time signals.
            
            In general, any finite DT signal is simply an array of data sampled at certain sampling rate.
            
            See also DiscreteSignalExtensions for additional functionality of DT signals.
            
            Note. 
            Method implementations are LINQ-less for better performance.
            
            In the earliest versions of NWaves there was also an ISignal interface, however it was refactored out.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.SamplingRate">
            <summary>
            Number of samples per unit of time (1 second)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Samples">
            <summary>
            Real-valued array of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Length">
            <summary>
            Length of the signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Duration">
            <summary>
            Duration of the signal (in sec)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Single[],System.Boolean)">
            <summary>
            The most efficient constructor for initializing discrete signals
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="samples">Array of samples</param>
            <param name="allocateNew">Set to true if new memory should be allocated for data</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Constructor for creating a signal from collection of samples
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="samples">Collection of samples</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Constructor for creating a signal of specified length filled with specified values
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="length">Number of samples</param>
            <param name="value">Value of each sample</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Single)">
            <summary>
            Constructor for creating a signal from collection of integer samples
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <param name="samples">Collection of integer samples</param>
            <param name="normalizeFactor">Some normalization coefficient</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Copy">
            <summary>
            Method for creating deep copy of the signal
            </summary>
            <returns>Copy of the signal</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Item(System.Int32)">
            <summary>
            Sample indexer
            </summary>
            <param name="index">Index</param>
            <returns>Sample by index</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Item(System.Int32,System.Int32)">
            <summary>
            Slice the signal (Python-style)
            
                var middle = signal[900, 1200];
            
            Implementaion is LINQ-less, since Skip() would be less efficient:
                return new DiscreteSignal(SamplingRate, Samples.Skip(startPos).Take(endPos - startPos));
            
            </summary>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <returns>Slice of the signal</returns>
            <exception>Overflow possible if endPos is less than startPos</exception>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded binary plus (superimpose signals)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Superimposed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_UnaryNegation(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded unary minus (negated signal)
            </summary>
            <param name="s">Signal</param>
            <returns>Negated signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded binary minus (difference signal)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Difference signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded + (add constant)
            </summary>
            <param name="s">Signal</param>
            <param name="constant">Constant to add to each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded - (subtract constant)
            </summary>
            <param name="s">Signal</param>
            <param name="constant">Constant to subtract from each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Multiply(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded * (signal amplification/attenuation)
            </summary>
            <param name="s">Signal</param>
            <param name="coeff">Amplification coefficient</param>
            <returns>Amplified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Energy(System.Int32,System.Int32)">
            <summary>
            Energy of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>Energy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Energy">
            <summary>
            Energy of entire signal
            </summary>
            <returns>Energy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Rms(System.Int32,System.Int32)">
            <summary>
            RMS of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>RMS</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Rms">
            <summary>
            RMS of entire signal
            </summary>
            <returns>RMS</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.ZeroCrossingRate(System.Int32,System.Int32)">
            <summary>
            Zero-crossing rate of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>Zero-crossing rate</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.ZeroCrossingRate">
            <summary>
            Zero-crossing rate of entire signal
            </summary>
            <returns>Zero-crossing rate</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Entropy(System.Int32,System.Int32,System.Int32)">
            <summary>
            Shannon entropy of a signal fragment
            (computed from bins distributed uniformly between the minimum and maximum values of samples)
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>Shannon entropy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Entropy">
            <summary>
            Entropy of entire signal
            </summary>
            <returns>Entropy</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions">
             <summary>
             In general, any finite DT signal is simply an array of data sampled at certain sampling rate.
             
             This array of samples can be:
                 - delayed (shifted) by positive or negative number of samples
                 - superimposed with another array of samples (another signal)
                 - concatenated with another array of samples (another signal)
                 - repeated N times
                 - amplified
            
             Note.
             Method implementations are LINQ-less and do Buffer.BlockCopy() for better performance.
             </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Delay(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Method delays the signal
                either by shifting it to the right (positive, e.g. Delay(1000))
                    or by shifting it to the left (negative, e.g. Delay(-1000))
            </summary>
            <param name="signal"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Superimpose(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.SuperimposeMany(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32[])">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Subtract(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method subtracts one signal from another.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Concatenate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method concatenates two signals.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Repeat(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Method returns repeated n times copy of the signal
            </summary>
            <param name="signal"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Amplify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            In-place signal amplification by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Attenuate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            In-place signal attenuation by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.First(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Return copy of first N samples
            </summary>
            <param name="signal">Signal</param>
            <param name="sampleCount">Number of samples</param>
            <returns>Copy of the first samples of signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Last(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            More or less efficient LINQ-less version.
            Skip() would require unnecessary enumeration.
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.FullRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Full rectification (in-place)
            </summary>
            <param name="signal">Signal</param>
            <returns>Fully rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.HalfRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Half rectification (in-place)
            </summary>
            <param name="signal">Signal</param>
            <returns>Half rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.ToComplex(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method copies discrete signal samples into complex signal
            </summary>
            <param name="signal">Real-valued signal</param>
            <returns>Corresponding complex-valued signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform">
            <summary>
            Class providing methods for various cepstrum transforms:
            
                1) Complex cepstrum (direct and inverse)
                2) Real cepstrum
                3) Power cepstrum
                4) Phase cepstrum
                
            1) and 2) are analogous to MATLAB cceps/icceps and rceps, respectively.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Size">
            <summary>
            Size of cepstrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._fft">
            <summary>
            FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._logBase">
            <summary>
            Logarithm base (E or 10)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._realSpectrum">
            <summary>
            Intermediate buffer storing real parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._imagSpectrum">
            <summary>
            Intermediate buffer storing imaginary parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._unwrapped">
            <summary>
            Intermediate buffer storing unwrapped phase
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Constructor with necessary parameters
            </summary>
            <param name="cepstrumSize"></param>
            <param name="fftSize"></param>
            <param name="logBase"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Direct(System.Single[],System.Single[])">
            <summary>
            Direct complex cepstral transform:
            
            Real{IFFT(log(abs(FFT(x)) + unwrapped_phase))}
            
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct complex cepstral transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Inverse(System.Single[],System.Single[],System.Double)">
            <summary>
            Inverse complex cepstral transform
            </summary>
            <param name="cepstrum"></param>
            <param name="output"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Inverse(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Inverse complex cepstral transform
            </summary>
            <param name="cepstrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.RealCepstrum(System.Single[],System.Single[])">
            <summary>
            Real cepstrum:
            
            real{IFFT(log(abs(FFT(x))))}
            
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.PowerCepstrum(System.Single[],System.Single[])">
            <summary>
            Wiki:
            power_cepstrum = 4 * real_cepstrum ^ 2
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.PhaseCepstrum(System.Single[],System.Single[])">
            <summary>
            Wiki:
            phase_cepstrum = (complex_cepstrum - reversed_complex_cepstrum) ^ 2
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct1">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-I.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct1._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-I (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-I (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-I (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse DCT-I (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct2">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-II.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct2._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct2._dctMtxInv">
            <summary>
            IDCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-II (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-II (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-II (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-II (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct3">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-III.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct3._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct3._dctMtxInv">
            <summary>
            IDCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-III (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-III (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-III (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-III (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct4">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-IV.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct4._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-IV (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-IV (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-IV (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-IV (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct2">
            <summary>
            Fast implementation of DCT-II via FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct2._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct2._temp">
            <summary>
            Internal temporary buffer
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Direct(System.Single[],System.Single[])">
            <summary>
            Direct DCT-II via FFT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Direct DCT-II via FFT (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse DCT-II via FFT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct3">
            <summary>
            Fast implementation of DCT-III via FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct3._dct2">
            <summary>
            Internal DCT-II transformer
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.Size">
            <summary>
            DCT size
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct4">
            <summary>
            Fast implementation of DCT-IV via FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct4._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct4._temp">
            <summary>
            Internal temporary buffer
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.Size">
            <summary>
            DCT size
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.IDct.Size">
            <summary>
            DCT size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.Direct(System.Single[],System.Single[])">
            <summary>
            Direct DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Direct normalized DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse normalized DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Mdct">
            <summary>
            Class providing methods for Modified Discrete Cosine Transform (MDCT).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Mdct._dct">
            <summary>
            Internal DCT-IV transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Mdct._temp">
            <summary>
            Internal temporary buffer
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Size">
            <summary>
            MDCT size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Direct(System.Single[],System.Single[])">
            <summary>
            Direct MDCT
            </summary>
            <param name="input">Input length must be equal to 2*DctSize</param>
            <param name="output">Output length must be equal to DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse MDCT
            </summary>
            <param name="input">Input length must be equal to DctSize</param>
            <param name="output">Output length must be equal to 2*DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Direct MDCT (with normalization)
            </summary>
            <param name="input">Input length must be equal to 2*DctSize</param>
            <param name="output">Output length must be equal to DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse MDCT (with normalization)
            </summary>
            <param name="input">Input length must be equal to DctSize</param>
            <param name="output">Output length must be equal to 2*DctSize</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Fft">
            <summary>
            Class providing methods for direct and inverse Fast Fourier Transforms
            and postprocessing: magnitude spectrum, power spectrum, logpower spectrum.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Fft.Size">
            <summary>
            The size of FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._realSpectrum">
            <summary>
            Intermediate buffer storing real parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._imagSpectrum">
            <summary>
            Intermediate buffer storing imaginary parts of spectrum
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.#ctor(System.Int32)">
            <summary>
            Constructor accepting the size of FFT
            </summary>
            <param name="fftSize">Size of FFT</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Direct(System.Single[],System.Single[])">
            <summary>
            Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse Fast Fourier Transform algorithm (with normalization by FFT size)
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.MagnitudeSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Magnitude spectrum:
            
                spectrum = sqrt(re * re + im * im)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Magnitude spectrum (array MUST have size at least _fftSize / 2 + 1)</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.PowerSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Power spectrum (normalized by default):
            
                spectrum =   (re * re + im * im) / fftSize
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Power spectrum (array MUST have size at least _fftSize / 2 + 1)</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.MagnitudeSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.PowerSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Shift(System.Single[])">
            <summary>
            FFT shift (in-place)
            </summary>
            <param name="samples"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Fft64">
            <summary>
            Class providing methods for direct and inverse Fast Fourier Transforms
            and postprocessing: magnitude spectrum, power spectrum, logpower spectrum.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Size">
            <summary>
            The size of FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft64._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft64._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.#ctor(System.Int32)">
            <summary>
            Constructor accepting the size of FFT
            </summary>
            <param name="fftSize">Size of FFT</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Direct(System.Double[],System.Double[])">
            <summary>
            Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Inverse(System.Double[],System.Double[])">
            <summary>
            Inverse Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.InverseNorm(System.Double[],System.Double[])">
            <summary>
            Inverse Fast Fourier Transform algorithm (with normalization by FFT size)
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Goertzel">
            <summary>
            Class for Goertzel algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Goertzel._fftSize">
            <summary>
            Size of FFT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="fftSize">Size of FFT</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.Direct(System.Single[],System.Int32)">
            <summary>
            Very simple implementation of Goertzel algorithm
            </summary>
            <param name="input">Input array</param>
            <param name="n">Number of the frequency component</param>
            <returns>nth component of a complex spectrum</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Overloaded method for DiscreteSignal
            </summary>
            <param name="input">Input signal</param>
            <param name="n">Number of the frequency component</param>
            <returns>nth component of a complex spectrum</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Size">
            <summary>
            Size of transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform._im">
            <summary>
            Internal array for imaginary parts
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Direct(System.Single[])">
            <summary>
            Direct transform
            </summary>
            <param name="re"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Inverse(System.Single[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform">
            <summary>
            Hilbert Transform
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Size">
            <summary>
            Size (length) of Hilbert Transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform._fft32">
            <summary>
            Fft transformer, single precision
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform._fft64">
            <summary>
            Fft transformer, double precision
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="length">Size of Hilbert Transform</param>
            <param name="doublePrecision"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.AnalyticSignal(System.Double[],System.Boolean)">
            <summary>
            Compute complex analytic signal, double precision
            </summary>
            <param name="samples">Array of samples</param>
            <param name="norm">Normalize by fft size</param>
            <returns>Complex analytic signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.AnalyticSignal(System.Single[],System.Boolean)">
            <summary>
            Compute complex analytic signal, single precision
            </summary>
            <param name="samples">Array of samples</param>
            <param name="norm">Normalize by fft size</param>
            <returns>Complex analytic signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="signal">Input signal</param>
            <returns>Hilbert Transform</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(System.Double[],System.Double[])">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="samples">Array of samples</param>
            <param name="output">Hilbert Transform array</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(System.Single[],System.Single[])">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="samples">Array of samples</param>
            <param name="output">Hilbert Transform array</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform.Direct(System.Single[],System.Single[],System.Single[],System.Boolean)">
            <summary>
            Direct Fast Mellin Transform
            </summary>
            <param name="input"></param>
            <param name="outputRe"></param>
            <param name="outputIm"></param>
            <param name="normalize"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.RealFft">
            <summary>
            FFT transformer for real inputs
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Size">
            <summary>
            Size of FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._fftSize">
            <summary>
            Half of FFT size (for calculations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._ar">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._br">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._ai">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._bi">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._re">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Direct(System.Single[],System.Single[],System.Single[])">
            <summary>
            Direct transform
            </summary>
            <param name="input"></param>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Inverse(System.Single[],System.Single[],System.Single[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.InverseNorm(System.Single[],System.Single[],System.Single[])">
            <summary>
            Inverse transform (with normalization by Fft size)
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.MagnitudeSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Magnitude spectrum:
            
                spectrum = sqrt(re * re + im * im)
            
            Since for realFFT: im[0] = im[fftSize/2] = 0
            we don't process separately these elements (like in case of FFT)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Magnitude spectrum</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.PowerSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Power spectrum (normalized by default):
            
                spectrum =   (re * re + im * im) / fftSize
            
            Since for realFFT: im[0] = im[fftSize/2] = 0
            we don't process separately these elements (like in case of FFT)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Power spectrum</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.MagnitudeSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.PowerSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Shift(System.Single[])">
            <summary>
            FFT shift (in-place)
            </summary>
            <param name="samples"></param>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Size">
            <summary>
            Size of FFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._fftSize">
            <summary>
            Half of FFT size (for calculations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._ar">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._br">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._ai">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._bi">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._re">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Direct(System.Double[],System.Double[],System.Double[])">
            <summary>
            Direct transform
            </summary>
            <param name="input"></param>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Inverse(System.Double[],System.Double[],System.Double[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.InverseNorm(System.Double[],System.Double[],System.Double[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Stft">
            <summary>
            Class providing methods for direct and inverse Short-Time Fourier Transforms.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Stft.Size">
            <summary>
            Size of FFT (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._fft">
            <summary>
            Internal FFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._hopSize">
            <summary>
            Overlap size (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._windowSize">
            <summary>
            Size of the window (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._window">
            <summary>
            Window type
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._windowSamples">
            <summary>
            Pre-computed samples of the window function
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._gain">
            <summary>
            ISTFT normalization gain
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.#ctor(System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Int32)">
            <summary>
            Constructor with necessary parameters
            </summary>
            <param name="windowSize">Size of window</param>
            <param name="hopSize">Hop (overlap) size</param>
            <param name="window">Type of the window function to apply</param>
            <param name="fftSize">Size of FFT</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Direct(System.Single[])">
            <summary>
            Method for computing direct STFT of a signal block.
            STFT (spectrogram) is essentially the list of spectra in time.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>STFT of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Inverse(System.Collections.Generic.List{System.Tuple{System.Single[],System.Single[]}})">
            <summary>
            Inverse STFT
            </summary>
            <param name="stft"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">The signal under analysis</param>
            <returns>STFT of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Spectrogram(System.Single[])">
            <summary>
            Method for computing a spectrogram.
            The spectrogram is essentially a list of power spectra in time.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>Spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Spectrogram(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">Signal</param>
            <returns>Spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.MagnitudePhaseSpectrogram(System.Single[])">
            <summary>
            Method for computing a spectrogram as arrays of Magnitude and Phase.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>Magnitude-Phase spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.MagnitudePhaseSpectrogram(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">Signal</param>
            <returns>Magnitude-Phase spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.ReconstructMagnitudePhase(AI.BackEnds.DSP.NWaves.Transforms.MagnitudePhaseList)">
            <summary>
            Reconstruct samples from magnitude-phase spectrogram
            </summary>
            <param name="spectrogram"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt">
            <summary>
            Fast Wavelet Transform
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Size">
            <summary>
            Size of the transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._waveletLength">
            <summary>
            The length of the mother wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._loD">
            <summary>
            LP coefficients for decomposition
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._hiD">
            <summary>
            HP coefficients for decomposition
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._loR">
            <summary>
            LP coefficients for reconstruction
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._hiR">
            <summary>
            HP coefficients for reconstruction
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._temp">
            <summary>
            Temporary internal buffer
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.#ctor(System.Int32,AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet)">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
            <param name="wavelet"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Direct(System.Single[],System.Single[],System.Int32)">
            <summary>
            Direct FWT (decomposition)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="level"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Inverse(System.Single[],System.Single[],System.Int32)">
            <summary>
            Inverse FWT (reconstruction)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="level"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.MaxLevel(System.Int32)">
            <summary>
            Maximum decomposition level
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet">
            <summary>
            Wavelet
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.Length">
            <summary>
            The length of the mother wavelet
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.LoD">
            <summary>
            LP coefficients for decomposition
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.HiD">
            <summary>
            HP coefficients for decomposition
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.LoR">
            <summary>
            LP coefficients for reconstruction
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.HiR">
            <summary>
            HP coefficients for reconstruction
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.#ctor(AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily,System.Int32)">
            <summary>
            Constructor from wavelet family and number of taps
            </summary>
            <param name="waveletFamily"></param>
            <param name="taps">Set for all wavelets</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.#ctor(System.String)">
            <summary>
            Constructor from name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeWavelet(AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily,System.Int32)">
            <summary>
            Fill wavelet fields: name, length and coefficients
            </summary>
            <param name="waveletFamily"></param>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.ComputeOrthonormalCoeffs">
            <summary>
            Compute orthonormal coefficients from LoD coefficients only
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeHaarWavelet">
            <summary>
            Haar wavelet
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeDaubechiesWavelet(System.Int32)">
            <summary>
            Daubechies wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeSymletWavelet(System.Int32)">
            <summary>
            Symlet wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeCoifletWavelet(System.Int32)">
            <summary>
            Coiflet wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily">
            <summary>
            Wavelet family type
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Haar">
            <summary>
            Haar wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Daubechies">
            <summary>
            Daubechies wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Coiflet">
            <summary>
            Coiflet wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Symlet">
            <summary>
            Symlet wavelet
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.Lpc">
            <summary>
            Functions related to Linear Predictive Coding
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.LevinsonDurbin(System.Single[],System.Single[],System.Int32,System.Int32)">
            <summary>
            Levinson-Durbin algorithm for solving main LPC task
            </summary>
            <param name="input">Auto-correlation vector</param>
            <param name="a">LP coefficients</param>
            <param name="order">Order of LPC</param>
            <returns>Prediction error</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.ToCepstrum(System.Single[],System.Single,System.Single[])">
            <summary>
            Convert LPC coefficients to cepstrum (LPCC)
            </summary>
            <param name="lpc"></param>
            <param name="gain"></param>
            <param name="lpcc"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.FromCepstrum(System.Single[],System.Single[])">
            <summary>
            Convert LPCC coefficients to LPC and gain
            
            Formulae: https://www.mathworks.com/help/dsp/ref/lpctofromcepstralcoefficients.html
            
            </summary>
            <param name="lpcc"></param>
            <param name="lpc"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.EstimateOrder(System.Int32)">
            <summary>
            Method returns LPC order for a given sampling rate 
            according to the best practices.
            </summary>
            <param name="samplingRate">Sampling rate</param>
            <returns>LPC order</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.ToLsf(System.Single[],System.Single[])">
            <summary>
            Convert LPC coefficients to Line Spectral Frequencies
            </summary>
            <param name="lpc"></param>
            <param name="lsf">The length must be equal to lpc length. Last element will be PI</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.FromLsf(System.Single[],System.Single[])">
            <summary>
            Convert Line Spectral Frequencies to LPC coefficients
            </summary>
            <param name="lsf">The length must be equal to lpc length. Last element must be PI</param>
            <param name="lpc"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.MathUtils">
            <summary>
            Static class providing some helpful math functions
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Sinc(System.Double)">
            <summary>
            Sinc-function
            </summary>
            <param name="x">Argument</param>
            <returns>sinc(x)</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.NextPowerOfTwo(System.Int32)">
            <summary>
            Method for computing next power of 2 (closest to the given number)
            </summary>
            <param name="n">Number</param>
            <returns>Next power of 2 closest to the number</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Gcd(System.Int32,System.Int32)">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Mod(System.Double,System.Double)">
            <summary>
            Modulo function that works correctly with negative numbers (as np.mod)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Asinh(System.Double)">
            <summary>
            Inverse sinh
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Factorial(System.Int32)">
            <summary>
            Factorial
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>
            Binomial coefficient
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Diff(System.Single[],System.Single[])">
            <summary>
            Diff signal (1st order derivative)
            </summary>
            <param name="samples"></param>
            <param name="diff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.InterpolateLinear(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Linear interpolation (as numpy.interp)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="arg"></param>
            <param name="interp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.BilinearTransform(System.Double[],System.Double[])">
            <summary>
            Bilinear transform (in-place)
            </summary>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Unwrap(System.Double[],System.Double)">
            <summary>
            Unwrap (phase)
            </summary>
            <param name="phase"></param>
            <param name="tolerance">Jump size</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.Wrap(System.Double[],System.Double)">
            <summary>
            Wrap (phase)
            </summary>
            <param name="phase"></param>
            <param name="tolerance">Jump size</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.FindNth(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Nth order statistics
            </summary>
            <param name="a"></param>
            <param name="n"></param>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.I0(System.Double)">
            <summary>
            Modified Bessel function of the 1st kind (Taylor series, not very precise method)
            </summary>
            <param name="x">x</param>
            <returns>I0(x)</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.PolynomialRoots(System.Double[],System.Int32)">
            <summary>
            Method implementing Durand-Kerner algorithm for finding complex roots of polynomials.
            Works for polynomials of order up to approx. 50. 
            </summary>
            <param name="a">Polynomial coefficients</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.ArraysAreEqual(System.Numerics.Complex[],System.Numerics.Complex[],System.Double)">
            <summary>
            Method checks if two arrays of complex numbers are essentially identical
            </summary>
            <param name="a">First array</param>
            <param name="b">Second array</param>
            <param name="tolerance">Tolerance level</param>
            <returns>true if arrays are equal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.EvaluatePolynomial(System.Double[],System.Numerics.Complex)">
            <summary>
            Evaluate polynomial according to Horner scheme
            </summary>
            <param name="a">Polynomial coefficients</param>
            <param name="x">x</param>
            <returns>The value of polynomial</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.MultiplyPolynomials(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Multiply polynomials
            </summary>
            <param name="poly1"></param>
            <param name="poly2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtils.DividePolynomial(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Divide polynomials
            </summary>
            <param name="dividend">Dividend</param>
            <param name="divisor">Divisor</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves">
            <summary>
            Class representing 2d matrix
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="rows"></param>
            <param name="columns"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.As2dArray">
            <summary>
            Get 2d array reference
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.T">
            <summary>
            Transposed matrix
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Companion(System.Double[])">
            <summary>
            Companion matrix
            </summary>
            <param name="a">Input array</param>
            <returns>Companion matrix</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Eye(System.Int32)">
            <summary>
            Identity matrix
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.ToFloats(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Convert array of doubles to array of floats
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.ToDoubles(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Convert array of floats to array of doubles
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopy(System.Single[])">
            <summary>
            Method simply copies source array to desination
            </summary>
            <param name="source">Source array</param>
            <returns>Source array copy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyTo(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies an array (or its fragment) to existing array (or its part)
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyFragment(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies some fragment of the source array starting at specified offset
            </summary>
            <param name="source"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
            <returns>The copy of source array part</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.MergeWithArray(System.Single[],System.Single[])">
            <summary>
            Method does fast in-memory merge of two arrays
            </summary>
            <param name="source1">The first array for merging</param>
            <param name="source2">The second array for merging</param>
            <returns>Merged array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.RepeatArray(System.Single[],System.Int32)">
            <summary>
            Method repeats given array N times
            </summary>
            <param name="source">Source array</param>
            <param name="times">Number of times to repeat array</param>
            <returns>Array repeated N times</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.PadZeros(System.Single[],System.Int32)">
            <summary>
            Method creates new zero-padded array from source array.
            </summary>
            <param name="source">Source array</param>
            <param name="size">The size of a zero-padded array</param>
            <returns>Zero-padded array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopy(System.Double[])">
            <summary>
            Method simply copies source array to desination
            </summary>
            <param name="source">Source array</param>
            <returns>Source array copy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyTo(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies an array (or its fragment) to existing array (or its part)
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyFragment(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies some fragment of the source array starting at specified offset
            </summary>
            <param name="source"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
            <returns>The copy of source array part</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.MergeWithArray(System.Double[],System.Double[])">
            <summary>
            Method does fast in-memory merge of two arrays
            </summary>
            <param name="source1">The first array for merging</param>
            <param name="source2">The second array for merging</param>
            <returns>Merged array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.RepeatArray(System.Double[],System.Int32)">
            <summary>
            Method repeats given array N times
            </summary>
            <param name="source">Source array</param>
            <param name="times">Number of times to repeat array</param>
            <returns>Array repeated N times</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.PadZeros(System.Double[],System.Int32)">
            <summary>
            Method creates new zero-padded array from source array.
            </summary>
            <param name="source">Source array</param>
            <param name="size">The size of a zero-padded array</param>
            <returns>Zero-padded array</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.Scale">
            <summary>
            Static class providing methods for 
            
            1) converting between different scales:
                - decibel
                - MIDI pitch
                - mel (HTK)
                - mel (Slaney)
                - bark1 (Traunmueller)
                - bark2 (Wang)
                - ERB
            
            2) loudness weighting:
                - A-weighting
                - B-weighting
                - C-weighting
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ToDecibel(System.Double,System.Double)">
            <summary>
            Method converts magnitude value to dB level
            </summary>
            <param name="value">Magnitude</param>
            <param name="valueReference">Reference magnitude</param>
            <returns>Decibel level</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ToDecibelPower(System.Double,System.Double)">
            <summary>
            Method converts power to dB level
            </summary>
            <param name="value">Power</param>
            <param name="valueReference">Reference power</param>
            <returns>Decibel level</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FromDecibel(System.Double,System.Double)">
            <summary>
            Method converts dB level to magnitude value
            </summary>
            <param name="level">dB level</param>
            <param name="valueReference">Reference magnitude</param>
            <returns>Magnitude value</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FromDecibelPower(System.Double,System.Double)">
            <summary>
            Method converts dB level to power
            </summary>
            <param name="level">dB level</param>
            <param name="valueReference">Reference power</param>
            <returns>Power</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.PitchToFreq(System.Int32)">
            <summary>
            Method converts MIDI pitch to frequency
            </summary>
            <param name="pitch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FreqToPitch(System.Double)">
            <summary>
            Method converts frequency to MIDI pitch
            </summary>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Utils.Scale.Notes">
            <summary>
            Array of notes
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.NoteToFreq(System.String,System.Int32)">
            <summary>
            Method converts note (in format ("G", 3), ("E", 5), etc.) to frequency in Hz
            </summary>
            <param name="note">Note (A-G#)</param>
            <param name="octave">Octave (0-8)</param>
            <returns>Frequency in Hz</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FreqToNote(System.Double)">
            <summary>
            Method converts frequency in Hz to note (in format ("G", 3), ("E", 5), etc.)
            </summary>
            <param name="freq">Frequency in Hz</param>
            <returns>Tuple (note, octave)</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToMel(System.Double)">
            <summary>
            Method converts herz frequency to corresponding mel frequency
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Mel frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.MelToHerz(System.Double)">
            <summary>
            Method converts mel frequency to corresponding herz frequency
            </summary>
            <param name="mel">Mel frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToMelSlaney(System.Double)">
            <summary>
            Method converts herz frequency to mel frequency (suggested by M.Slaney)
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Mel frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.MelToHerzSlaney(System.Double)">
            <summary>
            Method converts mel frequency to herz frequency (suggested by M.Slaney)
            </summary>
            <param name="mel">Mel frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToBark(System.Double)">
            <summary>
            Method #1 converts herz frequency to corresponding bark frequency
            (according to Traunmüller (1990))
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Bark frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.BarkToHerz(System.Double)">
            <summary>
            Method #1 converts bark frequency to corresponding herz frequency
            (according to Traunmüller (1990))
            </summary>
            <param name="bark">Bark frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToBarkSlaney(System.Double)">
            <summary>
            Method #2 converts herz frequency to corresponding bark frequency
            (according to Wang (1992)); used in M.Slaney's auditory toolbox
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Bark frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.BarkToHerzSlaney(System.Double)">
            <summary>
            Method #2 converts bark frequency to corresponding herz frequency
            (according to Wang (1992)); used in M.Slaney's auditory toolbox
            </summary>
            <param name="bark">Bark frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToErb(System.Double)">
            <summary>
            Method converts herz frequency to corresponding ERB frequency
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>ERB frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ErbToHerz(System.Double)">
            <summary>
            Method converts ERB frequency to corresponding herz frequency
            </summary>
            <param name="erb">ERB frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.LoudnessWeighting(System.Double,System.String)">
            <summary>
            Method for obtaining a perceptual loudness weight
            </summary>
            <param name="freq">Frequency</param>
            <param name="weightingType">Weighting type (A, B, C)</param>
            <returns>Weight value in dB</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.Window">
            <summary>
            Factory class generating various types of window functions
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.OfType(AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Int32,System.Object[])">
            <summary>
            Main factory method
            </summary>
            <param name="type">Window type</param>
            <param name="length">Window length</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Rectangular(System.Int32)">
            <summary>
            Rectangular window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Rectangular window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Triangular(System.Int32)">
            <summary>
            Triangular window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Triangular window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Hamming(System.Int32)">
            <summary>
            Hamming window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Hamming window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Blackman(System.Int32)">
            <summary>
            Blackman window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Blackman window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Hann(System.Int32)">
            <summary>
            Hann window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Hann window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Gaussian(System.Int32)">
            <summary>
            Gaussian window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Gaussian window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Kaiser(System.Int32,System.Double)">
            <summary>
            Kaiser window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Kaiser window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Kbd(System.Int32,System.Double)">
            <summary>
            Kaiser-Bessel Derived window
            </summary>
            <param name="length">Length of the window</param>
            <returns>KBD window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.BartlettHann(System.Int32)">
            <summary>
            Bartlett-Hann window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Lanczos(System.Int32)">
            <summary>
            Lanczos window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.PowerOfSine(System.Int32,System.Double)">
            <summary>
            Sin-beta window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Flattop(System.Int32)">
            <summary>
            Flat-top window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Liftering(System.Int32,System.Int32)">
            <summary>
            Cepstrum liftering.
            </summary>
            <param name="length">Length of the window</param>
            <param name="l">Denominator in liftering formula</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions">
            <summary>
            A few helper functions for applying windows to signals and arrays of samples
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Single[],System.Single[])">
            <summary>
            Mutable function that applies window array to array of float samples
            </summary>
            <param name="samples"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Double[],System.Double[])">
            <summary>
            Mutable function that applies window array to array of double samples
            </summary>
            <param name="samples"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single[])">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Single[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
            <param name="samples"></param>
            <param name="window"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Double[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
            <param name="samples"></param>
            <param name="window"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="window"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.WindowTypes">
            <summary>
            Most commonly used window functions
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Rectangular">
            <summary>
            Reactangular window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Triangular">
            <summary>
            Triangular window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Hamming">
            <summary>
            Hamming window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Blackman">
            <summary>
            Blackman window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Hann">
            <summary>
            Hann window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Gaussian">
            <summary>
            Gaussian window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Kaiser">
            <summary>
            Kaiser window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Kbd">
            <summary>
            Kaiser-Bessel Derived window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.BartlettHann">
            <summary>
            Bartlett-Hann window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Lanczos">
            <summary>
            Lanczos window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.PowerOfSine">
            <summary>
            Power-of-sine window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Flattop">
            <summary>
            Flat-top window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Liftering">
            <summary>
            Window for cepstral liftering
            </summary>
        </member>
        <member name="T:AI.Charts.ChartData">
            <summary>
            Данные графика
            </summary>
        </member>
        <member name="P:AI.Charts.ChartData.ChartName">
            <summary>
            Имя графика
            </summary>
        </member>
        <member name="M:AI.Charts.ChartData.SempleADD(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.Charts.Description,System.Drawing.Color,AI.Charts.ChartType)">
            <summary>
            Добавление графика
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="description"></param>
            <param name="color"></param>
            <param name="chartType"></param>
        </member>
        <member name="T:AI.Charts.ChartDataSample">
            <summary>
            Описание одной части графика
            </summary>
        </member>
        <member name="P:AI.Charts.ChartDataSample.DescriptionData">
            <summary>
            Описание (метаданные)
            </summary>
        </member>
        <member name="F:AI.Charts.ChartDataSample.DataX">
            <summary>
            Данные по оси X
            </summary>
        </member>
        <member name="F:AI.Charts.ChartDataSample.DataY">
            <summary>
            Данные по Y
            </summary>
        </member>
        <member name="P:AI.Charts.ChartDataSample.ColorChart">
            <summary>
            Цвет графика
            </summary>
        </member>
        <member name="P:AI.Charts.ChartDataSample.ChartType">
            <summary>
            Тип графика
            </summary>
        </member>
        <member name="M:AI.Charts.ChartDataSample.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.Charts.Description,System.Drawing.Color,AI.Charts.ChartType)">
            <summary>
            Данные графика
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="description"></param>
            <param name="color"></param>
            <param name="chartType"></param>
        </member>
        <member name="T:AI.Charts.ChartType">
            <summary>
            Доступные типы графиков
            </summary>
        </member>
        <member name="F:AI.Charts.ChartType.Plot">
            <summary>
            График в виде линии 
            </summary>
        </member>
        <member name="F:AI.Charts.ChartType.Bar">
            <summary>
            График в виде столбцов(гистограмма)
            </summary>
        </member>
        <member name="F:AI.Charts.ChartType.Scatter">
            <summary>
            Скаттерограмма, график в виде точек
            </summary>
        </member>
        <member name="F:AI.Charts.ChartType.Spline">
            <summary>
            Сплайновая кривая 
            </summary>
        </member>
        <member name="T:AI.Charts.Control.ChartSample">
            <summary>
            Данные графика
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartSample.Data">
            <summary>
            Ось X
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartSample.Steps">
            <summary>
            Ось Y
            </summary>
        </member>
        <member name="F:AI.Charts.Control.ChartSample.tableOfContentsOfX">
            <summary>
            Ускоренный поиск регионов
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSample.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Данные графика
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSample.GetMaxData">
            <summary>
            Максимум по оси Y
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSample.GetMaxSteps">
            <summary>
            Максимум по оси X
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSample.GetMinData">
            <summary>
            Минимум по оси Y
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSample.GetMinSteps">
            <summary>
            Минимум по оси X
            </summary>
        </member>
        <member name="T:AI.Charts.Control.ChartSempls">
            <summary>
            Коллекция
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.#ctor">
            <summary>
            Коллеция данных графика
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.Add(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавление данных
            </summary>
            <param name="x">Вектор x</param>
            <param name="y">Вектор y</param>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.GetMaxData">
            <summary>
            Максимум по оси Y
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.GetMaxSteps">
            <summary>
            Максимум по оси X
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.GetMinData">
            <summary>
            Минимум по оси Y
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartSempls.GetMinSteps">
            <summary>
            Минимум по оси X
            </summary>
        </member>
        <member name="T:AI.Charts.Control.ChartVisual">
            <summary>
            Визуально представление данных (Графики)
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.IsMoove">
            <summary>
            Можно ли перемещать график
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.IsScale">
            <summary>
            Можно ли масштабировать
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.IsShowXY">
            <summary>
            Выводить ли значения x,y
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.IsContextMenu">
            <summary>
            Использовать ли контекстное меню
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.ChartName">
            <summary>
            Имя графика
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.LabelX">
            <summary>
            Имя оси X
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.LabelY">
            <summary>
            Имя оси Y
            </summary>
        </member>
        <member name="P:AI.Charts.Control.ChartVisual.IsLogScale">
            <summary>
            График в логарифмическом масштабе
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.#ctor">
            <summary>
            Графики
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.VisualData(AI.Charts.ChartData)">
            <summary>
            Визуализация графиков
            </summary>
            <param name="chartDatas">Данные графиков</param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Nullable{System.Drawing.Color},System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddPlotBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.PlotBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.PlotComplex(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddPlotBlack(AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.PlotBlack(AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.PlotComplex(AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddRadialPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddRadialDegPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.RadPlotBlueDeg(AI.DataStructs.Algebraic.Vector,System.String,System.Int32)">
            <summary>
            Радиальный график
            </summary>
            <param name="y"></param>
            <param name="name"></param>
            <param name="width"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddBar(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddBarBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddBarBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.BarBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.BarBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddScatter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddScatterMark3(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddScatterMark6(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddScatterBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AddScatterBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ScatterBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ScatterBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ScatterComplex(AI.DataStructs.WithComplexElements.ComplexVector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ScatterComplexPlane(AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.String,System.String)">
            <summary>
            Создание скаттерограммы отражающей комплексную плоскость
            </summary>
            <param name="y">Комплексный вектор</param>
            <param name="name">Имя</param>
            <param name="xScale">Единица измерения шкалы x</param>
            <param name="yScale">Единица измерения шкалы y</param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ScatterComplexPlaneWithRing1(AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.String,System.String)">
            <summary>
            Создание скаттерограммы отражающей комплексную плоскость
            </summary>
            <param name="y">Комплексный вектор</param>
            <param name="name">Имя</param>
            <param name="xScale">Единица измерения шкалы x</param>
            <param name="yScale">Единица измерения шкалы y</param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.ChartImg">
            <summary>
             Отрисовка графика
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.Clear">
            <summary>
            Очистка графика
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.AutoScale">
            <summary>
            Масштабирование по умолчанию
            </summary>
        </member>
        <member name="F:AI.Charts.Control.ChartVisual.components">
            <summary>
            Designer variable used to keep track of non-visual components.
            </summary>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.Dispose(System.Boolean)">
            <summary>
            Disposes resources used by the control.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:AI.Charts.Control.ChartVisual.InitializeComponent">
            <summary>
            This method is required for Windows Forms designer support.
            Do not change the method contents inside the source code editor. The Forms designer might
            not be able to load this method if it was changed manually.
            </summary>
        </member>
        <member name="T:AI.Charts.Control.HeatMapControl">
            <summary>
            Тепловая карта
            </summary>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.#ctor">
            <summary>
            Тепловая карта
            </summary>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.NewGrad">
            <summary>
            Задает градиент тепловой карты
            </summary>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.GetColor(System.Double)">
            <summary>
            Получение цвета из значения 
            </summary>
            <param name="value">значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.HeatMap_SizeChanged(System.Object,System.EventArgs)">
            <summary>
            Удержание позиций меток
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.ResizeImage(System.Drawing.Image,System.Int32,System.Int32)">
            <summary>
            Преобразование изображения
            Источник: https://stackoverflow.com/questions/1922040/how-to-resize-an-image-c-sharp/24199315
            </summary>
            <param name="image"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.CalculateHeatMap(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Расчет тепловой карты для матрицы
            </summary>
            <param name="matrix">Матрица</param>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.CalculateHeatMap(System.Double[0:,0:])">
            <summary>
            Расчет тепловой карты для двумерного массива
            </summary>
            <param name="data">Массив</param>
        </member>
        <member name="F:AI.Charts.Control.HeatMapControl.components">
            <summary> 
            Обязательная переменная конструктора.
            </summary>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.Dispose(System.Boolean)">
            <summary> 
            Освободить все используемые ресурсы.
            </summary>
            <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        </member>
        <member name="M:AI.Charts.Control.HeatMapControl.InitializeComponent">
            <summary> 
            Требуемый метод для поддержки конструктора — не изменяйте 
            содержимое этого метода с помощью редактора кода.
            </summary>
        </member>
        <member name="T:AI.Charts.Data.DataMethods">
            <summary>
            Description of DataMethods.
            </summary>
        </member>
        <member name="M:AI.Charts.Data.DataMethods.ReducDataPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прореживание данных, чтобы на графике не было большого числа точек
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Charts.Data.DataMethods.ReducDataRadialPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прореживание данных, чтобы на графике не было большого числа точек
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Charts.Data.DataMethods.ReducData40000(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прореживание данных, чтобы на графике не было большого числа точек
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Charts.Data.DataMethods.ImageFromChart(System.Windows.Forms.DataVisualization.Charting.Chart)">
            <summary>
            Получение изображения графика 
            </summary>
            <param name="chart">График</param>
        </member>
        <member name="M:AI.Charts.Data.DataMethods.GetColorForStyle(System.String)">
            <summary>
            Получение среднего цвета из картинки
            </summary>
            <param name="path">Путь до картинки</param>
        </member>
        <member name="T:AI.Charts.Description">
            <summary>
            Описание для графика
            </summary>
        </member>
        <member name="F:AI.Charts.Description.X">
            <summary>
            Название оси X
            </summary>
        </member>
        <member name="F:AI.Charts.Description.Y">
            <summary>
            Название оси Y
            </summary>
        </member>
        <member name="F:AI.Charts.Description.Name">
            <summary>
            Название графика
            </summary>
        </member>
        <member name="P:AI.Charts.Description.Descript">
            <summary>
            Описание графика
            </summary>
        </member>
        <member name="M:AI.Charts.Description.#ctor(System.String,System.String,System.String)">
            <summary>
            Описание графика
            </summary>
            <param name="xL">Название оси X</param>
            <param name="yL">Название оси Y</param>
            <param name="name">Название графика</param>
        </member>
        <member name="T:AI.Charts.Forms.FormChart">
            <summary>
            Форма для отображения графиков
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.#ctor">
            <summary>
            Форма для отображения графиков
            </summary>
        </member>
        <member name="P:AI.Charts.Forms.FormChart.ChartName">
            <summary>
            Имя графика
            </summary>
        </member>
        <member name="P:AI.Charts.Forms.FormChart.LabelX">
            <summary>
            Имя оси X
            </summary>
        </member>
        <member name="P:AI.Charts.Forms.FormChart.LabelY">
            <summary>
            Имя оси Y
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.VisualData(AI.Charts.ChartData)">
            <summary>
            Визуализация графиков
            </summary>
            <param name="chartDatas">Данные графиков</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddPlot(AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddPlotBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.PlotBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.PlotComplex(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddPlotBlack(AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.PlotBlack(AI.DataStructs.Algebraic.Vector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.PlotComplex(AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.Int32,System.Boolean)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddRadialPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddRadialDegPlot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color,System.Int32)">
            <summary>
            Создание графика с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.RadPlotBlueDeg(AI.DataStructs.Algebraic.Vector,System.String,System.Int32)">
            <summary>
            Радиальный график
            </summary>
            <param name="y"></param>
            <param name="name"></param>
            <param name="width"></param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddBar(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddBarBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddBarBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.BarBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.BarBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание гистограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddScatter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String,System.Drawing.Color)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddScatterBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddScatterBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.ScatterBlack(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.ScatterBlack(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.ScatterComplex(AI.DataStructs.WithComplexElements.ComplexVector,System.String)">
            <summary>
            Создание скаттерограммы с данными
            </summary>
            <param name="y"></param>
            <param name="name"></param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.ScatterComplexPlane(AI.DataStructs.WithComplexElements.ComplexVector,System.String,System.String,System.String)">
            <summary>
            Создание скаттерограммы отражающей комплексную плоскость
            </summary>
            <param name="y">Комплексный вектор</param>
            <param name="name">Имя</param>
            <param name="xScale">Единица измерения шкалы x</param>
            <param name="yScale">Единица измерения шкалы y</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.Clear">
            <summary>
            Очищение графика
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddSpectrum(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Drawing.Color,System.String)">
            <summary>
            Adding an amplitude spectrum (Hamming window)
            </summary>
            <param name="x">Time vector</param>
            <param name="y">Amplitudes vector</param>
            <param name="color">Color</param>
            <param name="name">Chart name</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddSpectrum(AI.Charts.ChartElements.IChartElement)">
            <summary>
            Adding an amplitude spectrum (Hamming window)
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddDiff(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Drawing.Color,System.String,System.Int32)">
            <summary>
            Производная
            </summary>
            <param name="x">Вектор времени</param>
            <param name="y">Вектор амплитуд</param>
            <param name="color">Цвет</param>
            <param name="name">Имя графика</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddIntegr(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Drawing.Color,System.String,System.Int32)">
            <summary>
            Интеграл
            </summary>
            <param name="x">Вектор времени</param>
            <param name="y">Вектор амплитуд</param>
            <param name="color">Цвет</param>
            <param name="name">Имя графика</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.AddHistoramm(AI.DataStructs.Algebraic.Vector,System.Drawing.Color,System.String)">
            <summary>
            Гистограммы
            </summary>
            <param name="y">Вектор значений</param>
            <param name="color">Цвет</param>
            <param name="name">Имя</param>
        </member>
        <member name="F:AI.Charts.Forms.FormChart.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:AI.Charts.Forms.FormChart.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:AI.Combinatorics.CombinatoricsBaseFunction">
            <summary>
            Базовые функции коммбинарики
            </summary>
        </member>
        <member name="M:AI.Combinatorics.CombinatoricsBaseFunction.PlacingWithoutRepetition(System.Int32,System.Int32)">
            <summary>
            Размещение без повторов
            </summary>
            <param name="k">Количество элементов</param>
            <param name="n">Количество возможных позиций</param>
        </member>
        <member name="M:AI.Combinatorics.CombinatoricsBaseFunction.NumberOfCombinations(System.Int32,System.Int32)">
            <summary>
            Количество комбинаций
            </summary>
            <param name="k">Количество элементов</param>
            <param name="n">Количество возможных позиций</param>
        </member>
        <member name="T:AI.ComputerVision.BinaryImg">
            <summary>
            Description of BinaryImg.
            </summary>
        </member>
        <member name="P:AI.ComputerVision.BinaryImg.M">
            <summary>
            Ширина
            </summary>
        </member>
        <member name="P:AI.ComputerVision.BinaryImg.Count">
            <summary>
            Высота
            </summary>
        </member>
        <member name="P:AI.ComputerVision.BinaryImg.Item(System.Int32,System.Int32)">
            <summary>
            Вывод индекса
            </summary>
        </member>
        <member name="M:AI.ComputerVision.BinaryImg.#ctor(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Бинарное изображение
            </summary>
            <param name="matr">Матрица серого</param>
        </member>
        <member name="M:AI.ComputerVision.BinaryImg.#ctor(System.Drawing.Bitmap)">
            <summary>
            Бинарное изображение
            </summary>
            <param name="bm">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.BinaryImg.ToMatrixInvers">
            <summary>
            Бинарное в матрицу
            </summary>
        </member>
        <member name="M:AI.ComputerVision.BinaryImg.ToBmp">
            <summary>
            Бинарное в Bitmap
            </summary>
        </member>
        <member name="T:AI.ComputerVision.CalculateBinaryEl">
            <summary>
            Подсчет объектов
            </summary>
        </member>
        <member name="F:AI.ComputerVision.CalculateBinaryEl.img">
            <summary>
            Изображение
            </summary>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.#ctor">
            <summary>
            Подсчет объектов
            </summary>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.CalculateBinElements(System.Drawing.Bitmap)">
            <summary>
            Подсчет объектов
            </summary>
            <param name="bmp">Изображение</param>
            <returns>Кол-во объектов</returns>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.FilterI(System.Int32,System.Int32)">
            <summary>
            Проход одного шага по фильтрам внутренних углов, с подсчетом углов
            </summary>
            <param name="dx">Смещение по x</param>
            <param name="dy">Смещение по y</param>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.FilterE(System.Int32,System.Int32)">
            <summary>
            Проход одного шага по фильтрам внешних углов, с подсчетом углов
            </summary>
            <param name="dx">Смещение по x</param>
            <param name="dy">Смещение по y</param>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.Filter(System.Int32,System.Int32)">
            <summary>
            Проход одного шага по внешним и внутренним углам
            </summary>
            <param name="dx">Смещение х</param>
            <param name="dy">Смещение у</param>
        </member>
        <member name="M:AI.ComputerVision.CalculateBinaryEl.Mascs">
            <summary>
            Создание масок для фильтров внеш. и внутр. углов
            </summary>
        </member>
        <member name="T:AI.ComputerVision.CompImg">
            <summary>
            Сравнение изображений
            </summary>
        </member>
        <member name="M:AI.ComputerVision.CompImg.GetVectorFromImg(System.Drawing.Bitmap)">
            <summary>
            Получение вектора из изображения
            </summary>
        </member>
        <member name="M:AI.ComputerVision.CompImg.GetVectorFromImg(System.Drawing.Bitmap,System.String)">
            <summary>
            Получение вектора из изображения
            </summary>
            <param name="bitmap"></param>
            <param name="pathNorm"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.CompImg.GetVectorFromImgI(System.Drawing.Bitmap,System.String)">
            <summary>
            Получение вектора из изображения
            </summary>
            <param name="bitmap"></param>
            <param name="pathNorm"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.CompImg.GetVectorFromPath(System.String)">
            <summary>
            Получение вектора из изображения
            </summary>
            <param name="path">Путь до изображения</param>
        </member>
        <member name="M:AI.ComputerVision.CompImg.SaveMeanStdVect(System.String,System.String)">
            <summary>
            Сохраняет ско и средний вектор
            </summary>
            <param name="path2fold">Путь до папки с картинками</param>
            <param name="pathSave">Путь до сохранения</param>
        </member>
        <member name="T:AI.ComputerVision.FeaturesInBinaryImg">
            <summary>
            Description of FeaturesInBinaryImg.
            </summary>
        </member>
        <member name="M:AI.ComputerVision.FeaturesInBinaryImg.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Фичи из матрицы изобр
            </summary>
            <param name="isRot">Сохранить оригенальный поворот</param>
            <param name="isScale">Сохранить оригенальный масштаб</param>
            <param name="isMove">Сохранить оригенальное смещение</param>
            <param name="nGarm">Количество гармоник, кол-во точек в 2 раза больше</param>
        </member>
        <member name="M:AI.ComputerVision.FeaturesInBinaryImg.MatrixFeatures(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Генерация вектора частотных признаков из матрицы изображения
            </summary>
            <param name="img">Матрица изображения</param>
            <returns>Коэф. ряда фурье после преобразований</returns>
        </member>
        <member name="M:AI.ComputerVision.FeaturesInBinaryImg.KepstrFeatures(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Кепстральные коэффициенты
            </summary>
            <param name="img">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.FeaturesInBinaryImg.GetPoints(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Выдает точки
            </summary>
            <param name="img">Матрица серого изображения</param>
        </member>
        <member name="T:AI.ComputerVision.ImgFilters">
            <summary>
            Filters for images
            </summary>
        </member>
        <member name="M:AI.ComputerVision.ImgFilters.SpatialFilter(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Spatial grayscale filter
            </summary>
            <param name="img">Image matrix</param>
            <param name="filter">Filter matrix</param>
        </member>
        <member name="M:AI.ComputerVision.ImgFilters.MedianFilter(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Median grayscale filter
            </summary>
            <param name="img">Image matrix</param>
            <param name="filter">Filter matrix</param>
        </member>
        <member name="M:AI.ComputerVision.ImgFilters.StdFilter(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            std grayscale filter
            </summary>
            <param name="img">Image matrix</param>
            <param name="filter">Filter matrix</param>
        </member>
        <member name="T:AI.ComputerVision.ImageMatrixConverter">
            <summary>
            Конвертирование изображений
            в разные математические типы
            и обратно
            </summary>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.GetBitmap(System.String)">
            <summary>
            Загрузка картинки
            </summary>
            <param name="path">Имя</param>
            <returns>изображение</returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.ImgToByteArray(System.Drawing.Bitmap)">
            <summary>
            Получение массива байт, для сохранения или передачи по сети
            </summary>
            <param name="bitmap">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToTensor(System.Drawing.Bitmap)">
            <summary>
            Преобразование изображения в тензор 3-го ранга(нормировка на 1)
            </summary>
            <param name="Bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToMatr(System.Drawing.Bitmap)">
            <summary>
            Изображение в полутоновую матрицу
            </summary>
            <param name="Bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToMatrBlue(System.Drawing.Bitmap)">
            <summary>
            Изображение в матрицу синего канала
            </summary>
            <param name="Bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToMatrGreen(System.Drawing.Bitmap)">
            <summary>
            Изображение в матрицу зеленого канала
            </summary>
            <param name="Bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToMatrRed(System.Drawing.Bitmap)">
            <summary>
            Изображение в матрицу красного канала
            </summary>
            <param name="Bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpToHMatr(System.Drawing.Bitmap)">
            <summary>
            Преобразование картинки в матрицу H компонент
            H принадлежит интервалу [0,1]
            </summary>
            <param name="Bmp">Картинка</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.RotateBitmap(System.Drawing.Bitmap,System.Single)">
            <summary>
            Поворот изображения на заданный угол
            </summary>
            <param name="bmp">Исходное изображение</param>
            <param name="angleRotate">Угол поворота</param>
            <returns>Изображение повернутое на заданный угол</returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.VerticalReflectionBitmap(System.Drawing.Bitmap)">
            <summary>
            Вертикальное зеркальное отображение
            </summary>
            <param name="bmp">Изображение</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.HorizontalReflectionBitmap(System.Drawing.Bitmap)">
            <summary>
            Горизонтальное зеркальное отображение
            </summary>
            <param name="bmp">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpResizeW(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Пропорционально изменение размеров с помощью явного указания ширины
            </summary>
            <param name="bitmap">Исходное изображение</param>
            <param name="newW">Новая ширина</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpResizeH(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Пропорционально изменение размеров с помощью явного указания высоты
            </summary>
            <param name="bitmap">Исходное изображение</param>
            <param name="newH">Новая высота</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.BmpResizeM(System.Drawing.Bitmap,System.Int32)">
            <summary>
            Пропорционально изменение размеров с помощью явного указания размера максимальной стороны
            </summary>
            <param name="bitmap">Исходное изображение</param>
            <param name="newM">Размер максимальной стороны</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.HComponent(System.Drawing.Color)">
            <summary>
            Вычисление H компоненты
            </summary>
            <param name="rgb"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.Visualization(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Визуализация матрицы
            </summary>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.ToBitmap(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Перевод матрицы в полутоновое изображение
            </summary>
        </member>
        <member name="M:AI.ComputerVision.ImageMatrixConverter.ToBitmap(AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Тензор в картинку
            </summary>
            <param name="tensor">Тензор</param>
            <returns>Bitmap</returns>
        </member>
        <member name="T:AI.ComputerVision.SpatialFilters.ISpatialFilterGray">
            <summary>
            Grayscale spatial filter interface
            </summary>
        </member>
        <member name="T:AI.ComputerVision.UInt8.ConvolutionUInt16">
            <summary>
            Свертка изображений UInt8
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ConvolutionUInt16.Conv16Gray(AI.ComputerVision.UInt8.ImgUInt16Gray,AI.ComputerVision.UInt8.ImgUInt16Gray)">
            <summary>
            Свертка чб изобржений
            </summary>
            <param name="img"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ComputerVision.UInt8.ImgUInt16Gray">
            <summary>
            Изображение серое UInt16
            </summary>
        </member>
        <member name="F:AI.ComputerVision.UInt8.ImgUInt16Gray.img">
            <summary>
            Изображение
            </summary>
        </member>
        <member name="F:AI.ComputerVision.UInt8.ImgUInt16Gray.Width">
            <summary>
            Ширина
            </summary>
        </member>
        <member name="F:AI.ComputerVision.UInt8.ImgUInt16Gray.Height">
            <summary>
            Высота
            </summary>
        </member>
        <member name="P:AI.ComputerVision.UInt8.ImgUInt16Gray.Item(System.Int32,System.Int32)">
            <summary>
            Доступ к пикселам
            </summary>
            <param name="i">Index высоты</param>
            <param name="j">Index ширины</param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.#ctor(System.Int32,System.Int32)">
            <summary>
            Создание черного изображения указанных размеров
            </summary>
            <param name="h"></param>
            <param name="w"></param>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.#ctor(System.Drawing.Bitmap)">
            <summary>
            Загрузка картинки(с переводом в чб)
            </summary>
            <param name="bitmap">Изображение</param>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Addition(AI.ComputerVision.UInt8.ImgUInt16Gray,System.Int32)">
            <summary>
            Сумма
            </summary>
            <param name="img"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Subtraction(AI.ComputerVision.UInt8.ImgUInt16Gray,System.Int32)">
            <summary>
            Разность
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Addition(System.Int32,AI.ComputerVision.UInt8.ImgUInt16Gray)">
            <summary>
            Сумма
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Subtraction(System.Int32,AI.ComputerVision.UInt8.ImgUInt16Gray)">
            <summary>
            Разность
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Multiply(AI.ComputerVision.UInt8.ImgUInt16Gray,System.Double)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Division(AI.ComputerVision.UInt8.ImgUInt16Gray,System.Double)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Division(AI.ComputerVision.UInt8.ImgUInt16Gray,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Multiply(System.Double,AI.ComputerVision.UInt8.ImgUInt16Gray)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.op_Division(System.Double,AI.ComputerVision.UInt8.ImgUInt16Gray)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ComputerVision.UInt8.ImgUInt16Gray.ToBitmap">
            <summary>
            Перевод изображения в Bitmap
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.Correlation">
            <summary>
            Класс реализует авто- и взаимо- кореляционные функции
            Для действительных и комплексных векторов
            </summary>
        </member>
        <member name="M:AI.Correlation.CrossCorrelation(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Cross-correlation of two real vectors
            </summary>
            <param name="A">First vector</param>
            <param name="B">Second vector</param>
        </member>
        <member name="M:AI.Correlation.CrossCorrelation(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Cross-correlation of two complex vectors
            </summary>
            <param name="A">First vector</param>
            <param name="B">Second vector</param>
        </member>
        <member name="M:AI.Correlation.AutoCorrelation(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Автокорелляция действительного векторов
            </summary>
            <param name="A">Вектор</param>
            <returns>Возвращает осчеты АКФ</returns>
        </member>
        <member name="M:AI.Correlation.AutoCorrelation(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Автокорелляция комплексного векторов
            </summary>
            <param name="A">Вектор</param>
            <returns>Возвращает осчеты АКФ</returns>	
        </member>
        <member name="T:AI.DataStructs.Algebraic.IAlgebraicStructure">
            <summary>
            Algebraic structure interface
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.IAlgebraicStructure.Data">
            <summary>
            Structure data as 1D array
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.IAlgebraicStructure.Shape">
            <summary>
            Structure shape
            </summary>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Matrix">
            <summary>
            Class of matrix and operations on it
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Data">
            <summary>
            Matrix elements
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.DataType">
            <summary>
            Matrix type
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Height">
            <summary>
            Matrix height
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Width">
            <summary>
            matrix width
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Shape">
            <summary>
            Matrix shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Item(System.Int32,System.Int32)">
            <summary>
            Get element by indexes
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Item(System.Int32)">
            <summary>
            Get element by indexes
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Determinant">
            <summary>
            Matrix determinant
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsZero">
            <summary>
            Tells if matrix is filled with zeros
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsSquared">
            <summary>
            Tells if matrix is squared
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsDiagonal">
            <summary>
            Tells if matrix is diagonal
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsTriangle">
            <summary>
            Tells if matrix is triangle
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor">
            <summary>
            Создает матрицу со всеми нулями размерности 3х3
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Создает матрицу на основе двумерного массива
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(AI.DataStructs.Shapes.Shape)">
            <summary>
            Creating a matrix of 0s with the given shape
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Создает матрицу со всеми нулями размерности MxN
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Addition of matrices 
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Difference of matrices
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Addition 
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Addition
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            вычитание
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            вычитание
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора на матрицу
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Умножение вектора на матрицу
            </summary>
            <param name="B"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Matrix multiplication
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToMean">
            <summary>
            Replacing uncertainty with mean
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToValue(System.Double)">
            <summary>
            Replacing uncertainty with a number
            </summary>
            <param name="value">Число</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>
            Получение минора
            </summary>
            <param name="h">Без какой строки</param>
            <param name="w">Без какого столбца</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetInvertMatrix">
            <summary>
            Вычисление обратной матрицы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Min">
            <summary>
            Минимальное значение матрицы
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Max">
            <summary>
            Maximum value(Matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mean">
            <summary>
            Среднее арифметическое матрицы 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Sum">
            <summary>
            Сумма 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Dispersion">
            <summary>
            Дисперсия
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Std">
            <summary>
            Среднеквадратичное отклонение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.AdamarProduct(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Адамарово произведение(поэлементное)
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MaxPool(System.Int32,System.Int32,System.Int32[0:,0:]@)">
            <summary>
            Макс пулинг
            </summary>
            <param name="poolH">step по высоте</param>
            <param name="poolW">step по ширине</param>
            <param name="indexPool">Максимальные индексы в исходной матрице</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MulMatrOnVectColumn(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение матрицы на вектор столбец
            </summary>
            <param name="vectCol">Вектор столбец</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.LikeVector">
            <summary>
             Представление матрицы как вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GradientMatrixConvDelts(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Градиент свертки
            </summary>
            <param name="core"></param>
            <param name="delts"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Region(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Выделение региона
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Transpose">
            <summary>
            Транспонирование матрицы
            </summary>
            <returns>Возвращает транспонированную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Трансформирование матрицы
            </summary>
            <param name="transformFunc">Функция трансформации</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Copy">
            <summary>
            Копирование матрицы
            </summary>
            <returns>Возвращает копию</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Round(System.Int32)">
            <summary>
            Rounding значений
            </summary>
            <param name="n">До какого знака</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.ToTriangularMatr">
            <summary>
            Переводит произвольную матрицу в треугольную
            </summary>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetVector(System.Int32,System.Int32)">
            <summary>
            Возвращает вектор с нужного среза, нужный индекс
            </summary>
            <param name="index">Index</param>
            <param name="dimension">Срез/размерность</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Swap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Перегруппировка матрицы (Замена индексов)
            </summary>
            <param name="i">На какой индекс заменить</param>
            <param name="j">Какой индекс заменить</param>
            <param name="dimension">Размерность среза 0 или 1</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToMeanOfFeatures(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Replacing uncertainty with mean
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mul2VecFast(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора-столбца на вектор строку, возвращается матрица результата
            </summary>
            <param name="ABinaryBip">Бинарный вектор</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mul2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора-столбца на вектор строку, возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Sum2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сложение вектора-столбца на вектор строку по следующему правилу "matr[i, j] = B[j] + A[i];" возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Norm2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление нормы по след. правилу  matr[i, j] = Math.Sqrt(B[j]*B[j]+ A[i]*A[i]);, возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Pow(AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Возведение матрицы в степень 
            путем матричного умножения на саму себя
            </summary>
            <param name="A">Входная матрица</param>
            <param name="exponent">Степень</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetColumns(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Разложение матрицы на столбцы
            </summary>
            <param name="matr">Матрица</param>
            <returns>Массив векторов</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.AlternativMatrix(System.Func{System.Double,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Альтернативная матрица
            </summary>
            <param name="functions">Функции</param>
            <param name="values">Значения</param>
            <returns>Возвращает альтернативную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.OrtogonalMatrix(System.Func{System.Int32,System.Double,System.Double},AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Ортогональная матрица
            </summary>
            <param name="functions">Порождающая функция</param>
            <param name="values">Значения</param>
            <param name="count">Число выходов</param>
            <returns>Возвращает ортогональную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCorrelationMatrixNorm(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Метод создает матрицу с коэффициентами попарной корреляции векторов
            </summary>
            <param name="vectors">Вектора</param>
            <returns>Корреляционная матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCovMatrix(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Метод создает матрицу с коэффициентами попарной ковариции векторов
            </summary>
            <param name="vectors">Вектора</param>
            <returns>Ковариационнай матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCovMatrixFromColumns(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Метод создает матрицу с коэффициентами попарной ковариции векторов
            </summary>
            <param name="matrix">Матрица</param>
            <returns>Ковариационнай матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MeanMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица средних 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.DispersionMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица дисперсий 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.StdMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица среднеквадратичных отклонений
            </summary>
            <param name="matrices">Массив матриц</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Parse(System.String)">
            <summary>
            Initialize matrix from string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Parse(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Initialize matrix from string
            </summary>
            <param name="str"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.TryParse(System.String,AI.DataStructs.Algebraic.Matrix@)">
            <summary>
            Tries to initialize matrix from string
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.TryParse(System.String,AI.DataStructs.Algebraic.Matrix@,System.Globalization.NumberFormatInfo)">
            <summary>
            Tries to initialize matrix from string
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromVectorsAsRows(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Initialize matrix from vector array where each vector is a matrix row
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromVectorsAsColumns(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Initialize matrix from vector array where each vector is a matrix column
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromStrings(System.String[0:,0:])">
            <summary>
            Initialize matrix from 2D array of strings
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromStrings(System.String[0:,0:],System.Globalization.NumberFormatInfo)">
            <summary>
            Initialize matrix from 2D array of strings
            </summary>
            <param name="arr"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Save(System.String)">
            <summary>
            Saves matrix to the file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Save(System.IO.Stream)">
            <summary>
            Saves matrix to the stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.SaveAsText(System.String)">
            <summary>
            Saves matrix to file in text format
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetBytes">
            <summary>
            Represents matrix as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Load(System.String)">
            <summary>
            Loads matrix from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Load(System.IO.Stream)">
            <summary>
            Loads matrix from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.LoadAsText(System.String)">
            <summary>
            Loads matrix from text file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromBytes(System.Byte[])">
            <summary>
            Initializes matrix from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initializes matrix from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.MatrixType">
            <summary>
            Тип матрицы
            </summary>
        </member>
        <member name="F:AI.DataStructs.Algebraic.MatrixType.Image">
            <summary>
            Изображение
            </summary>
        </member>
        <member name="F:AI.DataStructs.Algebraic.MatrixType.MatStruct">
            <summary>
            Математическая структура
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Data">
            <summary>
            Tensor data as a flat array
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Shape">
            <summary>
            Tensor shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Item(System.Int32[])">
            <summary>
            Returns value by indexes in all dimensions
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Save(System.String)">
            <summary>
            Saves NDTensor to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Save(System.IO.Stream)">
            <summary>
            Saves NDTensor to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.GetBytes">
            <summary>
            Represents NDTensor as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Load(System.String)">
            <summary>
            Loads NDTensor from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Load(System.IO.Stream)">
            <summary>
            Loads NDTensor from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromBytes(System.Byte[])">
            <summary>
            Initialize NDTensor form an array of bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initialize NDTensor form a data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Tensor">
            <summary>
            Represents a tensor of rank 3
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Depth">
            <summary>
            Depth
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Shape">
            <summary>
            Tensor shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Accessing an item by index
            </summary>
            <param name="i">Height</param>
            <param name="j">Width</param>
            <param name="k">Depth</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Double[0:,0:,0:])">
            <summary>
            Initialization with an array
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Creating a tensor with zeros
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creating a tensor with zeros
            </summary>
            <param name="height">Height</param>
            <param name="width">Width</param>
            <param name="depth">Depth</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Double[])">
            <summary>
            Initialization with an array
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="K"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="K"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Copy">
            <summary>
            Copy
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Element-wise transformation of tensor
            </summary>
            <param name="transform">Transform function</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.ToMatrices">
            <summary>
            Convert tensor to array of matrices
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromMatrices(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Convert matrix array to tensor
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.VectorToTensor(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Converting a vector to a tensor
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.SubtractingDepth(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Subtracting a vector element by element from depth
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.PlusD(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Add a vector element-wise to the depth
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Sum">
            <summary>
            Sum of all tensor elements
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Mean">
            <summary>
            Average of all tensor elements
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Dispersion(System.Double)">
            <summary>
            Dispersion
            </summary>
            <param name="mean">Calculated mean</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Dispersion">
            <summary>
            Dispersion
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Std(System.Double)">
            <summary>
            Standard deviation
            </summary>
            <param name="mean">Calculated mean</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Std">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Save(System.String)">
            <summary>
            Save tensor to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Save(System.IO.Stream)">
            <summary>
            Save tensor to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.GetBytes">
            <summary>
            Represents tensor as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Load(System.String)">
            <summary>
            Loads tensor from the file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Load(System.IO.Stream)">
            <summary>
            Loads tensor from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromBytes(System.Byte[])">
            <summary>
            Initialize tensor from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initialize tensor from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Vector">
            <summary>
            Class that implements vector and operations on it
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.AI#DataStructs#Algebraic#IAlgebraicStructure#Data">
            <summary>
            Vector data as an array
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.Shape">
            <summary>
            Vector shape
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor">
            <summary>
            Creates a vector of capacity 3
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Int32)">
            <summary>
            Creates a vector of custom capacity
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Double)">
            <summary>
            Creates a vector of dimension 1 with the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Double[])">
            <summary>
            Creates a vector from a double array
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Creates a vector from the IEnumerable interface of double
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Creates a vector from the IEnumerable interface of float
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Subtraction
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Subtraction
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Subtraction
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_UnaryNegation(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Negation
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Remainder of the division
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Remainder of the division
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Remainder of the division for each element
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.NanToValue(System.Double)">
            <summary>
            Replacing uncertainty with a number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.NanToMean">
            <summary>
            Replacing uncertainty with a mean
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Repeat(System.Int32)">
            <summary>
            Vector repeat
            </summary>
            <param name="count">Number of repetitions</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Cos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Cosine of angle between vectors
            </summary>
            <param name="vect"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxOut">
            <summary>
            Convert a vector to a one-hot representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxOutVector(System.Double,System.Double)">
            <summary>
            Getting a vector with one at the index position with the maximum value and -1 at the rest
            </summary>
            <param name="max"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetUnitVector">
            <summary>
            Getting a unit vector (direction vector)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Round(System.Int32)">
            <summary>
            Rounding
            </summary>
            <param name="num">Count of digits in the fraction</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Deleting selected items
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(System.Double[])">
            <summary>
            Deleting selected items
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(System.Collections.Generic.List{System.Double})">
            <summary>
            Deleting selected items
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetIntervalDouble(System.Int32,System.Int32,System.Double[])">
            <summary>
            Returns a vector in the range [a; b)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetInterval(System.Int32,System.Int32)">
            <summary>
            Returns a vector in the range [a; b)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Clone">
            <summary>
            Vector cloning
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddSimmetr">
            <summary>
            Adding a mirrored vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Revers">
            <summary>
            Writing the vector in reverse order, for example, the vector {1,2,3} turns into {3,2,1}
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.CutAndZero(System.Int32)">
            <summary>
            Zero padding or cropping to the desired vector size
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Shift(System.Int32)">
            <summary>
            Shift
            </summary>
            <param name="valueShift"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ToMatrix">
            <summary>
            Vector to matrix
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Downsampling(System.Int32)">
            <summary>
            Decimation (without filter) vector
            </summary>
            <param name="n">Decimation factor</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Decimation(System.Int32)">
            <summary>
            Decimation (with filter) vector, NWave backend
            </summary>
            <param name="n">Decimation factor</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.UnPooling(System.Int32)">
            <summary>
            Up sampling, inserting zeros in the middle
            </summary>
            <param name="kUnPool">The number of zeros between samples of the original vector</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.InterpolayrZero(System.Int32)">
            <summary>
            Interpolation by a polynomial of order zero
            </summary>
            <param name="kInterp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddOne">
            <summary>
            Adds one to the beginning
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IsFilledWithZeros">
            <summary>
            Checks if all elements of the vector are equal to zero
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IsFilledWithZeros(System.Int32)">
            <summary>
            Checks if a vector contains more than n zero elements
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Vector transformation
            </summary>
            <param name="transformFunc"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformByIndex(System.Func{System.Int32,System.Double})">
            <summary>
            Vector transformation
            </summary>
            <param name="transformFunc">Transform function, function from index</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformFromIndexAndValue(System.Func{System.Int32,System.Double,System.Double})">
            <summary>
            Transform vector
            </summary>
            <param name="transformFunc">Transform function, function from index and value F(int i, double vect_i)</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformWithArguments(AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Vector transformation (Use vector of arguments)
            </summary>
            <param name="transformFunc">Transform function, a function of the value of the vector of arguments and the current vector</param>
            <param name="x">Vector of arguments</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Scale">
            <summary>
            Scaling, brings the vector to a range of 0-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Min">
            <summary>
            Minimal value
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Max">
            <summary>
            Maximum value
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxAbs">
            <summary>
            Maximum absolute value
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinAbs">
            <summary>
            Minimal absolute value
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Mean">
            <summary>
            Arithmetic mean of a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Sum">
            <summary>
            Vector elements sum
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ContainsNan">
            <summary>
            Does the uncertainty vector contain
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Dispersion">
            <summary>
            Dispersion
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Std">
            <summary>
            STD
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Norm">
            <summary>
            Vector norm
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Normalise">
            <summary>
            Normalization
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Normalise(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Normalization
            </summary>
            <param name="mean"></param>
            <param name="std"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxElementIndex">
            <summary>
            Index of max element
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMaxElementIndex">
            <summary>
            Index of absolutely max element
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinElementIndex">
            <summary>
            Index of min element
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMinElementIndex">
            <summary>
            Index of absolutely min element
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Index of max element
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMaxElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Index of absolutely max element
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Index of min element
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMinElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Index of absolutely min element
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IndexValueNeighborhoodMin(System.Double)">
            <summary>
            Closest minimal indexc
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Crosser(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Creates one vector from two vectors by applying the cross function for each element.
            </summary>
            <param name="x">First vector</param>
            <param name="y">Second vector</param>
            <param name="cross">Mixing function(crossing)</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SummWithCollision(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Connection of vectors with overlapping, by summation in the region overlap
            </summary>
            <param name="data">Vectots</param>
            <param name="col">Overlapping areas (collisions)</param>
            <returns/>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.OneHotPol(System.Int32,System.Int32)">
            <summary>
            Unipolar conversion of index (natural number) to one-hot vector, everywhere value is 0, but at the specified index is 1
            </summary>
            <param name="index">Index</param>
            <param name="maxInd">Maximal possible index</param>
            <returns>Vector with all zeroes exept the position</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.OneHotBePol(System.Int32,System.Int32)">
            <summary>
             Unipolar conversion of index (natural number) to one-hot vector, everywhere value is -1, but at the specified index is 1
            </summary>
            <param name="index">Index</param>
            <param name="maxInd">Maximal possible index</param>
            <returns>Vector with all -1s exept the position</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Concat(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Vector concatenation
            </summary>
            <param name="vectors">Vectors</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SeqBeginsWithZero(System.Double,System.Double)">
            <summary>
            Sequence that begins with zero
            </summary>
            <param name="step">Step</param>
            <param name="end">Last value</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Seq(System.Double,System.Double,System.Double)">
            <summary>
            Sequence
            </summary>
            <param name="step">Step</param>
            <param name="end">Last value</param>
            <param name="start">First value</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Time0(System.Double,System.Double)">
            <summary>
            Array os times
            </summary>
            <param name="fd">Sampling frequency</param>
            <param name="t">Time (sec)</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindows(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Split to windows
            </summary>
            <param name="inp">Input</param>
            <param name="w">Window size</param>
            <param name="step">Step</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindowsWithFunc(System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Split to windows
            </summary>
            <param name="transformer">Transformation function</param>
            <param name="inp">Input</param>
            <param name="w">Window size</param>
            <param name="step">Step</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindowsWithFuncVect(System.Func{AI.DataStructs.Algebraic.Vector,System.Double},AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Split to windows
            </summary>
            <param name="transformer">Transformation function</param>
            <param name="inp">Input</param>
            <param name="w">Window size</param>
            <param name="step">Step</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ScaleData(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Data scaling, ensemble synchronization is performed for each case
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Mean(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Ensemble averaging
            </summary>
            <param name="vectors">Vector ensemble</param>
            <returns>Avarage vector</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Std(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            STD by ensemble
            </summary>
            <param name="vectors">Vector ensemble</param>
            <returns>Avarage vector</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetCharVector(System.String)">
            <summary>
            Cast string to vector of letters
            </summary>
            <param name="str">String</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Parse(System.String)">
            <summary>
            Initialize vector from string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Parse(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Initialize vector from string
            </summary>
            <param name="str"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TryParse(System.String,AI.DataStructs.Algebraic.Vector@)">
            <summary>
            Tries to initialize vector from string
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TryParse(System.String,AI.DataStructs.Algebraic.Vector@,System.Globalization.NumberFormatInfo)">
            <summary>
            Tries to initialize vector from string
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromStrings(System.String[])">
            <summary>
            Initialize vector from string array
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromStrings(System.String[],System.Globalization.NumberFormatInfo)">
            <summary>
            Initialize vector from string array
            </summary>
            <param name="arr"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromList(System.Collections.Generic.IList{System.Double})">
            <summary>
            Cast list to vector
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromReadOnlyList(System.Collections.Generic.IReadOnlyList{System.Double})">
            <summary>
            Cast read-only list to vector
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Save(System.String)">
            <summary>
            Saves vector to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Save(System.IO.Stream)">
            <summary>
            Saves vector to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SaveAsText(System.String)">
            <summary>
            Saves vector to file in text format
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetBytes">
            <summary>
            Represents vector as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Load(System.String)">
            <summary>
            Loads vector from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.LoadAsBinary(System.String)">
            <summary>
            Загрузка вектора из массива double
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SaveAsBinary(System.String,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сохранение в массив double
            </summary>
            <param name="path">Путь до файла</param>
            <param name="vect">Вектор</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Load(System.IO.Stream)">
            <summary>
            Loads vector from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.LoadAsText(System.String)">
            <summary>
            Loads vector from text file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromBytes(System.Byte[])">
            <summary>
            Initializes vector from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initilizes vector from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.BinarySerializer">
            <summary>
            Helper class for binary serialization
            </summary>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Load``1(System.String)">
            <summary>
            Loading from file
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Load``1(System.IO.Stream)">
            <summary>
            Loading from stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Save``1(System.String,``0)">
            <summary>
            Saving to a binary file
            </summary>
            <param name="filePath"></param>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Save``1(System.IO.Stream,``0)">
            <summary>
            Saving to a stream
            </summary>
            <param name="stream"></param>
            <param name="data"></param>
        </member>
        <member name="T:AI.DataStructs.IByteConvertable">
            <summary>
            Object with binary serialization support
            </summary>
        </member>
        <member name="M:AI.DataStructs.IByteConvertable.GetBytes">
            <summary>
            Writing an object to a byte array
            </summary>
        </member>
        <member name="T:AI.DataStructs.InMemoryDataStream">
            <summary>
            Class for simple IO operations
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsZipped">
            <summary>
            Tells if data in the stream is zipped
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsEncrypted">
            <summary>
            Tells if data in the stream is encrypted
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsForReading">
            <summary>
            Tells if stream is opened for reading
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsForWriting">
            <summary>
            Tells if stream is opened for writing
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IV">
            <summary>
            AES algorithm initialization vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor">
            <summary>
            Creates DataStream for writing data
            </summary>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from file
            </summary>
            <param name="path"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from byte array
            </summary>
            <param name="data"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int32)">
            <summary>
            Writes int to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int16)">
            <summary>
            Writes short to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Byte)">
            <summary>
            Writes byte to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Double)">
            <summary>
            Writes double to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Single)">
            <summary>
            Writes float to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int64)">
            <summary>
            Writes long to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.String)">
            <summary>
            Writes string in utf-8 encoding to the stream
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.String)">
            <summary>
            Writes string in utf-8 encoding to the stream
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.String,System.Text.Encoding)">
            <summary>
            Writes string in custom encoding to the stream
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.String,System.Text.Encoding)">
            <summary>
            Writes string in custom encoding to the stream
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Byte[])">
            <summary>
            Writes byte array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Double[])">
            <summary>
            Writes double array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Single[])">
            <summary>
            Writes float array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int32[])">
            <summary>
            Writes int array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int16[])">
            <summary>
            Writes short array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int64[])">
            <summary>
            Writes long array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Char[])">
            <summary>
            Writes char array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Double[])">
            <summary>
            Writes double array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Single[])">
            <summary>
            Writes float array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int32[])">
            <summary>
            Writes int array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int64[])">
            <summary>
            Writes long array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int16[])">
            <summary>
            Writes short array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Char[])">
            <summary>
            Writes char array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Char)">
            <summary>
            Writes char to the stream
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInt">
            <summary>
            Reads int from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInt(System.Int32@)">
            <summary>
            Reads int from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLong">
            <summary>
            Reads long from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLong(System.Int64@)">
            <summary>
            Reads long from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShort">
            <summary>
            Reads short from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShort(System.Int16@)">
            <summary>
            Reads short from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadByte">
            <summary>
            Reads byte from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadByte(System.Byte@)">
            <summary>
            Reads byte from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDouble">
            <summary>
            Reads double from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDouble(System.Double@)">
            <summary>
            Reads double from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloat">
            <summary>
            Reads float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloat(System.Single@)">
            <summary>
            Reads float from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString">
            <summary>
            Reads string in utf-8 encoding from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.String@)">
            <summary>
            Reads string in utf-8 encoding from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.Text.Encoding)">
            <summary>
            Reads string in custom encoding from the stream
            </summary>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.String@,System.Text.Encoding)">
            <summary>
            Reads string in custom encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadBytes">
            <summary>
            Reads byte array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadBytes(System.Byte[]@)">
            <summary>
            Reads byte array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles">
            <summary>
            Reads double array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Double[]@)">
            <summary>
            Reads double array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats">
            <summary>
            Reads float array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Single[]@)">
            <summary>
            Reads float array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts">
            <summary>
            Reads int array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32[]@)">
            <summary>
            Reads int array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts">
            <summary>
            Reads short array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int16[]@)">
            <summary>
            Reads short array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs">
            <summary>
            Reads long array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int64[]@)">
            <summary>
            Reads long array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars">
            <summary>
            Reads char array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Char[]@)">
            <summary>
            Reads char array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Int32)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Int32,System.Double[]@)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Int32)">
            <summary>
            Reads float array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Int32,System.Single[]@)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32)">
            <summary>
            Reads int array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32,System.Int32[]@)">
            <summary>
            Reads int array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int32)">
            <summary>
            Reads long array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int32,System.Int64[]@)">
            <summary>
            Reads long array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int32)">
            <summary>
            Reads short array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int32,System.Int16[]@)">
            <summary>
            Reads short array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Int32)">
            <summary>
            Reads char array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Int32,System.Char[]@)">
            <summary>
            Reads char array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChar">
            <summary>
            Reads char from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChar(System.Char@)">
            <summary>
            Reads char from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadInt(System.Int32@)">
            <summary>
            Tries to read int from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadInt(System.Int32@,System.Boolean@)">
            <summary>
            Tries to read int from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadLong(System.Int64@)">
            <summary>
            Tries to read long from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadLong(System.Int64@,System.Boolean@)">
            <summary>
            Tries to read long from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadShort(System.Int16@)">
            <summary>
            Tries to read short from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadShort(System.Int16@,System.Boolean@)">
            <summary>
            Tries to read short from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadByte(System.Byte@)">
            <summary>
            Tries to read byte from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadByte(System.Byte@,System.Boolean@)">
            <summary>
            Tries to read byte from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadDouble(System.Double@)">
            <summary>
            Tries to read double from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadDouble(System.Double@,System.Boolean@)">
            <summary>
            Tries to read double from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadFloat(System.Single@)">
            <summary>
            Tries to read float from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadFloat(System.Single@,System.Boolean@)">
            <summary>
            Tries to read float from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@)">
            <summary>
            Tries to read string in utf-8 encoding from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Boolean@)">
            <summary>
            Tries to read string in utf-8 encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Text.Encoding)">
            <summary>
            Tries to read string in custom encoding from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Text.Encoding,System.Boolean@)">
            <summary>
            Tries to read string custom encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadChar(System.Char@)">
            <summary>
            Tries to read char from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadChar(System.Char@,System.Boolean@)">
            <summary>
            Tries to read char from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Skip">
            <summary>
            Skip bytes of count equal to next int in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Skip(System.Int32)">
            <summary>
            Skip given count of bytes
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int32)">
            <summary>
            Skips next int in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int64)">
            <summary>
            Skips next long in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int16)">
            <summary>
            Skips next short in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Double)">
            <summary>
            Skips next double in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Single)">
            <summary>
            Skips next float in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Char)">
            <summary>
            Skips next char in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.String)">
            <summary>
            Skips next string in utf-8 encoding in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Skips next string in custom encoding in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int32)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int32,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int64)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int64,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int16)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int16,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Byte)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Byte,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Double)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Double,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Single)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Single,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String)">
            <summary>
            Checks if the next string in utf-8 encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Boolean@)">
            <summary>
            Checks if the next string in utf-8 encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Checks if the next string in custom encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Text.Encoding,System.Boolean@)">
            <summary>
            Checks if the next string in custom encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Char)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Char,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int32)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int64)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int16)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Byte)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Double)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Single)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.String)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Char)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Zip">
            <summary>
            Zips data in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.UnZip">
            <summary>
            Unzips data in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Encrypt(System.String,System.String)">
            <summary>
            Encrypts data in the stream
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Decrypt(System.String,System.String)">
            <summary>
            Decrypts data in the stream
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.AsByteArray">
            <summary>
            Returns data as a byte array
            </summary>
            <param name="copy"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ToMemoryStream">
            <summary>
            Returns data as a memory stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Save(System.String)">
            <summary>
            Saves data to the file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Save(System.IO.Stream)">
            <summary>
            Saves data to the System.IO.Stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ToString">
            <summary>
            Returns data as base64 string
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Create">
            <summary>
            Initialize empty DataStream for writing data
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from file
            </summary>
            <param name="path"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromSystemStream(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromByteArray(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from byte array
            </summary>
            <param name="data"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromBase64String(System.String,System.Boolean,System.Boolean)">
            <summary>
            Initialize DataStream from base64 string for reading data
            </summary>
            <param name="strBase64"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.ISavable">
            <summary>
            Object that can be saved
            </summary>
        </member>
        <member name="M:AI.DataStructs.ISavable.Save(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.ISavable.Save(System.IO.Stream)">
            <summary>
            Save to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:AI.DataStructs.ITextSavable">
            <summary>
            Object that can be saved in text format
            </summary>
        </member>
        <member name="M:AI.DataStructs.ITextSavable.SaveAsText(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape">
            <summary>
            Represents numerous dimentional shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Item(System.Int32)">
            <summary>
            Get length in the specific dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Rank">
            <summary>
            Rank of the shape (count of it dimensions)
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Count">
            <summary>
            Count of elements in the shape (product of all dimension's lengths)
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.#ctor(System.Int32[])">
            <summary>
            Creates numerous dimentional shape
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Shrink">
            <summary>
            Returns shape with 1 less dimension
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Expand(System.Int32)">
            <summary>
            Expands shape with 1 more dimension
            </summary>
            <param name="newDimensionLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.FuzzyEquals(AI.DataStructs.Shapes.Shape)">
            <summary>
            Returns true if shapes has equal element count and only differs by dimenson count 
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.GetDataCopy">
            <summary>
            Returns current object data copy as an array
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape1D">
            <summary>
            Represents 1D shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape1D.Width">
            <summary>
            Width in 1D
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.#ctor(System.Int32)">
            <summary>
            Creates 1D shape
            </summary>
            <param name="width"></param>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape2D">
            <summary>
            Represents 2D shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Height">
            <summary>
            Height in 2D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Width">
            <summary>
            Width in 2D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Area">
            <summary>
            Product of Height and Width
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates 2D shape
            </summary>
            <param name="height"></param>
            <param name="width"></param>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape3D">
            <summary>
            Represents 3D shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Height">
            <summary>
            Height in 3D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Width">
            <summary>
            Width in 3D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Depth">
            <summary>
            Depth in 3D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Area">
            <summary>
            Product of Height and Width
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Volume">
            <summary>
            Product of Height, Width and Depth
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates 3D shape
            </summary>
            <param name="height">Height</param>
            <param name="width">Width</param>
            <param name="depth">Depth</param>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape4D">
            <summary>
            Represents 4D shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Height">
            <summary>
            Height in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Width">
            <summary>
            Width in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Depth">
            <summary>
            Depth in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.X">
            <summary>
            Fourth dimension length
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Area">
            <summary>
            Product of Height and Width
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Volume">
            <summary>
            Product of Height, Width and Depth
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates 4D shape
            </summary>
            <param name="height">Height</param>
            <param name="width">Width</param>
            <param name="depth">Depth</param>
            <param name="x">Fourth dimension</param>
        </member>
        <member name="T:AI.DataStructs.TableOfContentsOfTheSortedVector">
            <summary>
            Оглавление сортированного вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.TableOfContentsOfTheSortedVector.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Оглавление сортированного вектора
            </summary>
            <param name="vect">Сортированный вектор</param>
            <param name="numCh">Число глав</param>
        </member>
        <member name="M:AI.DataStructs.TableOfContentsOfTheSortedVector.IndexValueNeighborhoodMin(System.Double)">
            <summary>
            Ближайший минимальный индекс
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.ComplexMatrix">
            <summary>
            Матрица с комплексными числами
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Data">
            <summary>
            Matrix data
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Height">
            <summary>
            Matrix height
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Width">
            <summary>
            Matrix width
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Shape">
            <summary>
            Matrix shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Get element by indexes
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.RealMatrix">
            <summary>
            Real parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.ImaginaryMatrix">
            <summary>
            Imaginary parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.MagnitudeMatrix">
            <summary>
            Magnitude parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.PhaseMatrix">
            <summary>
            Phase parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor">
            <summary>
            Creates matrix of 3x3 size
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates matrix of the given size
            </summary>
            <param name="height">Matrix height</param>
            <param name="width">Matrix width</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Creates matrix with real and imaginary element's parts represented as algebraic matrices
            </summary>
            <param name="real">Real element's part</param>
            <param name="imaginary">Imaginary element's part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Creates matrix with real element's parts represented as algebraic matrix and zero imaginary parts
            </summary>
            <param name="real">Реальная часть</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.op_Multiply(AI.DataStructs.WithComplexElements.ComplexMatrix,AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Matrix multiplication
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Transform(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Поэлементное преобразование матриц
            </summary>
            <param name="func">Функция преобразования</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.TransformSelf(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Матрица изменяет саму себя
            </summary>
            <param name="func">Функция преобразования</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixFFT(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Двумерное преобразование Фурье
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixIFFT(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Обратное двумерное преобразование Фурье
            </summary>
            <param name="input">Входная матрица</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixFFT(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Двумерное преобразование Фурье
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.GetColumns(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Разложение матрицы на столбцы
            </summary>
            <param name="matr">Матрица</param>
            <returns>Массив векторов</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.ConjugateMatr">
            <summary>
            Сопряженная матрица
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.AdamarProduct(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Адамарово произведение матриц (поэлементное)
            </summary>
            <param name="complexMatrix">Матрица на которую происходит умножение</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.AdamarProduct(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Адамарово произведение матриц (поэлементное)
            </summary>
            <param name="matrix">Матрица на которую происходит умножение</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Save(System.String)">
            <summary>
            Saves matrix to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Save(System.IO.Stream)">
            <summary>
            Saves matrix to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.GetBytes">
            <summary>
            Represents vector as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Load(System.String)">
            <summary>
            Loads matrix from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Load(System.IO.Stream)">
            <summary>
            Loads matrix from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.FromBytes(System.Byte[])">
            <summary>
            Initializes matrix from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initilizes matrix from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Class that implements vector of complex numbers
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.AI#DataStructs#WithComplexElements#IComplexStructure#Data">
            <summary>
            Complex array containing vector samples
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.Shape">
            <summary>
            Vector shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.RealVector">
            <summary>
            Real parts of all vector components represented as algebraic vector
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.ImaginaryVector">
            <summary>
            Imaginary parts of all vector components represented as algebraic vector
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.MagnitudeVector">
            <summary>
            Magnitude parts of all vector components represented as algebraic vector
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.PhaseVector">
            <summary>
            Phase parts of all vector components represented as algebraic vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor">
            <summary>
            Creates a vector with zeros (0 + 0j) of capacity 3
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Int32)">
            <summary>
            Creates a vector with zeros (0 + 0j) of dimension n
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Numerics.Complex)">
            <summary>
            Creates a vector of dimension 1 with the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Collections.Generic.IEnumerable{System.Numerics.Complex})">
            <summary>
            Creates a vector from the IEnumerable interface of Complex
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Double[],System.Double[])">
            <summary>
            Creates a vector based on arrays of real and imaginary parts
            </summary>
            <param name="vectorReal">Real part</param>
            <param name="vectorImg">Imaginary part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Creates a vector based on arrays of real and imaginary parts
            </summary>
            <param name="vectorReal">Real part</param>
            <param name="vectorImg">Imaginary part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Double[])">
            <summary>
            Creates a vector based on array of real part, imaginary filled with zeros
            </summary>
            <param name="vectorReal">Real part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Creates a vector based on vectors of real part, imaginary filled with zeros
            </summary>
            <param name="vectorReal">Real part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное сложение
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(System.Double,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,System.Double)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_UnaryNegation(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Отрицание
            </summary>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное вычитание
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Вычитание из числа
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Вычитание числа
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(System.Double,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Вычитание из числа
            </summary>
            <param name="k">реальное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,System.Double)">
            <summary>
            Вычитание числа
            </summary>
            <param name="k"> число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Умножение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поэлементное умножение на реальный вектор
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное умножение на реальный вектор
            </summary>
            <param name="right">Первый вектор</param>
            <param name="left">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Multiplication by a number
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное умножение
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Деление
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Деление
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное деление
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(AI.DataStructs.WithComplexElements.ComplexVector)~System.Numerics.Complex[]">
            <summary>
            Implicit cast ComplexVector -> Complex[]
            </summary>
            <param name="vect">Vector</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(System.Numerics.Complex[])~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast Complex[] -> ComplexVector
            </summary>
            <param name="dbs">Complex array</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(System.Double[])~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast double[] -> ComplexVector
            </summary>
            <param name="dbs">Double array</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(AI.DataStructs.Algebraic.Vector)~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast Vector -> ComplexVector
            </summary>
            <param name="dbs"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.CutAndZero(System.Int32)">
            <summary>
            Zero padding or cropping to the desired vector size.
            </summary>
            <param name="n">New dimension</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Clone">
            <summary>
            Vector cloning
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Revers">
            <summary>
            Vector reverse (mirror image)
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Shift(System.Int32)">
            <summary>
             Shift the sequence by a certain number.Example: the sequence 1 2 3 is shifted by 2 - this is {0 0 1 2 3}, by 4 - {0 0 0 0 1 2 3}
            </summary>
            <param name="valueShift">Shift amount</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FurCentr">
            <summary>
            Centering an array of values ​​obtained by the Fourier transform
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Decimation(System.Int32)">
            <summary>
            Decimation (thinning) vector
            </summary>
            <param name="kDecim">Decimation factor</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.AddSimmetr">
            <summary>
            Adding a reflected Vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.InterpolayZero(System.Int32)">
            <summary>
            Interpolation by a polynomial of order zero
            </summary>
            <param name="kInterp">Interpolation factor</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Transform(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Element-wise vector transformation
            </summary>
            <param name="func">Conversion function</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformSelf(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Element-wise vector transformation
            </summary>
            <param name="func">Conversion function</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexConjugate">
            <summary>
            Complex conjugate number
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexConjugateSelf">
            <summary>
            Complex conjugate number
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Mean">
            <summary>
            Arithmetic mean of a complex vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexVectorPhaseMagn(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Converting the vector of phases and amplitudes into a complex vector
            </summary>
            <param name="magn">Amplitude vector</param>
            <param name="phase"> Phase vector(rad)</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexVectorPhaseDegMagnDb(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.DbType)">
            <summary>
            Converting the vector of phases and amplitudes into a complex vector
            </summary>
            <param name="magnDb">Amplitude vector(db)</param>
            <param name="phaseDeg"> Phase vector(deg)</param>
            <param name="dbType">Тип дб по энергия/амплитуда</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformVectorX(AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Numerics.Complex})">
            <summary>
            Vector transformation(A vector of real arguments is used)
            </summary>
            <param name="transformFunc">Conversion function, a function of the value of a vector of arguments</param>
            <param name="x">Argument vector</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformVectorX(AI.DataStructs.WithComplexElements.ComplexVector,System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Vector transformation(Using a vector of complex arguments)
            </summary>
            <param name="transformFunc"> Conversion function, a function of the value of a vector of arguments</param>
            <param name="x">Argument vector</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Save(System.String)">
            <summary>
            Saves vector to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Save(System.IO.Stream)">
            <summary>
            Saves vector to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.GetBytes">
            <summary>
            Represents vector as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Load(System.String)">
            <summary>
            Loads vector from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Load(System.IO.Stream)">
            <summary>
            Loads vector from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FromBytes(System.Byte[])">
            <summary>
            Initializes vector from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initilizes vector from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.DbType">
            <summary>
            Decibel type
            </summary>
        </member>
        <member name="F:AI.DataStructs.WithComplexElements.DbType.Energy">
            <summary>
            Energetic
            </summary>
        </member>
        <member name="F:AI.DataStructs.WithComplexElements.DbType.Ampl">
            <summary>
            Amplitude
            </summary>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.IComplexStructure">
            <summary>
            Complex structure interface
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.IComplexStructure.Data">
            <summary>
            Structure data as 1D array
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.IComplexStructure.Shape">
            <summary>
            Structure shape
            </summary>
        </member>
        <member name="T:AI.DSP.Analyse.FrequencyResponse">
            <summary>
            АЧХ
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.FStart">
            <summary>
            Начальная частота
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.FEnd">
            <summary>
            Конечная частота
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Step">
            <summary>
            Шаг по частоте
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Time">
            <summary>
            Время реализации
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Freq">
            <summary>
            Отсчеты по частоте
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.FrequencyResponse.#ctor(System.Int32)">
            <summary>
            АЧХ
            </summary>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.DSP.Analyse.FrequencyResponse.Test(System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Проверка АЧХ алгоритма
            </summary>
            <param name="alg">Алгоритм</param>
        </member>
        <member name="T:AI.DSP.Analyse.Trend">
            <summary>
            Тренд сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.Trend.K">
            <summary>
            Коэффициент наклона
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.Trend.B">
            <summary>
            Смещение
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучающая выборка
            </summary>
            <param name="X">Вектор X(независимая переменная)</param>
            <param name="Y">Вектор Y(зависимая переменная)</param>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.ToString">
            <summary>
            Вывод в строку
            </summary>
            <returns>Строка типа: f(x) = k*x+(b)</returns>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.Predict(System.Double)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="x">Независимая переменная</param>
            <returns>Зависимая переменная</returns>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="X">Вектор независимых переменных</param>
            <returns>Вектор зависимых переменных</returns>
        </member>
        <member name="T:AI.DSP.Analyse.Welch">
            <summary>
            Welch method
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.Welch.WelchRun(AI.DataStructs.Algebraic.Vector,System.Int32,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
             Welch method run
            </summary>
            <param name="signal">Signal</param>
            <param name="window">Окно</param>
            <param name="overlap">Overlap</param>
            <param name="windowForFFT">Window weighting function</param>
        </member>
        <member name="M:AI.DSP.Analyse.Welch.BartlettRun(AI.DataStructs.Algebraic.Vector,System.Int32,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Running the periodogram method
            </summary>
            <param name="signal">Signal</param>
            <param name="window">Window</param>
            <param name="windowForFFT">Window weighting function</param>
        </member>
        <member name="T:AI.DSP.Channel">
            <summary>
            Channel
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.ChData">
            <summary>
            Отсчеты сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Fd">
            <summary>
            Sampling frequency
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Dt">
            <summary>
            Шаг по времени
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Name">
            <summary>
            Имя канала
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Description">
            <summary>
            Описание
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Item(System.Int32)">
            <summary>
            Доступ по индексам к данным канала
            </summary>
            <param name="i">Index</param>
        </member>
        <member name="P:AI.DSP.Channel.ScaleVolt">
            <summary>
            Voltage scale
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.#ctor">
            <summary>
            Channel
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Channel, задается через вектор данных и частоту дискретизации
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,System.String)">
            <summary>
            Channel, задается через вектор данных, частоту дискретизации и имя
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
            <param name="name">Имя</param>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,System.String,System.String)">
            <summary>
            Channel, задается через вектор данных, частоту дискретизации, имя и  описание
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
            <param name="name">Имя</param>
            <param name="description">Описание</param>
        </member>
        <member name="M:AI.DSP.Channel.GetChannels(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Преобразует масив векторов в массив каналов
            </summary>
            <param name="vects">Массив векторов</param>
            <param name="fd">Sampling frequency</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Channel.ChansToVects(AI.DSP.Channel[])">
            <summary>
            Массив каналов в массив векторов
            </summary>
            <param name="channels">Массив каналов</param>
        </member>
        <member name="M:AI.DSP.Channel.SignalTrend">
            <summary>
            Тренды сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithoutTrend">
            <summary>
            Сигнал без тренда
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithM0Std1Trend">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается тренд)
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithM0Std1">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается среднее)
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.GetSpectr">
            <summary>
            Рассчитывает спектр
            </summary>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Channel.GetSpectr(System.Func{System.Int32,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчитывает спектр с использованием оконных функций
            </summary>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Channel.Time">
            <summary>
            Генерация отсчетов времени
            </summary>
            <returns>Отсчеты времени</returns>
        </member>
        <member name="M:AI.DSP.Channel.Freq">
            <summary>
            Генерация отсчетов частоты
            </summary>
            <returns>Отсчеты частоты</returns>
        </member>
        <member name="M:AI.DSP.Channel.KoefScaleToVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Коэффициент для перевода в вольты
            </summary>
            <param name="scaleVolt">Масштаб</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Channel.YName">
            <summary>
            Единица измерения шкалы Y
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.ConvertVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Конвертирование масштаба по Y
            </summary>
            <param name="newScale">Новый масштаб</param>
        </member>
        <member name="M:AI.DSP.Channel.Filtration(AI.DSP.DSPCore.IFilter)">
            <summary>
            Фильтрация канала
            </summary>
            <param name="filter">Фильтр</param>
        </member>
        <member name="T:AI.DSP.DSPCore.DCT">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT.MainMatrix">
            <summary> 
            Матрица прямого преобразования
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT.InvMatrix">
            <summary> 
            Матрица обратного преобразования
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.#ctor">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.#ctor(System.Int32,System.Int32)">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
            <param name="countInp">Кол-во входов</param>
            <param name="countOutp">Кол-во Выходов</param>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.GetMatrW(System.Int32,System.Int32)">
            <summary>
            Матрица
            </summary>
            <param name="Count"></param>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.DirectDCTNorm(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямое ДКТ
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.InversDCTNorm(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обратное Дкт
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.DSPCore.FastConv">
            <summary>
            Реализация быстрых сверток
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Impulse response</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Быстрая свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Impulse response</param>
            <param name="fd">Sampling frequency</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolutionNorm(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая нормированная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Impulse response</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastCorrelation(System.Double[])">
            <summary>
            Быстрая корреляция
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastCorrelation(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая нормированная корреляция
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Патерн</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.SectionalConvolutionNorm(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Быстрая секционная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="pattern">Паттерн (участок в разы меньше сигнала)</param>
            <param name="num">Число секций</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.SectionalConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Быстрая секционная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="pattern">Паттерн (участок в разы меньше сигнала)</param>
            <param name="num">Число секций</param>
        </member>
        <member name="T:AI.DSP.DSPCore.FastHilbert">
            <summary>
            Description of Hilbert.
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.ConjugateToTheHilbert(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сигнал сопряженный по Гильберту
            </summary>
            <param name="st">Исходный сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.GetAnalSig(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Аналитический сигнал
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Envelope(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Огибающая
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Phase(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Мгновенная фаза
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Frequency(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Мгновенная частота
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.EnvelopeIQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение огибающей на базе квадратурн. сост
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.PhaseIQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение девиации частоты на базе квадратурн. сост
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.IQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение девиации частоты на базе квадратурн. сост
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.Filters">
            <summary>
            Класс для реализации цифровых фильтров
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.Filter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Boolean)">
            <summary>
            Реализация простого фильтра
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="kw">АЧХ</param>
            <param name="mean">Нужна ли постоянная составляющая</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.Filter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector,System.Boolean)">
            <summary>
            Реализация простого фильтра
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="kw">КЧХ</param>
            <param name="mean">Нужна ли постоянная составляющая</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterKontur(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Реализация колебательного контура
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="Q">Добротность</param>
            <param name="f0">Резонансная частота</param>
            <param name="fd">Sampling frequency</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLow(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            ФНЧ (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLowButterworthCFH(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            ФНЧ (АЧХ повторяет АЧХ Баттерворта), задан через КЧХ
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <param name="order">Порядок фильтра</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLowButterworthAFH(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            ФНЧ (АЧХ повторяет АЧХ Баттерворта), задан через АЧХ
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <param name="order">Порядок фильтра</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterBand(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Полосовой фильтр (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr1">Нижняя частота полосы</param>
            <param name="sr2">Верхняя частота полосы</param>
            <param name="fd">Sampling frequency</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterHigh(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            ФВЧ (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterRezector(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Режекторный фильтр
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr1">Нижняя частота полосы</param>
            <param name="sr2">Верхняя частота полосы</param>
            <param name="fd">Sampling frequency</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.GetAFH(AI.DataStructs.Algebraic.Vector,System.Double[],AI.DSP.DSPCore.AFHType)">
            <summary>
            Создание АЧХ нужного типа
            </summary>
            <param name="f">Вектор частот</param>
            <param name="param">параметры</param>
            <param name="afh">Тип АЧХ</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.CreatAFH(AI.DataStructs.Algebraic.Vector,System.String[])">
            <summary>
            Создание составной АЧХ
            </summary>
            <param name="f">Вектор частот</param>
            <param name="param">Параметры</param>
            <returns>Возвращает АЧХ</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ExpAv(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Эспоненциональное скользящее среднее
            </summary>
            <param name="inp">Input</param>
            <param name="oldPart">Коэффициент сглаживания</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.MAv(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Cкользящее среднее
            </summary>
            <param name="inp">Input</param>
            <param name="l">Размер окна</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.GetEnvelope(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Получение огибающей
            </summary>
            <param name="inp"></param>
            <param name="dec">Прореживание</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ButterworthLowAFH(System.Int32,System.Double,System.Int32,System.Int32)">
            <summary>
            Ачх фильтра Баттерворта
            </summary>
            <param name="Count">Число отсчетов сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ButterworthLowCFH(System.Int32,System.Double,System.Int32,System.Int32)">
            <summary>
            КЧХ фильтра Баттерворта
            </summary>
            <param name="Count">Число отсчетов сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="T:AI.DSP.DSPCore.AFHType">
            <summary>
            Типы АЧХ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Low">
            <summary>
            ФНЧ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.High">
            <summary>
            ФВЧ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Rezector">
            <summary>
            Режектор
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Band">
            <summary>
            Полосовой
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.GetSpectrEnerge">
            <summary>
            Description of GetSpectrEnerge.
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.#ctor(System.Double)">
            <summary>
            Анализ формант
            </summary>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.Add(System.Double,System.Double)">
            <summary>
            Добавление диапозона частот
            </summary>
            <param name="b">Начальная частота форманты</param>
            <param name="e">Конечная частота форманты</param>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.GetAmplFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
             Возвращает суммарные амплитуды в формантах
            </summary>
            <param name="inp">Входной вектор</param>
            <returns>Вектор амплитуд</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.IFilter">
            <summary>
            Интерфейс фильтра
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.IFilter.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.IFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Запуск фильтрации
            </summary>
            <param name="signal">Исходный сигнал</param>
            <returns>Отфильтрованный</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.Kepstr">
             <summary>
            Кепстральный анализ
             </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Kepstr.FKT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрое кепстральное преобразование
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Kepstr.FKT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Быстрое кепстральное преобразование
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.DSPCore.OptimalFilter">
            <summary>
            Description of OptimalFilter.
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Оптимальный (согласованный) фильтр
            </summary>
            <param name="signal"></param>
            <param name="n"></param>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.Result(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прохождение фильтра
            </summary>
            <param name="signal">Сигнал на входе</param>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.SpectrCompressLFM(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Сжатие ЛЧМ по спектру
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.Signal">
            <summary>
            Description of Signal.
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Frequency(System.Int32,System.Double)">
            <summary>
            Массив частот
            </summary>
            <param name="Count">Кол-во значений</param>
            <param name="fd">Sampling frequency</param>
            <returns>Вектор частот</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.FrequencyCentr(System.Int32,System.Double)">
            <summary>
            Центрированный массив частот 
            </summary>
            <param name="Count">Кол-во значений</param>
            <param name="fd">Sampling frequency</param>
            <returns>Вектор частот</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Вектор амплитуд</param>
            <param name="f">Частота</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Вектор частот</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <param name="fi">Вектор фаз</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Вектор амплитуда</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="f">Частота</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Carrier frequency</param>
            <param name="fi1">Фаза модулирующего сигала</param>
            <param name="f2">Частота модулятора</param>
            <param name="fi2">Фаза модулируемого сигала</param>
            <param name="k">Modulation rate</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Carrier frequency</param>
            <param name="f2">Частота модулятора</param>
            <param name="fi2">Фаза модулируемого сигала</param>
            <param name="k">Modulation rate</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Carrier frequency</param>
            <param name="f2">Частота модулятора</param>
            <param name="k">Modulation rate</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRectK(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f1">Carrier frequency</param>
            <param name="f2">Частота модулятора</param>
            <param name="k">Modulation rate</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRectA(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Carrier frequency</param>
            <param name="f2">Частота модулятора</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания
            </summary>
            <param name="t"></param>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.DampedOscillations(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Затухающие колебания
            </summary>
            <param name="t">Время симуляции</param>
            <param name="f">частота</param>
            <param name="kDamp">Коэффициент затухания</param>
            <param name="A">Амплитуда(начальная)</param>
            <param name="fi">Фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Energe(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Энергия выделяемая на едичном резисторе за все время
            </summary>
            <param name="signal">Сигнал отсчеты</param>
            <param name="fd">Частота дискретизация</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.LFMRectNP(System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Пачка ЛЧМ
            </summary>
            <param name="f"></param>
            <param name="f0"></param>
            <param name="fd"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.LFM(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            ЛЧМ
            </summary>
            <param name="df"></param>
            <param name="f0"></param>
            <param name="fd"></param>
            <param name="time"></param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Perediscr(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Передискретизация сигнала
            (повышение частоты дискретизации в целое число раз)
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="fd">Старая частота дискретизации</param>
            <param name="newfd">Новая частота дикретизации</param>
            <returns>Вектор тойже длительности, что и входной,
            но с более высокой частотой дискретизации</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Norm(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Норма сигнала
            </summary>
            <param name="signal"></param>
            <param name="fd"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.DSPCore.Wavelet">
            <summary>
            Вейвлеты
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Wavelet.#ctor(AI.DSP.DSPCore.PerentWavelet)">
            <summary>
            Непрерывное вейвлет преобразование
            </summary>
            <param name="pw">Порождение вейвлетов</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Wavelet.SerchPatern(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поиск патернов в сигнале
            </summary>
            <param name="sig">Сигнал</param>
            <returns>Максимумы патернов</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.PerentWavelet">
            <summary>
            Ф-я порождения вейвлетов
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.waveletSpectrs">
            <summary>
            Спектры ф-й
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.fur">
            <summary>
            Фурье
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.std">
            <summary>
            Вектор СКО
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.scals">
            <summary>
            Масштабы
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.PerentWavelet.#ctor(System.Func{System.Double,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Порождения вейвлетов
            </summary>
            <param name="wavelet">Порождающая функция</param>
            <param name="scales">Масштабы</param>
            <param name="n">Размерность входа</param>
        </member>
        <member name="T:AI.DSP.FIR.FilterLowButterworth">
            <summary>
            Фильтр Баттерворта
            </summary>
        </member>
        <member name="P:AI.DSP.FIR.FilterLowButterworth.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="M:AI.DSP.FIR.FilterLowButterworth.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Фильтр Баттерворта
            </summary>
            <param name="f0">Частота среза</param>
            <param name="fd">Sampling frequency</param>
            <param name="signalLen">Длинна реализации</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="M:AI.DSP.FIR.FilterLowButterworth.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Фильтрация сигнала
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="T:AI.DSP.FIR.FIRFilter">
            <summary>
            Фильтр с конечной импульсной характеристикой
            </summary>
        </member>
        <member name="P:AI.DSP.FIR.FIRFilter.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="M:AI.DSP.FIR.FIRFilter.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,AI.DSP.FIR.FIRCalcConvType)">
            <summary>
            Инициализация фильтра
            </summary>
            <param name="ht">Impulse response фильтра</param>
            <param name="fd">Sampling frequency</param>
            <param name="calcConvType">Метод расчета свертки</param>
        </member>
        <member name="M:AI.DSP.FIR.FIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Расчет отклика фильтра на сигнал
            </summary>
            <param name="input">Сигнал</param>
        </member>
        <member name="T:AI.DSP.FIR.FIRCalcConvType">
            <summary>
            Метод расчета свертки
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Simple">
            <summary>
            Простая свертка
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.WithFFT">
            <summary>
            Быстрая с исп. БПФ
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Sectional">
            <summary>
            Секционная
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Sectional4">
            <summary>
            Секционная 4 потока
            </summary>
        </member>
        <member name="T:AI.DSP.IIR.IIRFilter">
            <summary>
            IIR filter
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.Name">
            <summary>
            Filter name
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.A">
            <summary>
            Coefficients a
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.B">
            <summary>
            Coefficients b
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.Treshold">
            <summary>
            Signal clipping
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            IIR filter
            </summary>
            <param name="a">Coefficients a</param>
            <param name="b">Coefficients b</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(System.Double)">
            <summary>
            Filter output
            </summary>
            <param name="inp">Input</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recursive filter output
            </summary>
            <param name="signal">Input signal</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Recursive filter output
            </summary>
            <param name="signal">Input signal</param>
            <param name="iteration">Filtering iterations</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Reset">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.ExportState">
            <summary>
            State export
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.ImportState(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Importing filter state
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="offsetA">Offset outputs</param>
            <param name="offsetB">Offset inputs</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Save(System.String)">
            <summary>
            Filter save
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Load(System.String)">
            <summary>
            Filter load
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Load(System.Byte[])">
            <summary>
            Filter load
            </summary>
            <param name="data">Buffer</param>
        </member>
        <member name="T:AI.DSP.Modulation.AM">
            <summary>
            Amplitude modulation
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.AM.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Инициализация модулятора ампл. модуляции
            </summary>
            <param name="fd">Sampling frequency</param>
            <param name="f0">Carrier frequency</param>
            <param name="m">Modulation rate</param>
        </member>
        <member name="M:AI.DSP.Modulation.AM.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция
            </summary>
            <param name="signalIn"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.AM.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция
            </summary>
            <param name="channel">Channel с модулированным сигналом</param>
        </member>
        <member name="M:AI.DSP.Modulation.AM.ModulateSimple(AI.DSP.Channel)">
            <summary>
            Модуляция для сигналов с одинаковой частотой дискретизации
            </summary>
            <param name="signalIn">Входной сигнал</param>
        </member>
        <member name="T:AI.DSP.Modulation.DSB">
            <summary>
            Амплитудная модуляция с подавленной центральной частотой
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.DSB.#ctor(System.Int32,System.Double)">
            <summary>
            Инициализация модулятора ампл. модуляции с подавленной несущей
            </summary>
            <param name="fd">Sampling frequency</param>
            <param name="f0">Carrier frequency</param>
        </member>
        <member name="M:AI.DSP.Modulation.DSB.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодулятор
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="M:AI.DSP.Modulation.DSB.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция
            </summary>
            <param name="signalIn"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.DSB.ModulateSimple(AI.DSP.Channel)">
            <summary>
            Модуляция для сигналов с одинаковой частотой дискретизации
            </summary>
            <param name="signalIn">Входной сигнал</param>
        </member>
        <member name="T:AI.DSP.Modulation.FM">
            <summary>
            Частотная модуляция
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.FM.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Инициализация модулятора частотной модуляции
            </summary>
            <param name="fd">Sampling frequency</param>
            <param name="f0">Carrier frequency</param>
            <param name="deltF">Дифиация частоты</param>
        </member>
        <member name="M:AI.DSP.Modulation.FM.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция ЧМК
            </summary>
            <param name="channel">Channel</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.FM.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция
            </summary>
            <param name="signalIn"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.FM.ModulateSimple(AI.DSP.Channel)">
            <summary>
            Модуляция для сигналов с одинаковой частотой дискретизации
            </summary>
            <param name="signalIn">Входной сигнал</param>
        </member>
        <member name="T:AI.DSP.Modulation.IModulator">
            <summary>
            Интерфейс модулятора
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.IModulator.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция сигнала
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="M:AI.DSP.Modulation.IModulator.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция сигнала
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="T:AI.DSP.Modulation.SSB">
            <summary>
            Однополосная амплитудная модуляция
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.SSB.#ctor(System.Int32,System.Double,AI.DSP.Modulation.SSBType)">
            <summary>
            Инициализация модулятора однополосной ампл. модуляции
            </summary>
            <param name="fd">Sampling frequency</param>
            <param name="f0">Carrier frequency</param>
            <param name="ssbType">Какая полоса будет подавлена</param>
        </member>
        <member name="M:AI.DSP.Modulation.SSB.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция
            </summary>
            <param name="signalIn"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.SSB.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="M:AI.DSP.Modulation.SSB.ModulateSimple(AI.DSP.Channel)">
            <summary>
            Модуляция для сигналов с одинаковой частотой дискретизации
            </summary>
            <param name="signalIn">Входной сигнал</param>
        </member>
        <member name="T:AI.DSP.Modulation.SSBType">
            <summary>
            Какая полоса будет подавлена
            </summary>
        </member>
        <member name="F:AI.DSP.Modulation.SSBType.Up">
            <summary>
            Верхняя
            </summary>
        </member>
        <member name="F:AI.DSP.Modulation.SSBType.Down">
            <summary>
            Нижняя
            </summary>
        </member>
        <member name="T:AI.DSP.MusicUtils.EchoReverb">
            <summary>
            Class for creating echo and reverb
            </summary>
        </member>
        <member name="P:AI.DSP.MusicUtils.EchoReverb.SampleRate">
            <summary>
            Project sampling rate
            </summary>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.#ctor(System.Int32)">
            <summary>
            Echo and reverb
            </summary>
            <param name="sr">Project sampling rate</param>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.Echo(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Echo effect
            </summary>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.EchoInvers(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Echo effect
            </summary>
        </member>
        <member name="T:AI.DSP.Oversampling.UpSampling">
            <summary>
            Увеличение частоты дискретизации
            </summary>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingRectFilter(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр с прямоугольной АЧХ)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Sampling frequency</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingButterworthFilter(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр Баттерворта)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Sampling frequency</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingButterworthFilterW(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр Баттерворта)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Sampling frequency</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="T:AI.DSP.PhaseCorrectingWindow">
            <summary>
            Windows for correcting phase discontinuities
            </summary>
        </member>
        <member name="T:AI.DSP.Signal1D">
            <summary>
            Основной класс для одномерного сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Name">
            <summary>
            Имя сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Description">
            <summary>
            Описание сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Fd">
            <summary>
            Sampling frequency
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Dt">
            <summary>
            Шаг по времени
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.ScaleVolt">
            <summary>
            Масштаб в вольтах
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="channels">Сигнал</param>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor">
            <summary>
            Создает пустой список каналов
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DSP.Channel)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Add(AI.DSP.Channel)">
            <summary>
            Добавление сигнала
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Trends">
            <summary>
            Тренды сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithoutTrend">
            <summary>
            Сигнал без тренда
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithM0Std1Trend">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается тренд)
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithM0Std1">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается среднее)
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.GetSpectr(System.Int32)">
            <summary>
            Рассчитывает спектр
            </summary>
            <param name="numCh">Номер канала</param>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.GetSpectrAll">
            <summary>
            Рассчитывает спектр по всем каналам
            </summary>
            <returns>Спектры</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CorrelationMatrix">
            <summary>
            Корреляционная матрица по каналам
            </summary>
            <returns>Матрица</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CorrelationMatrixSpectr">
            <summary>
            Корреляционная матрица амплитудных спектров
            </summary>
            <returns>Матрица</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CouplingCoefficient">
            <summary>
            Коэффициент связи между каналами рассчитывается как, единица минус определитель корреляционной матрицы
            </summary>
            <returns>Коэфициент связи [1,0] близко к 1 связь сильная, к 0 слабая</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CouplingCoefficientSp">
            <summary>
            Коэффициент связи между сперктрами каналов рассчитывается как, единица минус определитель корреляционной матрицы амплитудных спектров
            </summary>
            <returns>Коэфициент связи [1,0] близко к 1 связь сильная, к 0 слабая</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.Time">
            <summary>
            Генерация отсчетов времени
            </summary>
            <returns>Отсчеты времени</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.Freq">
            <summary>
            Генерация отсчетов частоты
            </summary>
            <returns>Отсчеты частоты</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.ConvertVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Конвертирование шкалы напряжения 
            </summary>
            <param name="typeScaleVolt">Новый масштаб</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Filtration(AI.DSP.DSPCore.IFilter)">
            <summary>
            Фильтрация сигнала
            </summary>
            <param name="filter">Фильтр</param>
        </member>
        <member name="M:AI.DSP.Signal1D.YName">
            <summary>
            Единица измерения шкалы Y
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.ChannelNames">
            <summary>
            Список имен каналов
            </summary>
        </member>
        <member name="T:AI.DSP.ISpectr">
            <summary>
            Базовый интерфейс реализации спектров
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Freq">
            <summary>
            Отсчеты частоты
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Data">
            <summary>
            Данные спектра
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Name">
            <summary>
            Имя
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.YLable">
            <summary>
            Название шкалы Y
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.XLable">
            <summary>
            Название шкалы X
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.IsDbScale">
            <summary>
            Выводится ли шкала данные по Y в децибелах
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.LogScaleX">
            <summary>
            Логарифмическая ли шкала частот
            </summary>
        </member>
        <member name="T:AI.DSP.AmplitudeSpectr">
            <summary>
            Амплитудный спектр
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Freq">
            <summary>
            Отсчеты частоты
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Data">
            <summary>
            Амплитуды спектра
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Name">
            <summary>
            Имя
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.YLable">
            <summary>
            Название шкалы Y
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.XLable">
            <summary>
            Название шкалы X
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.IsDbScale">
            <summary>
            Выводится ли шкала данные по Y в децибелах
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.LogScaleX">
            <summary>
            Логарифмическая ли шкала частот
            </summary>
        </member>
        <member name="M:AI.DSP.AmplitudeSpectr.#ctor(AI.DSP.Channel,System.Boolean)">
            <summary>
            Амплитудный спектр
            </summary>
            <param name="channel">Channel</param>
            <param name="isDbScale">Выражать ли в db, 20log(x)</param>
        </member>
        <member name="M:AI.DSP.AmplitudeSpectr.#ctor(AI.DSP.Channel,System.Func{System.Int32,AI.DataStructs.Algebraic.Vector},System.Boolean)">
            <summary>
            Амплитудный спектр
            </summary>
            <param name="channel">Channel</param>
            <param name="windowWFunc">Оконная функция</param>
            <param name="isDbScale">Выражать ли в db, 20log(x)</param>
        </member>
        <member name="T:AI.DSP.SpectrumStretching">
            <summary>
            Spectrum stretching and compression class
            </summary>
        </member>
        <member name="M:AI.DSP.SpectrumStretching.SpectrumStretch(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            Spectrum stretching
            </summary>
            <param name="signal">Input signal</param>
            <param name="k">Stretch ratio</param>
        </member>
        <member name="T:AI.DSP.TypeScaleVolt">
            <summary>
            Масштаб в вольтах
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.kV">
            <summary>
            Киловольты 
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.V">
            <summary>
            Вольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.mV">
            <summary>
            Милливольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.uV">
            <summary>
            Микровольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.nV">
            <summary>
            Нановольты
            </summary>
        </member>
        <member name="T:AI.FFT">
            <summary>
            Fourier transform
            </summary>
        </member>
        <member name="F:AI.FFT.SemplesCount">
            <summary>
            FFT Samples
            </summary>
        </member>
        <member name="M:AI.FFT.#ctor(System.Int32)">
            <summary>
            FFT (init rotate coef)
            </summary>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.Algebraic.Vector,System.Boolean)">
            <summary>
            FFT
            </summary>
        </member>
        <member name="M:AI.FFT.CalcFFT(System.Double[],System.Int32,System.Boolean)">
            <summary>
            FFT
            </summary>
        </member>
        <member name="M:AI.FFT.CalcIFFTReal(System.Numerics.Complex[],System.Int32)">
            <summary>
            FFT
            </summary>
        </member>
        <member name="M:AI.FFT.RealIFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            The real part of the Inverse FFT
            </summary>
        </member>
        <member name="M:AI.FFT.RealIFFT2(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            The real part of the FFT(not normalized to the number of samples)
            </summary>
        </member>
        <member name="M:AI.FFT.GetSpectrum(AI.DataStructs.Algebraic.Vector,System.Func{System.Int32,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Gives a signal spectrum from 0 to fd / 2
            </summary>
            <param name="input">Input data vector</param>
            <param name="window">Window function</param>
        </member>
        <member name="M:AI.FFT.IFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Inverse FFT
            </summary>
            <param name="inp">Input</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(System.Numerics.Complex[])">
            <summary>
            Возвращает спектр сигнала
            </summary>
            <param name="inp">Массив значений сигнала. Количество значений должно быть степенью 2</param>
            <returns>Массив со значениями спектра сигнала</returns>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Возвращает комплексный вектор спектра сигнала
            </summary>
            <param name="inp">Массив значений сигнала. Количество значений должно быть степенью 2</param>
            <returns>Массив со значениями спектра сигнала</returns>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрое преобразование Фурье(БПФ)
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            ОБПФ
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            ОБПФ
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.TimeFrTransform(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Time-frequency conversion
            </summary>
            <param name="vect">Vector</param>
            <param name="lenFr">Frame size</param>
        </member>
        <member name="M:AI.FFT.TimeFrTransformHalf(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Time-frequency conversion
            </summary>
            <param name="vect">Vector</param>
            <param name="lenFr">Frame size</param>
        </member>
        <member name="T:AI.WindowForFFT">
            <summary>
            FFT window functions
            </summary>
        </member>
        <member name="M:AI.WindowForFFT.HannWindow(System.Int32)">
            <summary>
            Hann (Henning) window provides -31.5 dB sidelobe level
            </summary>
            <param name="windowSize">Window size</param>
        </member>
        <member name="M:AI.WindowForFFT.HammingWindow(System.Int32)">
            <summary>
            Hamming window provides -42 dB sidelobe level
            </summary>
            <param name="windowSize">Window size</param>
        </member>
        <member name="M:AI.WindowForFFT.RectWindow(System.Int32)">
            <summary>
            Rectangular window provides -13 dB sidelobe level
            </summary>
            <param name="windowSize">Window size</param>
        </member>
        <member name="M:AI.WindowForFFT.BlackmanWindow(System.Int32)">
            <summary>
            Blackman window provides sidelobe level -58 db
            </summary>
            <param name="windowSize">Window size</param>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.GetDimention(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Getting the vector of the desired coordinate from the array of vectors
            </summary>
            <param name="array"></param>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.CVExtension">
            <summary>
            Extensoins for computer vision
            </summary>
        </member>
        <member name="M:AI.Extensions.CVExtension.ToMatrix(System.Drawing.Bitmap)">
            <summary>
            Преобразование картинки в матрицу
            </summary>
            <param name="bitmap">Картинка</param>
        </member>
        <member name="M:AI.Extensions.CVExtension.ToMatrix(System.Drawing.Bitmap,System.Int32,System.Int32)">
            <summary>
            Преобразование картинки в матрицу
            </summary>
            <param name="bitmap">Картинка</param>
            <param name="newWidth">Новая ширин</param>
            <param name="newHeights">Новая высота</param>
        </member>
        <member name="M:AI.Extensions.CVExtension.ToTensor(System.Drawing.Bitmap)">
            <summary>
            Преобразование картинки в тензор
            </summary>
            <param name="bitmap">Картинка</param>
        </member>
        <member name="M:AI.Extensions.CVExtension.ToTensor(System.Drawing.Bitmap,System.Int32,System.Int32)">
            <summary>
            Преобразование картинки в тензор и изменение размера
            </summary>
            <param name="bitmap">Картинка</param>
            <param name="newW">Новая ширина</param>
            <param name="newH">Новая высота</param>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.Write(AI.DataStructs.InMemoryDataStream,AI.DataStructs.IByteConvertable)">
            <summary>
            Writes IByteConvertable to the stream
            </summary>
            <param name="stream"></param>
            <param name="convertable"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.Write(AI.DataStructs.InMemoryDataStream,AI.DataStructs.IByteConvertable[])">
            <summary>
            Writes IByteConvertable array to the stream
            </summary>
            <param name="stream"></param>
            <param name="convertables"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVector(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads vector from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVector(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Vector@)">
            <summary>
            Reads vector from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVectors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads vector array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVectors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Vector[]@)">
            <summary>
            Reads vector array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrix(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads matrix from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrix(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Matrix@)">
            <summary>
            Reads matrix from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrices(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads matrix array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrices(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Matrix[]@)">
            <summary>
            Reads matrix array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensor(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads tensor from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensor(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Tensor@)">
            <summary>
            Reads tensor from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads tensor array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Tensor[]@)">
            <summary>
            Reads tensor array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensor(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NDTensor from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensor(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.NDTensor@)">
            <summary>
            Reads NDTensor from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NDTensor array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.NDTensor[]@)">
            <summary>
            Reads NDTensor array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValue(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NNValue from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValue(AI.DataStructs.InMemoryDataStream,AI.ML.NeuralNetwork.CoreNNW.NNValue@)">
            <summary>
            Reads NNValue from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValues(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NNValue array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValues(AI.DataStructs.InMemoryDataStream,AI.ML.NeuralNetwork.CoreNNW.NNValue[]@)">
            <summary>
            Reads NNValue array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVector(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex vector from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVector(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexVector@)">
            <summary>
            Reads complex vector from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVectors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex vector array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVectors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexVector[]@)">
            <summary>
            Reads complex vector array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrix(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex matrix from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrix(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexMatrix@)">
            <summary>
            Reads complex matrix from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrices(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex matrix array from the stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrices(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexMatrix[]@)">
            <summary>
            Reads complex matrix array from the stream
            </summary>
            <param name="stream"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.ShuffleExtensions">
            <summary>
            Extensions for collections shuffling
            </summary>
        </member>
        <member name="M:AI.Extensions.ShuffleExtensions.Shuffle``1(``0[],System.Nullable{System.Int32})">
            <summary>
            Shuffle an array using the Knuth method
            </summary>
            <param name="data">Array</param>
            <param name="seed">Random number generator seed</param>
        </member>
        <member name="M:AI.Extensions.ShuffleExtensions.Shuffle``1(System.Collections.Generic.IList{``0},System.Nullable{System.Int32})">
            <summary>
            Shuffle a list using the Knuth method
            </summary>
            <param name="data">List</param>
            <param name="seed">Random number generator seed</param>
        </member>
        <member name="T:AI.Functions">
            <summary>
            Математические фукции
            </summary>
        </member>
        <member name="M:AI.Functions.WindowFunc(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.WindowFuncDouble(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Double},System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.WindowFuncDouble(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Double},System.Int32,System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <param name="stride">step</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.NextPow2(System.Int32)">
            <summary>
            Следующая степень числа 2
            </summary>
            <param name="n">входное число</param>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Summ(System.Double[])">
            <summary>
            Суммирование всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(System.Single[])">
            <summary>
            Суммирование всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Поэлементная сумма
            </summary>
            <param name="vectors">Массив векторов</param>
            <returns>Результирующий вектор</returns>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Суммирование всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(System.Int32[])">
            <summary>
            Суммирование всех элементов массива типа int
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Суммирование всех элементов комплексного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.IntegralInterp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            Входной вектор апроксиммирован полиномом 0-го порядка
            с коэфициентом 2
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Integral(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Integral(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            </summary>
            <param name="A">Входной вектор</param>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор
            </summary>
            <param name="A"> Входной вектор</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор
            </summary>
            <param name="A"> Входной вектор</param>   
            <param name="fd"> Sampling frequency</param>
        </member>
        <member name="M:AI.Functions.DiffWithOutF(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор (без первого отсчета)
            </summary>
            <param name="A"> Входной вектор</param>
            <param name="fd"> Sampling frequency</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Вычисляет i-ю производную по dx
            </summary>
            <param name="A">Входной вектор</param>
            <param name="i">Порядок производной 1, 2, 3 ....</param>
            <returns>Действительный вектор</returns>
        </member>
        <member name="M:AI.Functions.Multiplication(System.Double[])">
            <summary>
            Перемножение всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Multiplication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перемножение всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.MultiplicationFunction(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перемножение всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.PowFunction(System.Double,System.Int32)">
            <summary>
            Возвращает набор степеней данного числа
            </summary>
            <param name="inp">Число</param>
            <param name="pow">максимальная степень</param>
        </member>
        <member name="M:AI.Functions.Multiplication(System.Int32[])">
            <summary>
            Перемножение всех элементов массива типа int
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FLV">
            <summary>
            Fuzzy Logic Variable(FLV)
            </summary>
        </member>
        <member name="P:AI.Fuzzy.FLV.Flv">
            <summary>
            Нечеткая логическая переменная
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.#ctor">
            <summary>
            Конструктор по умолчанию
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Double)~AI.Fuzzy.FLV">
            <summary>
            Инициализация double
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Single)~AI.Fuzzy.FLV">
            <summary>
            Инициализация float
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Int32)~AI.Fuzzy.FLV">
            <summary>
            Инициализация int
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(AI.Fuzzy.FLV)~System.Double">
            <summary>
            Инициализация double
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.#ctor(System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="flv">численное значение нечеткой переменной</param>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_LogicalNot(AI.Fuzzy.FLV)">
            Не 
        </member>
        <member name="M:AI.Fuzzy.FLV.op_BitwiseAnd(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            И
        </member>
        <member name="M:AI.Fuzzy.FLV.op_BitwiseOr(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Или
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.KDImplication(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Импликация Клини
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.GImplication(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Импликация Гогена
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzyAnalogyInference">
            <summary>
            Нечеткий вывод по аналогии
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrixG(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Матрица импликаций с применение импликации Гогена
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrixG(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Усредненная матрица импликаций с применение импликации Гогена
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrix(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Matrix},AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Усредненная матрица импликаций, обучение с подкреплением
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.Inference(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Логический вывод
            </summary>
            <param name="matrix">Матрица импликаций</param>
            <param name="ifVector">Вектор условия</param>
        </member>
        <member name="T:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector">
            <summary>
            Интерфейс векторного фаззификатора
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector.Fuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Фаззификация
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector.DeFuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дефаззификация
            </summary>
            <param name="valueF">Нечеткое значение</param>
        </member>
        <member name="T:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator">
            <summary>
            Векторный фаззификатор на базе сигмоиды
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.#ctor(System.Double)">
            <summary>
            Векторный фаззификатор на базе сигмоиды
            </summary>
            <param name="beta">Наклон</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.DeFuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дефаззификация
            </summary>
            <param name="valueF">Нечеткое значение</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.Fuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Фаззификация
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="T:AI.HightLevelFunctions.ActivationFunctions">
            <summary>
            Функции активации нейронов
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Softmax(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Softmax
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная ф-я
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(System.Double,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная ф-я
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.InverseSigmoid(System.Double,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная ф-я
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.InverseSigmoid(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная ф-я
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.SigmoidBiplyar(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная биполярная активационная ф-я
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Пороговая активационная ф-я
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="threshold">Порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Ограничение сверху и снизу
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="thresholdUp"></param>
            <param name="thresholdDoun"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Релу
            </summary>
            <param name="Inp"></param>
            <param name="threshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Input</param>
            <param name="thresholdUp">Верхний порог</param>
            <param name="thresholdDoun">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="inp">Input</param>
            <param name="thresholdUp">Верхний порог</param>
            <param name="thresholdDoun">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="Inp"></param>
            <param name="betta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.SigmoidBiplyar(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="Inp"></param>
            <param name="betta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="inp"></param>
            <param name="threshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="tensor">Input data tensor</param>
            <param name="betta">Коэфициент наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Log10(AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Логарифм по основанию 10
            </summary>
            <param name="tensor">Input data tensor</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Input</param>
            <param name="threshold">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector[],System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Input</param>
            <param name="threshold">Нижний порог</param>
        </member>
        <member name="T:AI.HightLevelFunctions.AnalyticGeometryFunctions">
            <summary>
            Analytic geometry
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.Cos(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Cosine of the angle between two vectors
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.NormVect(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculates the Euclidean norm of a vector
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.Dot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Dot product of 2 vectors
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.ProectionAtoB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Projection of vector A onto vector B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.AngleVect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Angle between vectors
            </summary>
            <returns>Returns the angle in radians</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.VectorFromAToB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculates the vector connecting point A to point B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.DistanceFromAToB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculates the distance from point A to B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.VectorRotate(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            Rotate a vector by specified angles
            </summary>
        </member>
        <member name="T:AI.HightLevelFunctions.DistributionFunctions">
            <summary>
            Функции распределения случайной величины
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Функция распределения по нормальному закону 
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">СКО</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Ф-я Гаусса
            </summary>
            <param name="inp"></param>
            <param name="m"></param>
            <param name="std"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussRect(System.Int32,System.Int32,System.Double)">
            <summary>
            Фильтр гаусса
            </summary>
            <param name="h">Высота фильтра</param>
            <param name="w">Ширина</param>
            <param name="std">СКО</param>
            <returns>Фильтр Гаусса</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(System.Double,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности
            </summary>
            <param name="Inp">Входное значение</param>
            <param name="m">Мат. ожидание</param>
            <param name="sko">СКО</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss1(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Функция Гаусса при x=m -> G(x) = 1
            </summary>
            <param name="inp"></param>
            <param name="m"></param>
            <param name="sko"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussNorm1(System.Double,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности при inp = m, out = 1
            </summary>
            <param name="Inp">Входное значение</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">СКО</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussNorm1(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности при inp = m, out = 1
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">СКО</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Puasson(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Функция распределения Пуасона 
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="m">Мат. ожидание от 0 до +inf</param>
        </member>
        <member name="T:AI.HightLevelFunctions.FunctionsForEachElements">
            <summary>
            Математические функции для векторов и матриц
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Unwrap(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Разворачивание арктангенса
            </summary>
            <param name="data">Данные с ф-ии atan</param>
            <param name="diffMax">Максимальный разрыв</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Pow(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возведение числа в вектор степеней
            </summary>
            <param name="a">Число</param>
            <param name="pow">Вектор степеней</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.PeakDel(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Устранение выбросов на одном отсчете сигнала(пиков)
            </summary>
            <param name="data">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.MinusOnePow(System.Int32)">
            <summary>
            Возведение -1 в степень
            </summary>
            <param name="pow">Степень</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Rad(System.Double,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Параметр</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Rad(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Вектор параметров</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Walsh(System.Double,System.Int32)">
            <summary>
            Функции Уолша
            </summary>
            <param name="x">Параметр</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Walsh(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Вектор параметров</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Erf(System.Double)">
            <summary>
            Loss function
            </summary>
            <param name="x">Аргумент</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Erf(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Функция ошибок
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GenerateTheSequence(System.Double,System.Double,System.Double)">
            <summary>
            Генерирование последовательности
            </summary>
            <param name="began">Начальное значение</param>
            <param name="step">Шаг</param>
            <param name="end">Конечное значение</param>
            <returns>Возвращает последовательность</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GenerateTheSequence(System.Double,System.Double)">
            <summary>
            Генерирование последовательности
            </summary>
            <param name="began">Начальное значение</param>
            <param name="end">Конечное значение</param>
            <returns>Возвращает послеовательность с шагом 1</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GradToRad(System.Double)">
            <summary>
            Перевод градусов в радианы
            </summary>
            <param name="grad">значение в градусах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GradToRad(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перевод градусов в радианы
            </summary>
            <param name="Inp">значения в градусах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.RadToGrad(System.Double)">
            <summary>
            Перевод радиан в градусы
            </summary>
            <param name="rad">значение в радианах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.RadToGrad(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перевод радиан в градусы
            </summary>
            <param name="Inp">значение в радианах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Factorial(System.Int32)">
            <summary>
            Вычисление факториала числа
            </summary>
            <param name="x">Число</param>
            <returns>Факториал</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Factorial(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление факториала векторов поэлементно
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns>Факториал</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sin(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление синусов
            </summary>
            <param name="Inp">Angle vector (in radians)</param>
            <returns>Вектор синусов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Round(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Rounding
            </summary>
            <param name="Inp">Input data vector</param>
            <param name="digits">до какого знака</param>
            <returns>Output vector</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление косинусов
            </summary>
            <param name="Inp">Angle vector (in radians)</param>
            <returns>Вектор косинусов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tan(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculating tangents
            </summary>
            <param name="Inp">Angle vector (in radians)</param>
            <returns>Вектор тангенсов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.ctg(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление котангенсов
            </summary>
            <param name="Inp">Angle vector (in radians)</param>
            <returns>Вектор котангенсов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Asin(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арксинусов
            </summary>
            <param name="Inp">Вектор синусов</param>
            <returns>Angle vector (in radians)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Acos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арккосинусов
            </summary>
            <param name="Inp">Вектор косинусов</param>
            <returns>Angle vector (in radians)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Atan(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арктангенсов
            </summary>
            <param name="Inp">Вектор тангенсов</param>
            <returns>Angle vector (in radians)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Log10(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дсятичный логарифм
            </summary>
            <param name="Inp">Подлогарифмическое число</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ln(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Логарифм по основанию "e"
            </summary>
            <param name="Inp">Подлогарифмическое число</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sec(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Секанс угла
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cosec(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Косеканс угла
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Exp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Экспонента e^x
            </summary>
            <param name="Inp">показатели степени</param>
            <returns>e^Inp - поэлементно</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tanh(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Гиперболический тангенс
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sign(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Определение знака
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sqrt(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Квадратный корень
            </summary>
            <param name="Inp">числа</param>		
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sin(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Вычисление синуса
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Exp(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            e^x
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tanh(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Гиперболический тангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cos(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Косинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Тангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ctan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Котангенс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Asin(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арксинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Acos(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арккосинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Atan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арктангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Abs(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Модуль
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sqrt(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Квадратный корень
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Log10(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Десятичный логарифм
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ln(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Логарифм по основанию E
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sec(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Секонс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cosec(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Косеконс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Abs(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Модуль
            </summary>
            <param name="Inp">Комплексный вектор значений для преобразования</param>
        </member>
        <member name="T:AI.IntervalData">
            <summary>
            Данные интервалов
            </summary>
        </member>
        <member name="M:AI.IntervalData.#ctor">
            <summary>
            Данные интервалов
            </summary>
        </member>
        <member name="M:AI.IntervalData.Add(System.Int32,System.Int32)">
            <summary>
            Добавление интервала
            </summary>
            <param name="bI">Начало</param>
            <param name="eI">Конец</param>
        </member>
        <member name="M:AI.IntervalData.GetVects(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Нарезка вектора по интервалам
            </summary>
            <param name="inputVector">Input data vector</param>
        </member>
        <member name="M:AI.IntervalData.GetVect(System.Func{AI.DataStructs.Algebraic.Vector,System.Double},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Нарезка вектора по интервалам + преобразование
            </summary>
            <param name="vect2doub">Функция для преобразования вектора в число</param>
            <param name="input">Input data vector</param>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.CorrelationAnalysis">
            <summary>
            Correlation analysis (orthogonality check)
            </summary>
        </member>
        <member name="P:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.CorMatrNorm">
            <summary>
            Normalized correlation matrix
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.#ctor(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Correlation analysis
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.MeanOrtog">
            <summary>
            Average Orthogonality Coefficient
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.CorMatrDeterm">
            <summary>
            Determinant of the correlation matrix (one of the multicollinearity indicators)
            </summary>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.MetricsForClassification">
            <summary>
            Quality metrics for assessing classification
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.Accuracy(System.Int32[],System.Int32[])">
            <summary>
            Accuracy
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.PrecisionForEachClass(System.Int32[],System.Int32[])">
            <summary>
            Algorithm precision value for each class
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.AveragePrecision(System.Int32[],System.Int32[])">
            <summary>
            Average precision across all classes
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.ConfusionMatrix(System.Int32[],System.Int32[])">
            <summary>
            Confusion matrix (confusion)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.Recall(System.Int32[],System.Int32[])">
            <summary>
            Recall
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.RecallForEachClass(System.Int32[],System.Int32[])">
            <summary>
            Algorithm recall value for each class
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.AverageRecall(System.Int32[],System.Int32[])">
            <summary>
            Average recall across all classes
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FMeasure(System.Int32[],System.Int32[])">
            <summary>
            F measure formula: 2 * recall * precision / (recall + precision)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FMeasure(System.Int32[],System.Int32[],System.Double)">
            <summary>
            F measure formula: (1+beta^2) * recall * precision / (recall + beta^2 * precision)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FullReport(System.Int32[],System.Int32[],System.Double,System.Boolean)">
            <summary>
            Complete classifier metrics report
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSLE(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            RMLE (target[i]>-1, output[i]>-1 for all i \in [0; N-1])
            </summary>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.SimilarityOfBases">
            <summary>
            Проверка схожести двух базисов
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.SimilarityOfBases.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Проверка схожести двух базисов
            </summary>
            <param name="bas1">Базис №1</param>
            <param name="bas2">Базис №2</param>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.SimilarityOfBases.ProbRandBasis">
            <summary>
            Вероятность что базисы не связаны (случайны)
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.BaseClassifier`1">
            <summary>
            Базовый классификатор
            </summary>
            <typeparam name="T">Тип классификатора</typeparam>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
            <param name="inp">Вход</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация (вероятности)
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Save(System.String)">
            <summary>
            Сохранить
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Save(System.IO.Stream)">
            <summary>
            Сохранить
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Load(System.String)">
            <summary>
            Загрузить
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Load(System.IO.Stream)">
            <summary>
            Загрузить 
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="T:AI.ML.Classifiers.CorrelationClassifier">
            <summary>
            Correlation classifier
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.CorrelationClassifier.Classes">
            <summary>
            Classes
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor">
            <summary>
            Correlation classifier
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor(System.String)">
            <summary>
            Correlation classifier
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
            Correlation classifier
            </summary>
            <param name="classifikator"> Classes</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Adding a class
            </summary>
            <param name="features">Feature vector</param>
            <param name="num">Label </param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recognizing a vector
            </summary>
            <param name="inp">Input</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recognizing a vector, the result is a vector of probabilities
            </summary>
            <param name="inp">Input vector</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Training a classifier
            </summary>
            <param name="features">Features</param>
            <param name="classes">Labels</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Training a classifier based on the vector-label dataset
            </summary>
            <param name="dataset">Vector-label dataset</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Save(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Save(System.IO.Stream)">
            <summary>
            Save to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Load(System.String)">
            <summary>
            Load from file
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Load(System.IO.Stream)">
            <summary>
            Load from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.FuzzyClassifier">
            <summary>
            Нечеткий классификатор
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.FuzzyficatorVectorInp">
            <summary>
            Фаззификатор входов
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.FuzzyficatorVectorOutp">
            <summary>
            Фаззификатор выходов
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.ImplMatrix">
            <summary>
            Матрица импликаций
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
            <param name="inp">Вход</param>
            <returns>Метка класса</returns>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
            <param name="inp">Вход</param>
            <returns>Вектор принадлежностей</returns>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="T:AI.ML.Classifiers.IClassifier">
            <summary>
            Интерфейс для работы классификаторов
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание
            </summary>
            <param name="inp">Вектор который надо распознать</param>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание
            </summary>
            <param name="inp">Вектор который надо распознать</param>
        </member>
        <member name="T:AI.ML.Classifiers.KNNCl">
            <summary>
            Classifier (k-nearest neighbors method)
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.K">
            <summary>
            Number of neighbors
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.H">
            <summary>
            Window width
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.IsFixed">
            <summary>
            Is the width fixed
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.IsParsenMethod">
            <summary>
            Is the Parzen window in use
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.KernelParsenWindow">
            <summary>
            Parzen window Kernel
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.Dist">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.Classes">
            <summary>
            Dataset
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor">
            <summary>
            Classifier (Method of k-nearest neighbors)
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Classifier (Method of k-nearest neighbors)
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.RbfK(System.Double)">
            <summary>
            Radial basis kernel for the Parzen window
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
            Classifier (Method of k-nearest neighbors)
            </summary>
            <param name="classifikator">Collection of classes</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recognition
            </summary>
            <param name="inp">Input vector</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Adding a class
            </summary>
            <param name="features">Feature vector</param>
            <param name="num">Label </param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recognizing a vector, the result is a vector of probabilities
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.RecognizeVectorMax(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Returns a vector, its length is the number of classes, the number of the required class is 1
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Training a classifier
            </summary>
            <param name="features">Features</param>
            <param name="classes">Labels</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Training a classifier based on the vector-label dataset
            </summary>
            <param name="dataset">Vector-label dataset</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Save(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Save(System.IO.Stream)">
            <summary>
            Save to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Load(System.String)">
            <summary>
            Load from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Load(System.IO.Stream)">
            <summary>
            Load from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.GetKNN(System.String)">
            <summary>
            Loading from csv file (features; class label)
            </summary>
            <param name="pathToEtallonClassCsv">File path</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.ToVector(System.Int32)">
            <summary>
            Transform to vector
            </summary>
            <param name="i">Index</param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNW)">
            <summary>
            
            </summary>
            <param name="net"></param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Classify
            </summary>
            <param name="inp">Input vector</param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Classify
            </summary>
            <param name="inp">Input vector</param>
        </member>
        <member name="T:AI.ML.Classifiers.NN">
            <summary>
            Classifier (method of standards)
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NN.Classes">
            <summary>
            Classes
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor">
            <summary>
             Classifier (method of standards)
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor(System.String)">
            <summary>
             Classifier (method of standards)
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
             Classifier (method of standards)
            </summary>
            <param name="classifikator"> Classes</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.AddClass(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Adding a standard to the classifier
            </summary>
            <param name="tDataset">Dataset</param>
            <param name="numClass">Index класса</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Recognizing a vector
            </summary>
            <param name="inp">Input</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Adding a class
            </summary>
            <param name="features">Feature vector</param>
            <param name="num">Label </param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Returns a vector, the length of which is equal to the number of classes, the value at the index of the required class is set to one, and at other indices to zero.
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Training a classifier
            </summary>
            <param name="features">Features</param>
            <param name="classes">Labels</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Training a classifier based on the vector-label dataset
            </summary>
            <param name="dataset">Vector-label dataset</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Save(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Save(System.IO.Stream)">
            <summary>
            Save to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Load(System.String)">
            <summary>
            Load from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Load(System.IO.Stream)">
            <summary>
            Load from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.StructClasses">
            <summary>
            Структура классификатора
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Save(System.String)">
            <summary>
            Save to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Save(System.IO.Stream)">
            <summary>
            Save to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Load(System.String)">
            <summary>
            Load from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Load(System.IO.Stream)">
            <summary>
            Load from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Clustering.Cluster">
            <summary>
            Cluster structure
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Cluster.Dataset">
            <summary>
            Dataset
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Cluster.Centr">
            <summary>
            Cluster center
            </summary>
        </member>
        <member name="T:AI.ML.Clustering.Forel">
            <summary>
            FOREL clustering
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Forel.Clusters">
            <summary>
            Clusters array
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Forel.DistanceFunction">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.#ctor">
            <summary>
            FOREL clustering
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Clustering training
            </summary>
            <param name="dataset">Vectors</param>
            <param name="minR">Minimum cluster radius</param>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Classify vector
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>Classify vectors</summary>
            <param name="vectors">Vectors</param>
        </member>
        <member name="M:AI.ML.Clustering.Forel.GetHypersphere(System.Double,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Проводит гиперсферу нужного радиуса из конкретной точки и на заданном множестве
            </summary>
            <param name="R">Радиус</param>
            <param name="m">Центр масс</param>
            <param name="pointsSet">Множество точек</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Max(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Максимальная дистанция
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.Forel.AWithOutB(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Множество А\В
            </summary>
            <param name="A">Множество А</param>
            <param name="B">Множество В</param>
            <returns>А\B</returns>
        </member>
        <member name="T:AI.ML.Clustering.IClustering">
            <summary>
            Interface for metric clustering algorithms
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Classify vector
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Classify vectors
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Clustering training
            </summary>
            <param name="dataset">Vectors</param>
            <param name="param">Free parametr</param>
        </member>
        <member name="P:AI.ML.Clustering.IClustering.DistanceFunction">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.IClustering.Clusters">
            <summary>
            Clusters array
            </summary>
        </member>
        <member name="T:AI.ML.Clustering.KMeans">
            <summary>Алгоритм k-means</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Centroids">
            <summary>
            Центроиды
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.MaxCount">
            <summary>
            Максимальное число циклов
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.#ctor(System.Int32)">
            <summary>K-Mean</summary>
            <param name="clasterCount">Количество кластеров</param>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.GroupCount">
            <summary>Количество кластеров</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.DimentionOfData">
            <summary>Размерность данных</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Сentroids">
            <summary>Цендроиды кластеров</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.DistanceFunction">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Clusters">
            <summary>
            Clusters array
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>Classify vector</summary>
            <param name="vector">Vector</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>Classify vectors</summary>
            <param name="vectors">Vectors</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Clustering training
            </summary>
            <param name="dataset">Vectors</param>
            <param name="seed">Seed</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Initialize">
            <summary>Инизиализация</summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.NearestVector(AI.DataStructs.Algebraic.Vector)">
            <summary>Ближайший вектор</summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.ValidateData(System.Int32,AI.DataStructs.Algebraic.Vector[])">
            <summary>Validate the sample</summary>
        </member>
        <member name="T:AI.ML.Clustering.KohonenNet">
            <summary>
            Kohonen self-organizing map
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KohonenNet.Steps">
            <summary>
            Neural network setup steps
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KohonenNet.Clusters">
            <summary>
            Clusters array
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Kohonen self-organizing map
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>Classify vector</summary>
            <param name="vector">Vector</param>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>Classify vectors</summary>
            <param name="vectors">Vectors</param>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.ClassifyAndTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            
            </summary>
            <param name="vect"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Train kohonen network
            </summary>
            <param name="datasetInp"></param>
            <param name="param"></param>
        </member>
        <member name="T:AI.ML.CrossCorrMatrix">
            <summary>
            Cross-correlation matrix
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.Base.Many2ManyVectorClassifier">
            <summary>
            Sequence for training a recurrent network on a many-to-many basis
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Base.Many2ManyVectorClassifier.Labels">
            <summary>
            Class labels
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Base.Many2ManyVectorClassifier.Features">
            <summary>
            Features
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.#ctor">
            <summary>
            Sequence for training a recurrent network on a many-to-many basis
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure})">
            <summary>
            Sequence for training a recurrent network on a many-to-many basis
            </summary>
            <param name="labels">Class labels</param>
            <param name="features"></param>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.GetDataset(System.Collections.Generic.IEnumerable{AI.ML.DataSets.Base.Many2ManyVectorClassifier},System.Boolean)">
            <summary>
            Getting a dataset, for use with a neural network manager
            </summary>
            <param name="data">Dataset</param>
            <param name="doShuffling">Whether it is necessary to shuffle the data in random order</param>
        </member>
        <member name="T:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset">
            <summary>
            Dataset containing an array of sequences for training recurrent neural networks
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetLabels">
            <summary>
            The method returns an array of lists(an array of sequences) of class labels
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetFeatures">
            <summary>
            The method returns an array of lists(an array of sequences) of feature vectors
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetVectorLabels(System.Int32)">
            <summary>
            The method returns an array of lists(an array of sequences) of class labels in vector representation
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.ShufflingDataset">
            <summary>
            Uniform shuffling
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.ExtensionOfFeatureSpace">
            <summary>
            Расширение пространства признаков
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Polinomial(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков полиномиальной ф-ей
            </summary>
            <param name="x">Input</param>
            <param name="n">степень полинома</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Polinomial(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Раширение пространства признаков полиномиальной ф-ей
            </summary>
            <param name="inp">Input</param>
            <param name="n">степень полинома</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Cos(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков косинусами
            </summary>
            <param name="x">Input</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Sin(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков синусами 
            </summary>
            <param name="x">Input</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.SinCos(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков синусами и косинусами
            </summary>
            <param name="x">Input</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Cos(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Раширение пространства признаков косинусами
            </summary>
            <param name="inp">Input</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.PoliCos(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Расширение пространства с помощью полиномиальных ф-й и потом косинусов
            </summary>
            <param name="x">Input</param>
            <param name="nPolinom">Степень полинома</param>
            <param name="nCos">Кол-во косинусов</param>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.PoliCos(System.Double,System.Int32,System.Int32)">
            <summary>
            Расширение пространства с помощью полиномиальных ф-й и потом косинусов
            </summary>
            <param name="x">Input</param>
            <param name="nPolinom">Степень полинома</param>
            <param name="nCos">Кол-во косинусов</param>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.GaussRBF(System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Радиально-базисная ф-я Гаусса
            </summary>
            <param name="x">Input</param>
            <param name="centers">Массив центров</param>
            <param name="std">СКО</param>
            <returns>Вектор значений от 0 до 1</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Sinc(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синус Котельникова sin(x)/x
            </summary>
            <param name="x"></param>
            <param name="centers"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixInt">
            <summary>
            Датасет с картинками матрица-нормер класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixInt.GetRandMatrixIntSemple">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixIntSample">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.MatrixIntSample.Matrix">
            <summary>
            Матрица
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.MatrixIntSample.ClassNum">
            <summary>
            Номер класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixIntSample.#ctor">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixIntSample.#ctor(AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
            <param name="matr">Матрица</param>
            <param name="numClass">Номер класса</param>
        </member>
        <member name="T:AI.ML.DataSets.MatrixVector">
            <summary>
            Коллекция(датасет) матрица-вектор
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixVector.MatrixVectorSempleRand">
            <summary>
            random instance
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixVectorSample">
            <summary>
            Матрица-вектор
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.MatrixVectorSample.matrix">
            <summary>
            Матрица
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.MatrixVectorSample.vector">
            <summary>
            Вектор
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixVectorSample.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Матрица-вектор
            </summary>
            <param name="matr">Матрица</param>
            <param name="vect">Вектор</param>
        </member>
        <member name="T:AI.ML.DataSets.Synthetic.PointClouds">
            <summary>
            Point clouds synthesis
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Synthetic.PointClouds.Dimention">
            <summary>
            Dimention
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.#ctor(System.Int32)">
            <summary>
            Point cloud synthesis
            </summary>
            <param name="dim">Dimention</param>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.AddCloud(System.Int32,AI.DataStructs.Algebraic.Vector,AI.ML.DataSets.Synthetic.PointClouds.CloudType,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Add point cloud
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.GetArray">
            <summary>
            Output as an array
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.Synthetic.PointClouds.CloudType">
            <summary>
            Point cloud type
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.Synthetic.PointClouds.CloudType.Hypersphere">
            <summary>
            Hypersphere
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.Synthetic.PointClouds.CloudType.Hypercube">
            <summary>
            Hypercube 
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.VectorClass">
            <summary>
            Представляет структуру вектор-класс
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorClass.Features">
            <summary>
            Вектор для классификации
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorClass.ClassMark">
            <summary>
            Метка класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorClass.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Представляет структуру вектор-класс
            </summary>
            <param name="vector">Вектор</param>
            <param name="mark">Метка класса</param>
        </member>
        <member name="T:AI.ML.DataSets.VectorIntDataset">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorIntDataset.mean">
            <summary>
            Средний вектор
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorIntDataset.disp">
            <summary>
            Дисперсия по выборке
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor(System.String)">
            <summary>
            Загрузка датасета из файла
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor(System.Int32)">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetRandomData">
            <summary>
            Случайный представитель датасета
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CorrMatrFeatures">
            <summary>
            Корреляционная матрица признаков
            </summary>
            <returns>Нормированная кор. матрица</returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.DispMeanResult">
            <summary>
            Получение вектора дисперсии и среднего вектора
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.Normalise">
            <summary>
            Нормализация датасета
            </summary>
            <returns>Датасет</returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetDatasetDelSim(System.Double)">
            <summary>
            Удаление похожих векторов из разных классов
            </summary>
            <param name="simCoef">Коэффициент схожести</param>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CsvToVid(System.String,System.Char)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CsvToVid(System.String,System.Int32,System.Char)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.Save(System.String,System.Char)">
            <summary>
            Сохранение датасета
            </summary>
        </member>
        <member name="T:AI.ML.Distances.BaseDist">
            <summary>
            Basic distance functions
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.LpDist(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure,System.Int32)">
            <summary>
            Lp family distances
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.EuclideanDistance(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Euclidean distance
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.LinfDist(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Distance L-infinity
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.Cos(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Cosine similarity
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.CosDist(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Cosine distance
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.SquareEucl(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Square of Euclidean distance
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.ManhattanDistance(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Square of Euclidean distance
            </summary>
        </member>
        <member name="T:AI.ML.Distances.DistancesBetweenDistributions">
            <summary>
            Distances between distributions
            </summary>
        </member>
        <member name="T:AI.ML.Distances.DistancesIntoAccountDistributions">
            <summary>
            Distances between points taking into account distributions, or distances from a point to a distribution.
            </summary>
        </member>
        <member name="T:AI.ML.Distances.ProbabilityDistances">
            <summary>
            Probability (entropy) distances
            </summary>
        </member>
        <member name="M:AI.ML.Distances.ProbabilityDistances.DKL(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Kullback–Leibler divergence
            </summary>
        </member>
        <member name="M:AI.ML.Distances.ProbabilityDistances.DKLSymmetrical(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Symmetrical Kullback - Leibler divergence
            </summary>
        </member>
        <member name="T:AI.ML.Genetic.GeneticCore.Cell">
            <summary>
            Клетка
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Score">
            <summary>
            Набранные очки
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Parametrs">
            <summary>
            Параметры (хромосомы)
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Function">
            <summary>
            Полезная функция
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Cell.#ctor(System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},System.Random,System.Double,System.Double)">
            <summary>
            Клетка
            </summary>
            <param name="parametrsCount">Number of parameters</param>
            <param name="function">Функция</param>
            <param name="rnd">Pseudo-random number generator</param>
            <param name="valDown">Нижняя граница распределения</param>
            <param name="valUp">Верхняя граница распределения</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Cell.Output(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Выход модели
            </summary>
            <param name="inpVector">Входной вектор</param>
        </member>
        <member name="T:AI.ML.Genetic.GeneticCore.Population">
            <summary>
            Cell population
            </summary>
        </member>
        <member name="F:AI.ML.Genetic.GeneticCore.Population.mutProb">
            <summary>
            Mutation probability
            </summary>
        </member>
        <member name="F:AI.ML.Genetic.GeneticCore.Population.k">
            <summary>
            Crossover point
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.LiderCount">
            <summary>
            Number of leaders to breed
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.MutationValue">
            <summary>
            Mutation value
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.DValueUp">
            <summary>
            Search upper bound
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.DValueDown">
            <summary>
            Search lower bound
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.#ctor(System.Int32,System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],System.Double,System.Double)">
            <summary>
            Population
            </summary>
            <param name="countCell">Number of cells</param>
            <param name="countParam">Number of parameters</param>
            <param name="function">Utility function</param>
            <param name="inp">Input vectors</param>
            <param name="outp">Output vectors</param>
            <param name="valDown">Search lower bound</param>
            <param name="valUp">Search upper bound</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.#ctor(System.Int32,System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Population
            </summary>
            <param name="countCell">Number of cells</param>
            <param name="countParam">Number of parameters</param>
            <param name="function">Utility function</param>
            <param name="inp">Input data vector</param>
            <param name="outp">Output vector</param>
            <param name="valDown">Search lower bound</param>
            <param name="valUp">Search upper bound</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.CellOut(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
             Passing a function from one variable
            </summary>
            <param name="inp">Vector of inputs</param>
            <param name="indCell">Cell number</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Epoch(System.Int32)">
            <summary>
            Epoch of cells
            </summary>
            <param name="count">Number of children</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Score(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Points for one example
            </summary>
            <param name="outp">Model output</param>
            <param name="targ">Target value</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.SortCells">
            <summary>
            Sotrting
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Mutation(AI.ML.Genetic.GeneticCore.Cell)">
            <summary>
            Cell mutation
            </summary>
            <param name="input">Original cell</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Cross(AI.ML.Genetic.GeneticCore.Cell,AI.ML.Genetic.GeneticCore.Cell)">
            <summary>
            Cell crossing
            </summary>
            <param name="par1">First parent</param>
            <param name="par2">Second parent</param>
        </member>
        <member name="T:AI.ML.GradientDecentDataset">
            <summary>
            Класс для хранения обучающей выборки для градиентного спуска
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecentDataset.X">
            <summary>
            Набор векторов "Х"
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecentDataset.Y">
            <summary>
            Набор векторов "Y"
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.#ctor">
            <summary>
            Создает экземпляр GradientDecentDataset
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.#ctor(System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Создает экземпляр GradientDecentDataset
            </summary>
            <param name="xVector">Набор векторов "Х"</param>
            <param name="yVector">Набор векторов "Y"</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">Вектор х</param>
            <param name="y">Вектор у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(System.Double,System.Double)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">переменная х</param>
            <param name="y">переменная у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">Вектор х</param>
            <param name="y">Переменная у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Clear">
            <summary>
            Очистка данных
            </summary>
        </member>
        <member name="T:AI.ML.GradientDecent">
            <summary>
            Градиентный спуск
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Step">
            <summary>
            Шаг для вычисления частных производных и градиента
            (чем он меньше, тем точнее вычисление частных производных)
            по умолчанию step 1e-7
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.GdDataset">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Parammetrs">
            <summary>
            Вектор оптимизируемых парамметров
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Function">
            <summary>
            Целевая функция типа:
            double SF(Vector_парамметры, ListVector_обучающая_выборка_Х, ListVector_обучающая_выборка_Y)
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Norm">
            <summary>
            Норма обучения, по умолчанию 0.002
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Itterations">
            <summary>
            Кол-во иттераций, по умолчанию 30
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.#ctor(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Double},AI.ML.GradientDecentDataset)">
            <summary>
            Создание объекта Градиентный спуск
            </summary>
            <param name="param">Вектор оптимизируемых парамметров</param>
            <param name="function">Целевая функция типа:
            double SF(Vector_парамметры, ListVector_обучающая_выборка_Х, ListVector_обучающая_выборка_Y)</param>
            <param name="gdd">Обучающая выборка</param>
        </member>
        <member name="M:AI.ML.GradientDecent.DecentIter">
            <summary>
            Одна иттерация спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.Decent">
            <summary>
            Синхронное выполнение градиентного спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.AsyncDecent">
            <summary>
            Асинхронное выполнение градиентного спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.PartialDerivatives(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Func{AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Double})">
            <summary>
            Частные производные
            </summary>
            <param name="param">Начальный вектор параметров(точка)</param>
            <param name="function">Целевая функция(принимает вектор параметров, выдает результирующее значение)</param>
             <param name="inp"> Вектора входа</param>
              <param name="ideal"> Ideal outputs</param>
            <returns>Возвращает вектор частных производных</returns>
        </member>
        <member name="T:AI.ML.HMM.HMM">
            <summary>
            Basic block for constructing hidden Markov models, Markov chain
            </summary>
        </member>
        <member name="F:AI.ML.HMM.HMM.stateMatrix">
            <summary>
            State Matrix
            </summary>
        </member>
        <member name="F:AI.ML.HMM.HMM.stateAlter">
            <summary>
            Inverted state matrix
            </summary>
        </member>
        <member name="M:AI.ML.HMM.HMM.#ctor">
            <summary>
            Markov chain
            </summary>
        </member>
        <member name="M:AI.ML.HMM.HMM.Train(System.Int32[])">
            <summary>
            Train
            </summary>
            <param name="trainSeq">Training sequence</param>
        </member>
        <member name="M:AI.ML.HMM.HMM.GetMax(System.Double[0:,0:])">
            <summary>
            Maximum transition probability
            </summary>
            <param name="matrix">State Matrix</param>
        </member>
        <member name="M:AI.ML.HMM.HMM.Generate(System.Int32,System.Int32)">
            <summary>
            Generating text
            </summary>
            <param name="num">Steps count</param>
            <param name="begin">The first word</param>
        </member>
        <member name="T:AI.ML.HMM.MChWords">
            <summary>
            Markov chain
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MChWords.stateMatrix">
            <summary>
            State Matrix
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MChWords.stateAlter">
            <summary>
            Inverted state matrix
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MChWords.#ctor">
            <summary>
            Markov chain
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MChWords.Train(System.String)">
            <summary>
            Train
            </summary>
            <param name="TrainText">Training text</param>
        </member>
        <member name="M:AI.ML.HMM.MChWords.GetMax(System.Double[0:,0:])">
            <summary>
            Maximum transition probability
            </summary>
            <param name="matrix">State Matrix</param>
        </member>
        <member name="M:AI.ML.HMM.MChWords.Generate(System.Int32,System.String)">
            <summary>
            Generating text
            </summary>
            <param name="num">How many words</param>
            <param name="begin">The first word</param>
        </member>
        <member name="T:AI.ML.HMM.KMeanHMM">
            <summary>
            Hidden Markov model with state extraction based on the k-means algorithm
            </summary>
        </member>
        <member name="P:AI.ML.HMM.KMeanHMM.KMean">
            <summary>
            Extractor based on the k-means algorithm
            </summary>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.#ctor(System.Int32)">
            <summary>
            Hidden Markov model with state extraction based on the k-means algorithm
            </summary>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.GetTransitionMatrix(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Obtaining a matrix of probabilities of transitions between states
            </summary>
            <param name="seq">sequence of vectors</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.GetTransitionVector(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Obtaining a vector of probabilities of transitions between states
            </summary>
            <param name="seq">Sequence of vectors</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.Train(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Model training
            </summary>
            <param name="seqInp">Sequence of vectors</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.TrainHMM(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Only Markov chein train
            </summary>
            <param name="seqInp">Sequence of vectors</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.Generate(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Generating a sequence of states
            </summary>
            <param name="start">Start vector</param>
            <param name="len">Sequence length</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit">
            <summary>
            Activation function в виде модуля
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit">
            <summary>
            Activation function EliotSig
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit">
            <summary>
            Радиально-базисная активационная ф-я
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation">
            <summary>
            Интерфейс актив. функций
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Numerator">
            <summary>
            Initializer numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit">
            <summary>
            Линейная активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.#ctor">
            <summary>
            Линейная активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Forward(System.Single)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU">
            <summary>
            Активационная ф-я PLU (двусторонний ограничитель)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.#ctor">
            <summary>
            Активационная ф-я PLU (двусторонний ограничитель)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.#ctor(System.Single,System.Single)">
            <summary>
            Активационная ф-я PLU (двусторонний ограничитель)
            </summary>
            <param name="slope">Наклон за линейным участком</param>
            <param name="max">Максимальное значение линейного участка</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU">
            <summary>
            Активация ReLU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor">
            <summary>
            Активация ReLU
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor(System.Single)">
            <summary>
            Активация ReLU
            </summary>
            <param name="slope">Наклон при x меньше 0 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor(System.Double)">
            <summary>
            Активация ReLU
            </summary>
            <param name="slope">Наклон при x меньше 0 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.ToString">
            <summary>
            Имя актив ф.-ии
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit">
            <summary>
            Сигмоидальная Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.#ctor">
            <summary>
            Сигмоидальная Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.ToString">
            <summary>
            Имя функции
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.#ctor">
            <summary>
            Сигмоидальная Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.ToString">
            <summary>
            Имя функции
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit">
            <summary>
            Синусоидальная активационная фукция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.#ctor">
            <summary>
            Синусоидальная активационная фукция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit">
            <summary>
            Софтмакс активация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.ToString">
            <summary>
            Имя функции активации
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit">
            <summary>
            SQN Активация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit">
            <summary>
            Радиально-базискная ф-я активации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit">
            <summary>
            Activation function hyperbolic tangent
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Numerator">
            <summary>
            Random number generator setting numerator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Forward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Bakward pass
            </summary>
            <param name="x">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.ToString">
            <summary>
            Activation function name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="loss">Loss function</param>
            <param name="valSplit">Fraction of the sample to be used for validation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="loss">Loss function</param>
            <param name="valSplit">Fraction of the sample to be used for validation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingSample(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationSample(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingSample(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingRange(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationRange(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingRange(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent)">
            <summary>
            Add all samples from the "anotherSet" to current
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Save(System.String)">
            <summary>
            Save dataset to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Save(System.IO.Stream)">
            <summary>
            Save dataset to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Load(System.String)">
            <summary>
            Load dataset from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Load(System.IO.Stream)">
            <summary>
            Load dataset from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent">
            <summary>
            Dataset for training recurrent neural networks
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Dataset for recurrent neural networks
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for recurrent neural networks
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="loss">Loss function</param>
            <param name="valSplit">Fraction of the sample to be used for validation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for recurrent neural networks
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="loss">Loss function</param>
            <param name="valSplit">Fraction of the sample to be used for validation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure})">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure})">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure})">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent)">
            <summary>
            Add all samples from the "anotherSet" to current
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Save(System.String)">
            <summary>
            Save dataset to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Save(System.IO.Stream)">
            <summary>
            Save dataset to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Load(System.String)">
            <summary>
            Load dataset from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Load(System.IO.Stream)">
            <summary>
            Load dataset from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="inputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="data"></param>
            <param name="loss"></param>
            <param name="valSplit"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for non-recurrent neural networks
            </summary>
            <param name="data"></param>
            <param name="loss"></param>
            <param name="valSplit"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingSample(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationSample(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingSample(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingRange(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddvalidationRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationRange(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingRange(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle)">
            <summary>
            Add all samples from the "anotherSet" to current
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Save(System.String)">
            <summary>
            Save dataset to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Save(System.IO.Stream)">
            <summary>
            Save dataset to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Load(System.String)">
            <summary>
            Load dataset from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Load(System.IO.Stream)">
            <summary>
            Load dataset from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet">
            <summary>
            Dataset for DSP tasks
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.#ctor(AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Dataset for DSP tasks
            </summary>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.#ctor(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Dataset for DSP tasks
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
            <param name="loss">Loss function</param>
            <param name="valSplit">Fraction of the sample to be used for validation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTrainingSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Adds one sample to the training subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddValidationSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Adds one sample to the validation subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTestingSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Adds one sample to the testing subset
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTrainingRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Adds sample range to the training subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddValidationRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Adds sample range to the validation subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTestingRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Adds sample range to the testing subset
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet)">
            <summary>
            Add all samples from the "anotherSet" to current
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Save(System.String)">
            <summary>
            Save dataset to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Save(System.IO.Stream)">
            <summary>
            Save dataset to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Load(System.String)">
            <summary>
            Load dataset from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Load(System.IO.Stream)">
            <summary>
            Load dataset from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence">
            <summary>
            Data sequence used in network training
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence.Steps">
            <summary>
            Sequence of steps
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence.#ctor(AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep[])">
            <summary>
            Data sequence
            </summary>
            <param name="steps">Array of steps</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet">
            <summary>
            Neural network training dataset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.InputShape">
            <summary>
            Input data dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.OutputShape">
            <summary>
            Output data dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.LossFunction">
            <summary>
            Loss function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.TrainingInternal">
            <summary>
            Training subset internal storage
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Training">
            <summary>
            Training subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.ValidationInternal">
            <summary>
            Validation subset internal storage
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Validation">
            <summary>
            Validation subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.HasValidationData">
            <summary>
            Tells if validation subset is present
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.TestingInternal">
            <summary>
            Testing subset internal storage
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Testing">
            <summary>
            Testing subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.HasTestingData">
            <summary>
            Tells if testing subset is present
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Initialize dataset with given input and output shape and loss
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep">
            <summary>
            Data step
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.Input">
            <summary>
            Input data tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.TargetOutput">
            <summary>
            Ideal output tensor
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Data step
            </summary>
            <param name="input">Input data tensor</param>
            <param name="targetOutput">Output data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(System.Double[],System.Double[])">
            <summary>
            Data step
            </summary>
            <param name="input">Input</param>
            <param name="targetOutput">Output</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Data step
            </summary>
            <param name="input">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(System.Double[])">
            <summary>
            Data step
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet">
            <summary>
            Dataset interface
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.InputShape">
            <summary>
            Input data dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.OutputShape">
            <summary>
            Output data dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.LossFunction">
            <summary>
            Loss function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Training">
            <summary>
            Training subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Validation">
            <summary>
            Validation subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.HasValidationData">
            <summary>
            Tells if validation subset is present
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Testing">
            <summary>
            Testing subset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.HasTestingData">
            <summary>
            Tells if testing subset is present
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.ReportType">
            <summary>
            Report type
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.TrainingEpoches">
            <summary>
            Total epoches that need to be passed
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.BatchSize">
            <summary>
            Batch size
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.LearningRate">
            <summary>
            Learning rate
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.Model">
            <summary>
            Neural network
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.Data">
            <summary>
            Training dataset
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.MinLoss">
            <summary>
            Minimal loss
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.GraphCPU">
            <summary>
            Graph of automatic differentiation for CPU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.IsBackward">
            <summary>
            Whether to calculate derivatives
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Backprop">
            <summary>
            Functions for which derivatives are calculated
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.#ctor">
            <summary>
            Graph of automatic differentiation for CPU
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.#ctor(System.Boolean)">
            <summary>
            Graph of automatic differentiation for CPU
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Backward">
            <summary>
            Backward pass (differentiation)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Restart(System.Boolean)">
            <summary>
            Restart
            </summary>
            <param name="isBacward">Is there a backward pass</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Copyist(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Copy tensor
            </summary>
            <param name="value">Tensor</param>
            <param name="count">Number of copies</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.ScalarProduct(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Dot product of two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.AddCicleBuff(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Adding an item
            </summary>
            <param name="old">Buffer old state</param>
            <param name="inp">Added element</param>
            <param name="len">Buffer capacity</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Vector concatenation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.DeConcatinateOne(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Cutting a vector into vectors by 1 element
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Concatenate two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Activate(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Activation function
            </summary>
            <param name="function">Function activation</param>
            <param name="t">The tensor to which it is applied</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Mul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Matrix multiplication
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.MulMV(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Matrix-vector multiplication
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Addition of two tensors
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Addition of three tensors
            </summary>
            <param name="t1">Tensor #1</param>
            <param name="t2">Tensor #2</param>
            <param name="t3">Tensor #3</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.OneMinus(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            1-m
            </summary>
            <param name="m">Input data tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Subtract(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Subtraction
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.MulMatrixByNumber(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single)">
            <summary>
            Multiplication by a number
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.MulMatrixByNumber(System.Single,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Multiplication by a number
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Invers(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Tensor inversion -m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.AdamarMul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adamar product of tensors
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convolution without bias
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convolution
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.MaxPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Max pooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Tensor shape transformation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.UnPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            UnPooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.Upsampling2DBicubic(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.AddN(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adding a tensor to a number
            </summary>
            <param name="tensor">Tensor</param>
            <param name="number">Number</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.DropOut(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single,System.Single,System.Random)">
            <summary>
            Dropout
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.DeepSplit(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Splitting a tensor into multiple tensors by depth
            </summary>
            <param name="data">Input tensor</param>
            <param name="countLayersInSlice">Number of layers in one slice</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.ImRealCross(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Mixing real and imaginary parts to create a new real and imaginary part
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.DeepJoin(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Tensor depth join
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.FeedForwardLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Feedforward layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.GRULayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit)">
            <summary>
            Gru layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.GraphCPU.FeedforwardLinLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Feedforward linear layer
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.INetwork">
            <summary>
            Interface of neural network
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.InputShape">
            <summary>
            Inputs shape
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.OutputShape">
            <summary>
            Outputs shape
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.TrainableParameters">
            <summary>
            Number of trainable parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.Layers">
            <summary>
            List of layers
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input data</param>
            <param name="g">Graph of automatic differentiation</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input data</param>
            <param name="g">Graph of automatic differentiation</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.ResetState">
            <summary>
            Reset state, must be in a recurrent neural network
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.GetParameters">
            <summary>
            Trainable parameters
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.AddNewLayer(AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Append a new layer to the network
            </summary>
            <param name="layer">New layer</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.AddNewLayer(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Append a new layer to the network
            </summary>
            <param name="inputShape">Input shape</param>
            <param name="layer">new layer</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer">
            <summary>
            Nonlinear layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.TrainableParameters">
            <summary>
            Number of training parameters (0)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.AddDenInSqrt">
            <summary>
            Adding under the root (0)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.#ctor(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Activation layer
            </summary>
            <param name="shapeInp">Input dimension</param>
            <param name="activation">Activation function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Activation layer
            </summary>
            <param name="activation">Activation function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass слоя
            </summary>
            <param name="input">Входной тензор</param>
            <param name="g">Graph of automatic differentiation</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate">
            <summary>
            Data aggregation layer (Calculates average)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.#ctor">
            <summary>
            Data aggregation layer (Calculates average)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Data aggregation layer (Calculates average)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IActivatableLayer">
            <summary>
            Layer with activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IActivatableLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer">
            <summary>
            Layer interface
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.OnlyUse">
            <summary>
            Only use mode
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer">
            <summary>
            Trainable layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer.InitWeights(System.Random)">
            <summary>
            Initialize layer weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRandomizableLayer">
            <summary>
            Layer that requires randomizer for work
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRandomizableLayer.Random">
            <summary>
            Random object for the layer
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRecurrentLayer">
            <summary>
            Interface for recurrent layers
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRecurrentLayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization">
            <summary>
             BatchReNormalization (Normalization of inputs during online learning)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.#ctor">
            <summary>
             BatchReNormalization (Normalization of inputs during online learning)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.WRe">
            <summary>
            Weighting matrix
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.WIm">
            <summary>
            Weighting matrix
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.BiasRe">
            <summary>
            Hyperplane displacement vector (neuron polarization)
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.BiasIm">
            <summary>
            Hyperplane displacement vector (neuron polarization)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Число выходов</param>
            <param name="f">Activation function</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="outputDimension">Число выходов</param>
            <param name="f">Activation function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D">
            <summary>
            One-dimensional convolutional layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.IsSame">
            <summary>
            Whether the dimension of the input is preserved
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.AddDenInSqrt">
            <summary>
            Adding a value to the denominator under the root when initializing the weights
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32,System.Random,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            One-dimensional convolutional layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            One-dimensional convolutional layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.InitWeights(System.Random)">
            <summary>
            Initialize layer weights
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.GetParameters">
            <summary>
            Generating a neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D">
            <summary>
            One-dimensional upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.AddDenInSqrt">
            <summary>
            Adding a value to the denominator under the root when initializing the weights
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.#ctor(System.Int32)">
            <summary>
            One-dimensional upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            One-dimensional upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer">
            <summary>
            Convolutional layer of neural network
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.FilterStrucuture">
            <summary>
            Filter structure
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.StrideX">
            <summary>
            X-axis stride
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.StrideY">
            <summary>
            Y-axis stride
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.PaddingX">
            <summary>
            Padding X-axis
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.PaddingY">
            <summary>
            Padding Y-axis
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.IsSame">
            <summary>
            Whether the dimension of the input is preserved
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Numerator">
            <summary>
            Initializer numerator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.AddDenInSqrt">
            <summary>
            Adding a value to the denominator under the root when initializing the weights
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Bias">
            <summary>
            Offset weights
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Filters">
            <summary>
            Filter tensors
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Convolutional layer
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
            <param name="filterStruct">Структура фильтров</param>
            <param name="func">Activation function</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Convolutional layer
            </summary>
            <param name="filterStruct">Структура фильтров</param>
            <param name="func">Activation function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convolutional layer
            </summary>
            <param name="func">Activation function</param>
            <param name="filterCount">Число фильтров</param>
            <param name="height">Высота фильтра</param>
            <param name="width">Ширина фильтра</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.GeneratorW(System.Random,System.Double)">
            <summary>
            Setting up the random number generator initializer
            </summary>
            <param name="random">Pseudo-random number generator</param>
            <param name="addDenumInSqrt">Adding a value to a radical expression in the denominator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.InitWeights(System.Random)">
            <summary>
            Initialize layer weights
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.RestOutShape">
            <summary>
            Обновление размера выхода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct">
            <summary>
            Convolutional network filter structure
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterW">
            <summary>
            Filter width
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterH">
            <summary>
            Filter height
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterCount">
            <summary>
            Number of filters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.Volume">
            <summary>
            Product of height by width and number of filters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor(AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
            <param name="gain">Усиление градиента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D">
            <summary>
            One-dimensional subsampling layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.AddDenInSqrt">
            <summary>
            Adding a value to the denominator under the root when initializing the weights
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            Subsampling (Maxpooling 1D)
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
            <param name="k">How many times to compress out</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.#ctor(System.Int32)">
            <summary>
            Subsampling (Maxpooling 1D)
            </summary>
            <param name="k">How many times to compress out</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling">
            <summary>
            Макспуллинг
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32)">
            <summary>
            Subsampling (Maxpooling 2D)
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
            <param name="h">How many times to compress out in height</param>
            <param name="w">How many times to compress in width</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.#ctor(System.Int32,System.Int32)">
            <summary>
            Subsampling (Maxpooling 2D) 
            </summary>
            <param name="h">How many times to compress out in height</param>
            <param name="w">How many times to compress in width</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape">
            <summary>
            Слой изменения формы тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.TrainableParameters">
            <summary>
            Число тренировочных параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.AddDenInSqrt">
            <summary>
            Добавление в знаменатель
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D,AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="inputShape">Начальная форма</param>
            <param name="newShape">Новая форма</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="inputShape">Начальная форма</param>
            <param name="newShape">Новая форма</param>
            <param name="gain">Усиление градиента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="newShape">Новая форма</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic">
            <summary>
            Upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.InputShape">
            <summary>
            Dimension and shape of the input tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.AddDenInSqrt">
            <summary>
            Adding a value to the denominator under the root when initializing the weights
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32)">
            <summary>
            Upsampling with bicubic interpolation
            </summary>
            <param name="inputShape">Dimension and shape of the input tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.#ctor(System.Int32,System.Int32)">
            <summary>
            Upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Direct network pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Automatic differentiation graph</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer">
            <summary>
            Copy layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Copy layer
            </summary>
            <param name="count">Number of copies</param>
            <param name="act">Non-linear function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            Слой копирования
            </summary>
            <param name="inpShape">Input dimension</param>
            <param name="count">Число копмрований</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut">
            <summary>
            DropOut layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.Random">
            <summary>
            Random object for the layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.#ctor(System.Single)">
            <summary>
            Dropout layer
            </summary>
            <param name="dropProb">Probability of disconnection with a neuron</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.DropOut.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer">
            <summary>
            Fully connected forward propagation layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.W">
            <summary>
            Weighting matrix
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.Bias">
            <summary>
            Hyperplane displacement vector (neuron polarization)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Fully connected layer
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="f">Activation function</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Fully connected layer
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="f">Activation function</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Fully connected layer
            </summary>
            <param name="outputDimension">Output dimension</param>
            <param name="f">Activation function</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer">
            <summary>
            Linear layer without bias
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Linear layer without bias
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Linear layer without bias
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(System.Int32)">
            <summary>
            Linear layer without bias
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer">
            <summary>
            Layer for training and creating embedding vectors
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Layer for training and creating embedding vectors
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.#ctor(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Layer for training and creating embedding vectors (initialization with pre-trained vectors)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.InitWeights(System.Random)">
            <summary>
            Initialize layer weights
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell">
            <summary>
            Обучаемый БИХ-фильтр
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.AddDenInSqrt">
            <summary>
            Добавление для расчета весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.Random">
            <summary>
            Random initialization for the layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.A">
            <summary>
            a - Коэффициенты фильтра
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.B">
            <summary>
            b - Коэффициенты фильтра
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.#ctor(System.Int32,System.Int32)">
            <summary>
            Обучаемый нейрофильтр
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Обучаемый нейрофильтр
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
            <param name="random">Random</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass (фильтрация)
            </summary>
            <param name="input"></param>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.GetParameters">
            <summary>
            Получение параметров
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.InitWeights(System.Random)">
            <summary>
            Not used
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer">
            <summary>
            Обучаемый банк фильтров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.AddDenInSqrt">
            <summary>
            Adding under the root
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.TrainableParameters">
            <summary>
            Teachable parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.FilterCells">
            <summary>
            Фильтры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Int32,System.Int32)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="activation">Activation function</param>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="countF"></param>
            <param name="aL"></param>
            <param name="bL"></param>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Прохождение банка
            </summary>
            <param name="input">Input</param>
            <param name="g">Граф</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.InitWeights(System.Random)">
            <summary>
            Инициализация
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.GetParameters">
            <summary>
            Получение обучаемых параметров
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer">
            <summary>
            Слой GRU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.TrainableParameters">
            <summary>
            Обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(System.Int32)">
            <summary>
            Слой GRU
            </summary>
            <param name="outputDimension">Output dimension</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.InitWeights(System.Random)">
            <summary>
            Generating weight coefficients of a neural network layer
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression">
            <summary>
            Слой GRU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.TrainableParameters">
            <summary>
            Обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(System.Int32)">
            <summary>
            Слой GRU
            </summary>
            <param name="outputDimension">Output dimension</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.InitWeights(System.Random)">
            <summary>
            Generating weight coefficients of a neural network layer
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer">
            <summary>
            Long short-term memory(LSTM) layer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(System.Int32)">
            <summary>
            Long short-term memory(LSTM) layer
            </summary>
            <param name="outputDimension">Output dimension</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.InitWeights(System.Random)">
            <summary>
            Generating weight coefficients of a neural network layer
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1">
            <summary>
            Long short-term memory(LSTM) layer (inpGate = 1.0 - forgetGate)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer (inpGate = 1.0 - forgetGate)
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer (inpGate = 1.0 - forgetGate)
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(System.Int32)">
            <summary>
            Long short-term memory(LSTM) layer
            </summary>
            <param name="outputDimension">Output dimension</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.InitWeights(System.Random)">
            <summary>
            Generating weight coefficients of a neural network layer
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection">
            <summary>
            Long short-term memory(LSTM) layer peephole connection
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer peephole connection
            </summary>
            <param name="inputDimension">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Long short-term memory(LSTM) layer peephole connection
            </summary>
            <param name="inputShape">Input dimension</param>
            <param name="outputDimension">Output dimension</param>
            <param name="initParamsStdDev">Standard deviation</param>
            <param name="rnd">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(System.Int32)">
            <summary>
            Long short-term memory(LSTM) layer peephole connection
            </summary>
            <param name="outputDimension">Output dimension</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.InitWeights(System.Random)">
            <summary>
            Generating weight coefficients of a neural network layer
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.ToString">
            <summary>
            Layer description
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.AddDenInSqrt">
            <summary>
            Adding to the denominator
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ActivationFunction">
            <summary>
            Activation function
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Double,System.Random)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Double,System.Random)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="g">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ResetState">
            <summary>
            Resetting the state of the neural network layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.InitWeights(System.Random)">
            <summary>
            Generating weights
            </summary>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ToString">
            <summary>
            Layer description
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax">
            <summary>
            Calculation of the error for the cross entropy provided that the output is Softmax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss">
            <summary>
            Loss function interface
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow">
            <summary>
            Ошибка 4я степень, для контрастирования выбросов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax">
            <summary>
            Аргмакс (нереализован)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy">
            <summary>
            Перекрестная энтропия
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actual">Output value (actual)</param>
            <param name="target">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt">
            <summary>
            Средний квадрат отклонения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE">
            <summary>
            Mean square of error
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares">
            <summary>
            Сумма квадратов отклонения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Backward pass (taking derivative)
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Error value
            </summary>
            <param name="actualOutput">Output value (actual)</param>
            <param name="targetOutput">Target value (ideal)</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.IBackwardRun">
            <summary>
            Interface for starting the calculation of derivatives by a chain rule
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.IBackwardRun.StartCalc">
            <summary>
            Starting the calculation of derivatives
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph">
            <summary>
            Self-differentiation graph interface
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.IsBackward">
            <summary>
            Is there a backward pass
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Backprop">
            <summary>
            Back pass elements
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Backward">
            <summary>
            Backward pass (differentiation)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Restart(System.Boolean)">
            <summary>
            Restart
            </summary>
            <param name="isBacward">  Is there a backward pass</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Copyist(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Copy tensor
            </summary>
            <param name="value">Tensor</param>
            <param name="count">Number of copies</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.ScalarProduct(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Dot product of two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Concatenate two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Vector concatenation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.DeConcatinateOne(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Cutting a vector into vectors by 1 element
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Activate(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Activation function
            </summary>
            <param name="function">Function activation</param>
            <param name="t">The tensor to which it is applied</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.AddCicleBuff(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Adding an item
            </summary>
            <param name="old">Buffer old state</param>
            <param name="inp">Added element</param>
            <param name="len">Buffer capacity</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Mul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Matrix multiplication
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.MulMV(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Matrix-vector multiplication
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Addition of two tensors
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.AddN(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adding a tensor to a number
            </summary>
            <param name="tensor">Tensor</param>
            <param name="number">Number</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Addition of three tensors
            </summary>
            <param name="t1">Tensor #1</param>
            <param name="t2">Tensor #2</param>
            <param name="t3">Tensor #3</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.OneMinus(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            1-m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Subtract(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Subtraction
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.MulMatrixByNumber(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single)">
            <summary>
            Multiplication by a number
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.MulMatrixByNumber(System.Single,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Multiplication by a number
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Invers(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Tensor inversion -m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.AdamarMul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Adamar product of tensors
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convolution without bias
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convolution
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.MaxPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Max pooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Tensor shape transformation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.UnPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            UnPooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.Upsampling2DBicubic(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Upsampling with bicubic interpolation
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.DropOut(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single,System.Single,System.Random)">
            <summary>
            Dropout
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.ImRealCross(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Mixing real and imaginary parts to create a new real and imaginary part
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.DeepJoin(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Tensor depth join
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.DeepSplit(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Splitting a tensor by depth
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.FeedForwardLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Feedforward layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.FeedforwardLinLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Feedforward linear layer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.IGraph.GRULayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit)">
            <summary>
            GRU layer
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.Runnable">
            <summary>
            Class for starting the calculation of derivatives by a chain rule
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.Runnable.StartCalc">
            <summary>
            Class for starting the calculation of derivatives by a chain rule
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.NNValue">
            <summary>
            The main class for storing data about a neural network, can be a vector, matrix or tensor of the 3rd rank
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.DifData">
            <summary>
            Gradients
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.StepCache">
            <summary>
            Cache for the first time the optimizer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.StepCache2">
            <summary>
            Cache optimizers for more complex, with two moments, such as Adam
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Shape">
            <summary>
            Shape of the tensor
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32)">
            <summary>
            Getting an element by its index in an array
            </summary>
            <param name="i">index</param>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32,System.Int32)">
            <summary>
            Retrieving an element by index of height and width
            </summary>
            <param name="h">Height index</param>
            <param name="w">Width index</param>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieving an element by index of height, width and depth
            </summary>
            <param name="h">Height</param>
            <param name="w">Width</param>
            <param name="d">Deep</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create tensor
            </summary>
            <param name="height">Height</param>
            <param name="width">Width</param>
            <param name="depth">Deep</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Create tensor
            </summary>
            <param name="shape">Shape of the tensor</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Create a tensor based on the algebraic strucuture
            </summary>
            <param name="algebraicStructure"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(System.Double)">
            <summary>
            Create tensor with parameters 1, 1, 1
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.op_Division(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Double)">
            <summary>
            Division of the tensor of DERIVATIVES by a number
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Like0">
            <summary>
            Similar tensor (same shape, filled with zeros)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTensor">
            <summary>
            Перевод в AI Тензор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToMatrix">
            <summary>
            Перевод в AI Матрицу
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToVector">
            <summary>
            Перевод в AI Вектор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTxts">
            <summary>
            Перевод матрицы в массив строк
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTxtsNoInfo">
            <summary>
            Перевод матрицы в массив строк
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Gauss(System.Random)">
            <summary>
            Гауссово распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Clone">
            <summary>
            Клонирование тензора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ResetDw">
            <summary>
            Сброс производных
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ResetStepCache">
            <summary>
            Сброс кэша
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Transpose(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Транспонирование
            </summary>
            <param name="m">Матрица</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Random(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Height </param>
            <param name="initParamsStdDev">ско</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Random(System.Int32,System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Height </param>
            <param name="d">Глубина</param>
            <param name="initParamsStdDev">ско</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.RandomR(System.Int32,System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Height </param>
            <param name="d">Глубина</param>
            <param name="initParamsStdDev">ско</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ident(System.Int32)">
            <summary>
            Создание единичной матрицы
            </summary>
            <param name="dim">Размерность матрицы</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Uniform(System.Int32,System.Int32,System.Double)">
            <summary>
            Создание матрицы заполненной одним числом
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
            <param name="s">Число</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(System.Int32,System.Int32)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(System.Int32)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="h"> Height </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.NegativeOnes(System.Int32,System.Int32)">
            <summary>
            Заполнение тензора -1
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D)" -->
        <!-- Badly formed XML comment ignored for member "M:AI.ML.NeuralNetwork.CoreNNW.NNValue.SaveAsText(System.String)" -->
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.SaveAsTextNoInfo(System.String)">
            <summary>
            Сохранение без тензора без описания
            </summary>
            <param name="path">Путь для сохранения</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Save(System.String)">
            <summary>
            Save NNValue to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Save(System.IO.Stream)">
            <summary>
            Save NNValue to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.GetBytes">
            <summary>
            Represents NNValue as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Load(System.String)">
            <summary>
            Load NNValue from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Load(System.IO.Stream)">
            <summary>
            Load NNValue from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.FromBytes(System.Byte[])">
            <summary>
            Initialize NNValue from an array of bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initialize NNValue from data stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.NNW">
            <summary>
            Neural network
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.Layers">
            <summary>
            List of network layers
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.InputShape">
            <summary>
            Input dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.OutputShape">
            <summary>
            Output dimension
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.TrainableParameters">
            <summary>
            Number of learning parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.#ctor(System.Int32)">
            <summary>
            Neural network
            </summary>
            <param name="seed">Random number generator seed</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.#ctor(System.Collections.Generic.List{AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer})">
            <summary>
            Neural network
            </summary>
            <param name="layers">List of layers</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.AddNewLayer(AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Adding a NEW layer to the neural network
            </summary>
            <param name="layer">Layer</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.AddNewLayer(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Adding a NEW layer to the neural network
            </summary>
            <param name="inpShape">Input tensor shape</param>
            <param name="layer">Layer</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="graph">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Forward pass
            </summary>
            <param name="input">Input</param>
            <param name="graph"></param>
            <returns>Graph of automatic differentiation</returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.ResetState">
            <summary>
            Resetting the state (necessary for recurrent neural networks)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.GetParameters">
            <summary>
            Getting trained parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.OnlyUse">
            <summary>
            Use only mode, all additional parameters are deleted
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Save(System.String)">
            <summary>
            Save network to file
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Save(System.IO.Stream)">
            <summary>
            Save network to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Load(System.String)">
            <summary>
            Load network from file
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Load(System.IO.Stream)">
            <summary>
            Load network from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer">
            <summary>
            Интерфейс учителя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer.Train(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single)">
            <summary>
            Network training
            </summary>
            <param name="epochesToPass">Number of epochs</param>
            /// <param name="batchSize">Batch size</param>
            <param name="learningRate">Learning rate</param>
            <param name="network">Neural network</param>
            <param name="data">Data set</param>
            <param name="minLoss">Minimal loss value</param>
            <returns>Loss</returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer.TrainAsync(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single,System.Threading.CancellationToken)">
            <summary>
            Network async training
            </summary>
            <param name="epochesToPass">Number of epochs</param>
            <param name="batchSize">Batch size</param>
            <param name="learningRate">Learning rate</param>
            <param name="network">Neural network</param>
            <param name="data">Data set</param>
            <param name="minLoss">Minimal loss value</param>
            <returns>Loss</returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer">
            <summary>
            Class for training neural networks
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.L1Regularization">
            <summary>
            Regularization coefficient L1, if it is equal to 0 L1 no regularization
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.L2Regularization">
            <summary>
            Regularization coefficient L2, if it is equal to 0 L2 regularization no
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Optimizer">
            <summary>
            Learning method SGD, Adam, etc.
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.GradientClipValue">
            <summary>
            Gradient clipping to avoid gradient explosion, default 3
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Info">
            <summary>
            Neural network training information
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.IsBusy">
            <summary>
            True if currently training another model
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.DoOverfitStop">
            <summary>
            Whether to stop learning when overfitting
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.DoCheckPointSave">
            <summary>
            Whether to make intermediate saves
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.CheckPointSaver">
            <summary>
            Checkpoint saver
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.MetricsMin">
            <summary>
            The minimum value for metrics that decrease as the quality of the model increases
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.MetricsMax">
            <summary>
            The maximum value for metrics that increase with increasing model quality
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Metrics">
            <summary>
            Metric
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ReportType">
            <summary>
            Report type
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ControlFunction">
            <summary>
            Function that controls the training of the neural network.If it evaluates to "true", training will be stopped.
            The function of the following form "bool Function (INetwork network, TrainInfo info, float bestVal)"
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor">
            <summary>
            Creating a trainer for a neural network
            </summary> 
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.IGraph)">
            <summary>
            Creating a trainer for a neural network
            </summary> 
            <param name="graph">Graph of automatic differentiation</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.IGraph,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer)">
            <summary>
            Creating a trainer for a neural network
            </summary> 
            <param name="graph">Graph of automatic differentiation</param>
            <param name="trainType">Train type</param>
            <param name="optimizer">Optimizer training method</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.IGraph,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer,System.Int32)">
            <summary>
            Creating a trainer for a neural network
            </summary> 
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Train(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single)">
            <summary>
            Network training
            </summary>
            <param name="epochesToPass">Number of epochs</param>
            <param name="batchSize">Batch size</param>
            <param name="learningRate">Learning rate</param>
            <param name="network">Neural network</param>
            <param name="data">Data set</param>
            <param name="minLoss">Minimal loss value</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainAsync(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single,System.Threading.CancellationToken)">
            <summary>
            Network training
            </summary>
            <param name="epochesToPass">Number of epochs</param>
            <param name="batchSize">Batch size</param>
            <param name="learningRate">Learning rate</param>
            <param name="network">Neural network</param>
            <param name="data">Data set</param>
            <param name="minLoss">Minimal loss value</param>
            <param name="cancellationToken">Token for cancelling asynchronous operation</param>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ReportElementCreated">
            <summary>
            Calls when new report element is created
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.EpochPassed">
            <summary>
            Calls when epoch is passed
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingStarted">
            <summary>
            Calls when training is started
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingFinished">
            <summary>
            Calls when training is finished
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingStopped">
            <summary>
            Calls when network training is stopped without finishing all epoches
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingCancelled">
            <summary>
            Calls when network training is cancelled by the token
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo">
            <summary>
            Information about training a neural network
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.ValidationLoss">
            <summary>
            Validation error
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.TrainLoss">
            <summary>
            Train error
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.TestLoss">
            <summary>
            Test error
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.#ctor">
            <summary>
            Information about training a neural network
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta">
            <summary>
            Adadelta
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name=" gradG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L2 </param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad">
            <summary>
            Adagrad
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name="kG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L2 </param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam">
            <summary>
            Adam
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.#ctor(System.Single,System.Single)">
            <summary>
            Adam
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name="kG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L1 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax">
            <summary>
            Adamax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.#ctor">
            <summary>
            Adamax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name="kG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L1 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer">
            <summary>
            Optimizer
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating parameters 
            </summary>
            <param name="network"> Neural network</param>
            <param name="learningRate"> Learning rate</param>
            <param name="gradClip"> Maximum gradient value</param>
            <param name="gradGain">Gradient enhancement factor</param>
            <param name="L1">L1 regularization</param>
            <param name="L2">L2 regularization</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer.Reset">
            <summary>
            Resetting Teaching Parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov">
            <summary>
            Nesterov
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.#ctor">
            <summary>
            Nesterov
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.#ctor(System.Single)">
            <summary>
            Nesterov
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name="kG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L1 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp">
            <summary>
             RMSProp
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.DecayRate">
            <summary>
            Momentum
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.SmoothEpsilon">
            <summary>
            Smoothing factor
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating model parameters 
            </summary>
            <param name="network"> Neural network </param>
            <param name="learningRate">Learning rate</param>
            <param name="gradClip"> Maximum gradient value </param>
            <param name="kG"> Gain of gradients </param>
            <param name="L1"> Regularization coefficient L1 </param>
            <param name="L2"> Regularization coefficient L1 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.Reset">
            <summary>
            Resetting neural network training parameters
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD">
            <summary>
            Stochastic gradient descent
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.Momentum">
            <summary>
            Momentum
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.#ctor">
            <summary>
            Stochastic gradient descent, moment = 0
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.#ctor(System.Single)">
            <summary>
            Stochastic gradient descent
            </summary>
            <param name="momentum">Moment</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.Reset">
            <summary>
            Resetting Teaching Parameters
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Updating parameters 
            </summary>
            <param name="network"> Neural network</param>
            <param name="learningRate"> Learning rate</param>
            <param name="gradClip"> Maximum gradient value</param>
            <param name="gradGain">Gradient enhancement factor</param>
            <param name="L1">L1 regularization</param>
            <param name="L2">L2 regularization</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.ToString">
            <summary>
            String representation
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.RMSLE">
            <summary>
            RMLE (target[i]>-1, output[i]>-1 for all i \in [0; N-1])
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Utilities.OverfitDetector.IsOverfit(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Overfit test
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.NeuralNetworkManager">
            <summary>
            Neural network manager (helper)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Model">
            <summary>
            Neural Network
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Graph">
            <summary>
            Graph of automatic differentiation
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Optimizer">
            <summary>
            Optimizer
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Loss">
            <summary>
            Loss function
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.LearningRate">
            <summary>
            Learning rate
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.L1Regularization">
            <summary>
            L1 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.L2Regularization">
            <summary>
            L2 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.GradientClipValue">
            <summary>
            Ограничение градиентов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.ValSplit">
            <summary>
            Какая часть выборки идет на валидацию модели
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.BatchSize">
            <summary>
            Размер батча
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.EpochesToPass">
            <summary>
            Number of epochs
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.MinLoss">
            <summary>
            Минимальная ошибка после которой останавливается обучение
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor">
            <summary>
            Neural network
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor(System.String)">
            <summary>
            Neural network
            </summary>
            <param name="path">Path to the saved network</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNW)">
            <summary>
            Neural network
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardVector(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardVector(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardMatrix(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardMatrix(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardTensor(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardTensor(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Neural network forward pass
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrent(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrent(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentVector(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentVector(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentMatrix(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentMatrix(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentTensor(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentTensor(AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Neural network forward reccurent pass
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Neural network training
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Threading.CancellationToken)">
            <summary>
            Neural network training
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[])">
            <summary>
            Neural network training
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(AI.DataStructs.Algebraic.IAlgebraicStructure[],AI.DataStructs.Algebraic.IAlgebraicStructure[],System.Threading.CancellationToken)">
            <summary>
            Neural network training
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetSignal(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Neural network training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetSignalAsync(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],System.Threading.CancellationToken)">
            <summary>
            Neural network async training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Neural network training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Threading.CancellationToken)">
            <summary>
            Neural network async training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[])">
            <summary>
            Neural network training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure}[],System.Threading.CancellationToken)">
            <summary>
            Neural network async training
            </summary>
            <param name="inputs">Inputs</param>
            <param name="outputs">Outputs(target values)</param>
        </member>
        <member name="T:AI.ML.Regression.IRegression">
            <summary>
            Regression interface
            </summary>
        </member>
        <member name="M:AI.ML.Regression.IRegression.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Regression training
            </summary>
            <param name="data">Set of vector inputs</param>
            <param name="targets">Output vector</param>
        </member>
        <member name="M:AI.ML.Regression.IRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Model prediction
            </summary>
            <param name="data">Input data vector</param>
        </member>
        <member name="T:AI.ML.Regression.KNNCorR">
            <summary>
            Regression(k-nearest neighbors method) (correlation metric)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.K">
            <summary>
            Number of neighbors
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.FixedH">
            <summary>
            Is the width fixed
            </summary>
        </member>
        <member name="F:AI.ML.Regression.KNNCorR.isMutation">
            <summary>
            Whether to trigger mutation of neighbors
            </summary>
        </member>
        <member name="F:AI.ML.Regression.KNNCorR.mutCount">
            <summary>
            Number of mutated neighbors
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.Dist">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.Reg">
            <summary>
            Regression data
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor">
            <summary>
            Regression (Nearest Neighbor Method)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor(System.String)">
            <summary>
            Regression (Nearest Neighbor Method)
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor(AI.ML.Regression.StructRegres)">
            <summary>
            Regression (Nearest Neighbor Method)
            </summary>
            <param name="reg"> Данные для регрессии</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Save(System.String)">
            <summary>
            Saving the regression model
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Open(System.String)">
            <summary>
            Loading a regression model
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Adding data
            </summary>
            <param name="tData">Central vector</param>
            <param name="targ">Dependent (target) variable</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.AddData(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавление данных для обучения
            </summary>
            <param name="tData">Input data vector</param>
            <param name="targ">Выход</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Regression training
            </summary>
            <param name="tData">Training data inputs</param>
            <param name="targs">Ideal outputs</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Regression training
            </summary>
            <param name="tData">Training data inputs</param>
            <param name="targs">Ideal outputs</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Model prediction
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.ImpObj">
            <summary>
            Calculation of the distribution of the importance of objects for the forecast
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.OnlyImp(System.Int32)">
            <summary>
            Leaves only objects important for forecasting
            </summary>
            <param name="n">Number of objects to keep</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.PredictV(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Vector prediction
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="T:AI.ML.Regression.KnnMultyRegr">
            <summary>
            Regression (k-nearest neighbors method)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.K">
            <summary>
            Number of neighbors
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.H">
            <summary>
            Window width
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.FixedH">
            <summary>
            Is the width fixed
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.IsNadrMethod">
            <summary>
            Используется ли окно Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.KernelWindow">
            <summary>
            Ядро окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.Dist">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.Reg">
            <summary>
            Dataset
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.RbfK(System.Double)">
            <summary>
            Радиально-базисное ядро для окна Парзена
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor(System.String)">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor(AI.ML.Regression.StructRegresMulty)">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
            <param name="reg"> Данные для регрессии</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Save(System.String)">
            <summary>
            Save
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Open(System.String)">
            <summary>
            Loading
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.ToData(System.Int32,System.Double@)">
            <summary>
            Перевод в double
            </summary>
            <param name="i">Index</param>
            <param name="R">Window weight (return parameter)</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавление класса
            </summary>
            <param name="tData">Центральный вектор</param>
            <param name="targ">Зависимая переменная</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Regression training
            </summary>
            <param name="tData">Input data</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Regression training
            </summary>
            <param name="tData">Input data</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Forecasted vector
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.PredictV(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Predict
            </summary>
            <param name="inp">Input vector</param>
        </member>
        <member name="T:AI.ML.Regression.KNNReg">
            <summary>
            Regression (k-nearest neighbors method)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.K">
            <summary>
            Number of neighbors
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.H">
            <summary>
            Window width
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.FixedH">
            <summary>
            Is the width fixed
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.IsNadrMethod">
            <summary>
            Используется ли окно Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.KernelWindow">
            <summary>
            Ядро окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.Dist">
            <summary>
            Distance function
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.Reg">
            <summary>
            Данные для регрессии
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor">
            <summary>
            Regression (k-nearest neighbors method)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.RbfK(System.Double)">
            <summary>
            Radial-basis kernel for the Nadaraya-Watson method
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor(System.String)">
            <summary>
            Regression (k-nearest neighbors method)
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor(AI.ML.Regression.StructRegres)">
            <summary>
            Regression (k-nearest neighbors method)
            </summary>
            <param name="reg">Dataset</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Save(System.String)">
            <summary>
            Save
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Open(System.String)">
            <summary>
            Loading
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.ToData(System.Int32,System.Double@)">
            <summary>
            Перевод в double
            </summary>
            <param name="i">Index</param>
            <param name="R">Вес окна</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Rang(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Ранжирование
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавление класса
            </summary>
            <param name="tData">Центральный вектор</param>
            <param name="targ">Зависимая переменная</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Regression training
            </summary>
            <param name="tData">Input data</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Regression training
            </summary>
            <param name="tData">Input data</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возращает вектор, его длинна - Number of classes, на номере нужного класса стоит 1
            </summary>
            <param name="inp">Input data vector</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.PredictV(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз вектора значений
            </summary>
            <param name="inp">Input data vector</param>
        </member>
        <member name="T:AI.ML.Regression.LinearRegressionModel">
            <summary>
            Модель для линейной регрессии хранит k и b   
            f(x) = k*x+b;
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegressionModel.k">
            <summary>
            Тангенс угла наклона
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegressionModel.b">
            <summary>
            Смещение относительно (0;0)
            </summary>
        </member>
        <member name="T:AI.ML.Regression.LinearRegression">
            <summary>
            Линейная регрессия
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegression.Lrm">
            <summary>
            Парамметры линейной регрессии
            </summary>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучающая выборка
            </summary>
            <param name="X">Вектор X(независимая переменная)</param>
            <param name="Y">Вектор Y(зависимая переменная)</param>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.ToString">
            <summary>
            Вывод в строку
            </summary>
            <returns>Строка типа: f(x) = k*x+(b)</returns>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.Predict(System.Double)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="x">Независимая переменная</param>
            <returns>Зависимая переменная</returns>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="X">Вектор независимых переменных</param>
            <returns>Вектор зависимых переменных</returns>
        </member>
        <member name="T:AI.ML.Regression.MultipleRegression">
            <summary>
            Multiple regression
            </summary>
        </member>
        <member name="P:AI.ML.Regression.MultipleRegression.Parammetrs">
            <summary>
            Параметры модели
            </summary>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.#ctor(System.Boolean)">
            <summary>
            Множественная линейная регрессия
            </summary>
            <param name="isScale">Стоит ли применить масштабирование к данным</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.#ctor(System.String)">
            <summary>
            Множественная линейная регрессия
            </summary>
            <param name="path">Путь до модели</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз
            </summary>
            <param name="vect">Input data vector</param>
            <returns>Выход</returns>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Predict(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Прогноз
            </summary>
            <param name="inp">Вектора входа</param>
            <returns>Output vector</returns>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.SaveModel(System.String)">
            <summary>
            Сохранение модели
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.LoadModel(System.String)">
            <summary>
            Loading the model
            </summary>
            <param name="path">The path to the file</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Multiple regression training
            </summary>
            <param name="data">Features</param>
            <param name="targets">Ideal outputs</param>
        </member>
        <member name="T:AI.ML.Regression.PolynomialRegression">
            <summary>
            Description of PolynomialRegression.
            </summary>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Полиномиальная регрессия
            </summary>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.Predict(System.Double)">
            <summary>
            Прогноз
            </summary>
            <param name="inp">Значение незав. переменной</param>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз
            </summary>
            <param name="vect">Значения незав. переменных</param>
        </member>
        <member name="T:AI.ML.Regression.StructRegr">
            <summary>
            Regression dataset item
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Target">
            <summary>
            Target variable value
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Features">
            <summary>
            Feature vector
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.R">
            <summary>
            Distance
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Params">
            <summary>
            Extra options
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegres">
            <summary>
            Regression dataset
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegres.Classes">
            <summary>
            Data
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegresMulty">
            <summary>
            Dataset for regression
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegresMulty.Classes">
            <summary>
            Data
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegrMulty">
            <summary>
            Structure for storing regression data
            </summary>
        </member>
        <member name="F:AI.ML.Regression.StructRegrMulty._targ">
            <summary>
            Target vector
            </summary>
        </member>
        <member name="F:AI.ML.Regression.StructRegrMulty._centGiperSfer">
            <summary>
            Center of the hypersphere
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.Targets">
            <summary>
            Target vector
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.CentGiperSfer">
            <summary>
            Center of the hypersphere
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.R">
            <summary>
            Distance
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.Params">
            <summary>
            Extra options
            </summary>
        </member>
        <member name="T:AI.ML.SeqPredict.AR">
            <summary>
            Autoregression
            </summary>
        </member>
        <member name="T:AI.ML.SeqPredict.GRUPredict">
            <summary>
            Prediction with GRU network
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.#ctor(System.Int32)">
            <summary>
            Prediction with GRU network
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Prediction n next values
            </summary>
            <param name="data">Start data</param>
            <param name="n">Number of next sempls</param>
        </member>
        <member name="T:AI.ML.SeqPredict.ISeqPredict">
            <summary>
            Прогнозирование последовательностей
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение
            </summary>
            <param name="data">Данные</param>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Прогноз
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.PredictTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение и прогноз на 1
            </summary>
        </member>
        <member name="T:AI.ML.SeqPredict.SeqPrediction">
            <summary>
            Прогнозирование последовательности
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.#ctor(AI.ML.Regression.IRegression,System.Int32)">
            <summary>
            Прогнозирование последовательности
            </summary>
            <param name="reg">Алгоритм прогнозирования</param>
            <param name="w">Window width</param>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение модели
            </summary>
            <param name="data">Последовательность</param>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Прогноз
            </summary>
            <param name="data">Известная часть последовательности</param>
            <param name="n">Сколько шагов предсказать</param>
        </member>
        <member name="T:AI.NLP.BoWModel">
            <summary>
            Bag-of-Words model
            </summary>
        </member>
        <member name="F:AI.NLP.BoWModel.vector">
            <summary>
            A vector where all 0's except for the word position
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.isStop">
            <summary>
            Are stop words analyzed
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.isDig">
            <summary>
            Are numbers being skipped
            </summary>
        </member>
        <member name="F:AI.NLP.BoWModel.Len">
            <summary>
            Vector / Dictionary Length
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.IsNormalise">
            <summary>
            Is the vector normalization
            </summary>
        </member>
        <member name="M:AI.NLP.BoWModel.#ctor(System.String)">
            <summary>
             Bag-of-Words model
            </summary>
        </member>
        <member name="M:AI.NLP.BoWModel.GetVector(System.String)">
            <summary>
            Getting a vector from text
            </summary>
            <param name="text">Text</param>
        </member>
        <member name="M:AI.NLP.BoWModel.ModelGen(System.String,System.String,System.Boolean)">
            <summary>
            Generating a model
            </summary>
        </member>
        <member name="T:AI.NLP.CompareStringMethods">
            <summary>
            Методы сравнения строк
            </summary>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.LevenshteinDistance(System.String,System.String)">
            <summary>
            Схожесть строк выраженая через расстояние Левенштейна
            </summary>
            <param name="input"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.WordCorellation(System.String,System.String)">
            <summary>
            Корреляция строк выраженая через расстояние Левенштейна
            </summary>
            <param name="input"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.HistogramCos(System.String,System.String,System.Int32)">
            <summary>
            Сравнение текста по n-граммам
            </summary>
            <param name="input">Строка входа</param>
            <param name="target">Целевая строка</param>
            <param name="n">Количество слов</param>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.HistogramCrossEntropy(System.String,System.String,System.Int32)">
            <summary>
            Сравнение текста по n-граммам
            </summary>
            <param name="input">Строка входа</param>
            <param name="target">Целевая строка</param>
            <param name="n">Количество слов</param>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.HistogramCrossEntropy(System.String,System.String)">
            <summary>
            Сравнение текста по n-граммам
            </summary>
            <param name="input">Строка входа</param>
            <param name="target">Целевая строка</param>
        </member>
        <member name="M:AI.NLP.CompareStringMethods.HistogramCos(System.String,System.String)">
            <summary>
            Сравнение текста по n-граммам
            </summary>
            <param name="input">Строка входа</param>
            <param name="target">Целевая строка</param>
        </member>
        <member name="T:AI.NLP.HMMFast">
            <summary>
            Быстрые марковские цепи
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFast.Models">
            <summary>
            Элемент модели
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFast.NGram">
            <summary>
            Глубина моделирования
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFast.ProbabilityVector">
            <summary>
            Вектор вероятностей
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFast.InvertedProbabilityVector">
            <summary>
            1- вектор вероятностей, полезен для установки квантелей
            </summary>
        </member>
        <member name="M:AI.NLP.HMMFast.#ctor">
            <summary>
            Быстрые марковские цепи
            </summary>
        </member>
        <member name="M:AI.NLP.HMMFast.#ctor(AI.NLP.HMMFastModel[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрые марковские цепи
            </summary>
        </member>
        <member name="M:AI.NLP.HMMFast.Train(System.String,System.Boolean)">
            <summary>
            Обучение языковой модели
            </summary>
            <param name="trainText">Тренировочный текст</param>
            <param name="addStart">Добавлять ли старт вначале</param>
        </member>
        <member name="M:AI.NLP.HMMFast.Generate(System.Int32)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">число слов</param>
            <returns>сгенерированная строка</returns>
        </member>
        <member name="M:AI.NLP.HMMFast.Generate(System.Int32,System.String[])">
            <summary>
            Генерация текста
            </summary>
            <param name="num">число слов</param>
            <param name="strs">начальное состояние</param>
            <returns>сгенерированная строка</returns>
        </member>
        <member name="M:AI.NLP.HMMFast.Generate(System.Int32,System.String[],System.Random)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">число слов</param>
            <param name="strs">начальное состояние</param>
            <param name="rnd">Pseudo-random number generator</param>
            <returns>сгенерированная строка</returns>
        </member>
        <member name="M:AI.NLP.HMMFast.TextToVector(System.String)">
            <summary>
            Преобразование текста в вектор + изменение модели
            </summary>
            <param name="text">текст</param>
            <returns>вектор</returns>
        </member>
        <member name="M:AI.NLP.HMMFast.Save(System.String)">
            <summary>
            Saves HMMFast to file
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:AI.NLP.HMMFast.Save(System.IO.Stream)">
            <summary>
            Saves HMMFast to stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:AI.NLP.HMMFast.Load(System.String)">
            <summary>
            Loads HMMFast from file
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.HMMFast.Load(System.IO.Stream)">
            <summary>
            Loads HMMFast from stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.NLP.HMMFastModel">
            <summary>
            Блок для сохранения
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFastModel.Model">
            <summary>
            N-грамма
            </summary>
        </member>
        <member name="P:AI.NLP.HMMFastModel.Probability">
            <summary>
            Вероятность
            </summary>
        </member>
        <member name="T:AI.NLP.HMMNextWord">
            <summary>
            Слово
            </summary>
        </member>
        <member name="P:AI.NLP.HMMNextWord.Value">
            <summary>
            Слово
            </summary>
        </member>
        <member name="P:AI.NLP.HMMNextWord.Probability">
            <summary>
            Вероятность
            </summary>
        </member>
        <member name="M:AI.NLP.HMMNextWord.#ctor(System.String,System.Double)">
            <summary>
            Слово
            </summary>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionary">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.pDictionary">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.IsDigitDel">
            <summary>
            Удалять ли цифры
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.IsStem">
            <summary>
            Использовать ли стеммер
            </summary>
        </member>
        <member name="F:AI.NLP.ProbabilityDictionary.stop">
            <summary>
            Слова не несущие смысла
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.StopWords">
            <summary>
            Слова не несущие смысла при стат. анализе
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Вероятностный словарь
            </summary>
            <param name="isStopDel">Удалять ли стоп-слова</param>
            <param name="isDigitDel">Удалять ли числа</param>
            <param name="isStem">Делать ли стеммеризацию</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.Run(System.String)">
            <summary>
            Данные вероятностного словаря
            </summary>
            <param name="text">Тукст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWordsRunAll(System.String)">
            <summary>
            Запуск генерации словаря с выводом всех слов
            </summary>
            <param name="text">Текст для генерации</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWordsRun(System.String,System.Int32)">
            <summary>
            Запуск генерации словаря с выводом определенного числа слов
            </summary>
            <param name="text">Текст для генерации</param>
            <param name="numW">Число слов</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.DigialPredickat(System.String)">
            <summary>
            Возвращает true если в сторке есть цифры
            </summary>
            <param name="str">Строка</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.Analis">
            <summary>
            Анализ текста
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.ToString(System.Int32)">
            <summary>
            Переводит частотный словарь в строку
            </summary>
            <param name="index">До какого индекса</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWords(System.String)">
            <summary>
            Получение слов
            </summary>
            <param name="text">Текст</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWords(System.String,System.Boolean)">
            <summary>
            Получение слов
            </summary>
            <param name="text"></param>
            <param name="IsStem"></param>
            <returns></returns>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionaryData">
            <summary>
            Данные вероятностного словаря
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryData.Word">
            <summary>
            Слово
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryData.Probability">
            <summary>
            Вероятность встретить это слово
            </summary>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionaryHash">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryHash.pDictionary">
            <summary>
            Вероятностный словарь 
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryHash.IsStem">
            <summary>
            Применять ли стеммер
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.#ctor(System.Boolean)">
            <summary>
            Вероятностный словарь
            </summary>
            <param name="isStem">Делать ли стеммеризацию</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.Run(System.String)">
            <summary>
            Данные вероятностного словаря
            </summary>
            <param name="text">Тукст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.Analis">
            <summary>
            Анализ текста
            </summary>
        </member>
        <member name="T:AI.NLP.Stemmers.StemmerRus">
            <summary>
            Стемер русского языка
            </summary>
        </member>
        <member name="M:AI.NLP.Stemmers.StemmerRus.TransformingWordsArray(System.String[])">
            <summary>
            Стемминг массива слов
            </summary>
            <param name="words">Массив слов</param>
        </member>
        <member name="M:AI.NLP.Stemmers.StemmerRus.TransformingWord(System.String)">
            <summary>
            стемминг
            </summary>
            <param name="word">слово</param>
            <returns>приставка+корень</returns>
        </member>
        <member name="T:AI.NLP.TextStandard">
            <summary>
            Стандартизация текста
            </summary>
        </member>
        <member name="M:AI.NLP.TextStandard.Normalize(System.String,System.Boolean)">
            <summary>
             Standardization of the input text
            </summary>
            <param name="input">Input text</param>
            <param name="isLower">Casting to lowercase</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyCharsAndDigit(System.String)">
            <summary>
            В запросе остаются только буквы, цифры и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyChars(System.String)">
            <summary>
            В запросе остаются только буквы и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyRusChars(System.String)">
            <summary>
            В запросе остаются только буквы и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="M:AI.NLP.TextStandard.NoDoubleWord(System.String)">
            <summary>
            Удаляет повторы слов
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="T:AI.NLP.TextSummarization">
            <summary>
            Суммаризация
            </summary>
        </member>
        <member name="M:AI.NLP.TextSummarization.#ctor">
            <summary>
            Суммаризация
            </summary>
        </member>
        <member name="M:AI.NLP.TextSummarization.Summarization(System.String,System.Int32)">
            <summary>
            Суммаризация текста
            </summary>
            <param name="text">Текст</param>
            <param name="num">Кол-во предложений для описания текста</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextSummarization.GetSeqs(System.String)">
            <summary>
            Выдает предложения
            </summary>
            <param name="text">Текст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextSummarization.Step1(System.String)">
            <summary>
            The first step of the algorithm(compilation of probabilistic dictionaries)
            </summary>
            <param name="text">Текст</param>
        </member>
        <member name="M:AI.NLP.TextSummarization.Step2">
            <summary>
            Second step of making the list: sentence, weight
            </summary>
        </member>
        <member name="M:AI.NLP.TextSummarization.GetW(System.Int32)">
            <summary>
            Calculating the semantic weight of a sentence
            </summary>
        </member>
        <member name="T:AI.NLP.DataSummText">
            <summary>
            Данные предложений
            </summary>
        </member>
        <member name="P:AI.NLP.DataSummText.W">
            <summary>
            Вес
            </summary>
        </member>
        <member name="P:AI.NLP.DataSummText.Str">
            <summary>
            Содержание
            </summary>
        </member>
        <member name="M:AI.NLP.DataSummText.#ctor(System.String,System.Double)">
            <summary>
            Данные предложений
            </summary>
            <param name="str">строка</param>
            <param name="w">вес</param>
        </member>
        <member name="T:AI.NLP.TextTokenizer">
            <summary>
            Class for tokenizing text
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.IsLower">
            <summary>
            Whether to convert text to lowercase
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.IsStem">
            <summary>
            Whether to stem the text
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.DelChars">
            <summary>
            Deleted characters
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.Separaters">
            <summary>
            Characters or strings to separate words
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.Count">
            <summary>
            Output vector dimention
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.WordCount">
            <summary>
            Number of words in the frequency dictionary
            </summary>
        </member>
        <member name="M:AI.NLP.TextTokenizer.#ctor(System.Boolean,System.Boolean,System.Char[],System.String[])">
            <summary>
            Class for tokenizing text
            </summary>
            <param name="isLower">Whether to convert text to lowercase</param>
            <param name="isStem">Whether to stem the text</param>
            <param name="deleted">Deleted characters (default [',' ';' '*' '?' '!' '.'])  </param>
            <param name="separaters">Characters or strings to separate words (default ["\t" " " "\n"])</param>
        </member>
        <member name="T:AI.NLP.TFIDF">
            <summary>
            TF-IDF
            </summary>
        </member>
        <member name="M:AI.NLP.TFIDF.#ctor(System.String[])">
            <summary>
            TF-IDF
            </summary>
            <param name="docs">Массив документов</param>
        </member>
        <member name="M:AI.NLP.TFIDF.TFWord(System.String,System.Int32)">
            <summary>
            tf
            </summary>
            <param name="t"></param>
            <param name="dIndex"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.IDFWord(System.String)">
            <summary>
            Idf
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.TF_IDF(System.String,System.Int32)">
            <summary>
            TF-IDF
            </summary>
            <param name="t"></param>
            <param name="dIndex"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.TF_IDF_Str(System.String,System.Int32)">
            <summary>
            Принадлежность строки к определенному документу
            </summary>
            <param name="str">Строка</param>
            <param name="dIndex">Index документа</param>
        </member>
        <member name="M:AI.NLP.TFIDF.Search(System.String)">
            <summary>
            Поиск документа
            </summary>
            <param name="req">Запрос</param>
        </member>
        <member name="T:AI.NLP.TFIDFDictionary">
            <summary>
            TF-IDF Dictionary
            </summary>
        </member>
        <member name="P:AI.NLP.TFIDFDictionary.tFIDF">
            <summary>
            TF-IDF algorithm
            </summary>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.#ctor(System.String)">
            <summary>
            Generating TF-IDF Dictionary
            </summary>
            <param name="pathToDir">Path to the directory with documents</param>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.ToVect(System.String)">
            <summary>
            Word to vector based on dictionary
            </summary>
            <param name="word">Word</param>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.Sim(System.String,System.String)">
            <summary>
            Word proximity calculation
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.VectorDictionary">
            <summary>
            Drawing up a vector dictionary
            </summary>
        </member>
        <member name="T:AI.Sound">
            <summary>
            Description of Sound.
            </summary>
        </member>
        <member name="F:AI.Sound.chunkID">
            <summary>
            ID
            </summary>
        </member>
        <member name="F:AI.Sound.fileSize">
            <summary>
            Размер файла
            </summary>
        </member>
        <member name="F:AI.Sound.riffType">
            <summary>
            Тип
            </summary>
        </member>
        <member name="F:AI.Sound.fmtID">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.fmtSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.fmtCode">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.channels">
            <summary>
            Каналы (число)
            </summary>
        </member>
        <member name="F:AI.Sound.sampleRate">
            <summary>
            Sampling frequency
            </summary>
        </member>
        <member name="F:AI.Sound.fmtAvgBPS">
            <summary>
            средний битрейт
            </summary>
        </member>
        <member name="F:AI.Sound.fmtBlockAlign">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.bitDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.dataID">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.dataSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.Sound.#ctor">
            <summary>
            Звук
            </summary>
        </member>
        <member name="M:AI.Sound.SoundLoad(System.String)">
            <summary>
            Загрузка звука
            </summary>
            <param name="path">File path</param>
            <returns></returns>
        </member>
        <member name="M:AI.Sound.SaveVector(System.String,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Save vector как звука
            </summary>
            <param name="path"></param>
            <param name="vector"></param>
            <param name="fd"></param>
        </member>
        <member name="T:AI.SpecialFunction.EllipticIntegral">
            <summary>
            Эллиптические интегралы
            </summary>
        </member>
        <member name="M:AI.SpecialFunction.EllipticIntegral.CompleteEllipticIntegral_I(System.Double)">
            <summary>
            Полный эллиптический интеграл первого рода
            </summary>
            <param name="k">Значение</param>
        </member>
        <member name="M:AI.SpecialFunction.EllipticIntegral.CompleteComplementarEllipticIntegral_I(System.Double)">
            <summary>
            Полный комплементарный эллиптический интеграл первого рода
            </summary>
            <param name="k">Значение</param>
        </member>
        <member name="T:AI.Statistics.Distributions.IDistribution">
            <summary>
            Basic interface for distribution of functions
            </summary>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcLogProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcLogProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcProb(System.Double)">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcLogProb(System.Double)">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcLogProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcLogProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters, key params: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcLogProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters, key params: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters, key params: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
            <param name="param_dist">Distribution parameters, key params: "std", "mean"</param>
        </member>
        <member name="T:AI.Statistics.FormStatistcs">
            <summary>
            Статистики зависимые только от формы функции
            </summary>
        </member>
        <member name="M:AI.Statistics.FormStatistcs.CrestFactor(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Коэффициент формы (пик-фактор)
            </summary>
            <param name="vector">Input data vector</param>
        </member>
        <member name="T:AI.Statistics.Histogramm">
            <summary>
            Структура гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.#ctor">
            <summary>
             Структура гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.#ctor(System.Int32)">
            <summary>
             Структура гистограммы
            </summary>
            <param name="n">Число разрядов</param>
        </member>
        <member name="P:AI.Statistics.Histogramm.X">
            <summary>
            Значения столбцов
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Y">
            <summary>
            Высоты столбцов
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Name">
            <summary>
            Название гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Info">
            <summary>
            Описание гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.XLable">
            <summary>
            Название оси "Х" гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.YLables">
            <summary>
            Название оси "У" гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.Save(System.String)">
            <summary>
            Сохранение гистограммы
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueH(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Сумма значений по строкам
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueHMean(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Средние знач. яркости
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueW(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Сумма значений по строкам
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueWMean(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Средние знач. яркости
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarAnd(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе умножения(Эквивалент "И")
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarSumm(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе сложения
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarNorm(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе вычисления модуля
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.Open(System.String)">
            <summary>
            Загрузка гистограммы
            </summary>
            <param name="path">File path</param>		
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Возвращает индикаторы
            </summary>
            <param name="inps">Входы</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmax1D(System.Double)">
            <summary>
            Одномерная плотность вероятности
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmaxND(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Многомерная плотность вероятности
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmax1D(System.Double,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Моделирует argmax{log[f(x|Theta)] + log(w)}
            </summary>
            <param name="inp"></param>
            <param name="distribution">Родительская функция распределения</param>
            <param name="param_dist">Параметры распределения</param>
            <param name="apriori">Априорное расп</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmaxND(AI.DataStructs.Algebraic.Vector,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Многомерная плотность вероятности 
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Расчет индикаторов
            </summary>
            <param name="inps"></param>
            <param name="distribution"></param>
            <param name="param_dist"></param>
            <param name="apriori"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector[],AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возвращает индикаторы
            </summary>
            <param name="inps">Входы</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.#ctor(AI.Statistics.Distributions.IDistribution,System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{System.String,System.Double}},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Mixture modeling
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.#ctor(AI.Statistics.Distributions.IDistribution,System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Mixture modeling
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcLogProb(System.Double)">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcLogProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Log probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcProb(System.Double)">
            <summary>
            Probability calculation
            </summary>
            <param name="x">Input</param>
        </member>
        <member name="T:AI.Statistics.Quantile">
            <summary>
            Quantiles
            </summary>
        </member>
        <member name="P:AI.Statistics.Quantile.SortVec">
            <summary>
            Sorted vector
            </summary>
        </member>
        <member name="M:AI.Statistics.Quantile.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Quantile
            </summary>
            <param name="structureDouble">Data</param>
        </member>
        <member name="M:AI.Statistics.Quantile.GetQuantile(System.Double)">
            <summary>
            Calculating a given quantile (0-1)
            </summary>
            <param name="q">Quantile</param>
        </member>
        <member name="T:AI.Statistics.RandomItemSelection`1">
            <summary>
            Random selection of items
            </summary>
            <typeparam name="T">Array type</typeparam>
        </member>
        <member name="M:AI.Statistics.RandomItemSelection`1.GetElement(AI.DataStructs.Algebraic.Vector,`0[],System.Random)">
            <summary>
            Random selection of elements with a given distribution function
            </summary>
            <param name="distributionFunction">Samples of a discrete distribution function</param>
            <param name="arrayStates">Array of states</param>
            <param name="random">Random number generator</param>
        </member>
        <member name="M:AI.Statistics.RandomItemSelection`1.GetIndex(AI.DataStructs.Algebraic.Vector,System.Random)">
            <summary>
            Random selection of index with a given distribution function
            </summary>
            <param name="distributionFunction">Samples of a discrete distribution function</param>
            <param name="random">Random number generator</param>
        </member>
        <member name="T:AI.Statistics.Statistic">
            <summary>
            The class contains methods for statistical analysis.As well as pseudo random number generators
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.STD">
            <summary>
            Root mean square deviation
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.MinValue">
            <summary>
            Minimum value
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.MaxValue">
            <summary>
            Maximum value
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.Variance">
            <summary>
            Dispersion
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.Expected">
            <summary>
            Expected value
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Creates an object of class Statistic, takes a vector of input values ​​of a random variable
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32)">
            <summary>
            Pseudo-random number generator с равномерным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32,System.Random)">
            <summary>
            Pseudo-random number generator с равномерным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="random">Pseudo-random number generator</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Gauss(System.Random)">
            <summary>
            Гауссовское распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Gauss2(System.Random,System.Int32)">
            <summary>
            Гауссовское распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNormP(System.Int32,System.Int32)">
            <summary>
            Pseudo-random number generator с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="iter">Число итераций</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNormP(System.Int32,System.Random,System.Int32)">
            <summary>
            Pseudo-random number generator с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="random">Pseudo-random number generator</param>
            <param name="iter">Число итераций</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32)">
            <summary>
            Pseudo-random number generator с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Random)">
            <summary>
            Pseudo-random number generator с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="rnd">Pseudo-random number generator</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32,System.Int32)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32,System.Int32,System.Random)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32,System.Int32,System.Int32)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Int32)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Random)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
            <param name="rn">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Height </param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <param name="random">Pseudo-random number generator</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaximalValue(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Maximum value
            </summary>
            <param name="data">Values</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MinimalValue(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Minimum value
            </summary>
            <param name="data">Values</param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValue">
            <summary>
            Expected value
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValue(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Estimation of mathematical expectation
            </summary>
            <param name="vector">Vector containing samples of a random variable</param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueAbs(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Estimation of the mathematical expectation from the modulus of a random variable
            </summary>
            <param name="vector">Vector containing samples of a random variable</param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueNotCheckNaN(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Estimation of mathematical expectation
            </summary>
            <param name="vector">Vector containing samples of a random variable</param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueAbsNotCheckNaN(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Estimation of the mathematical expectation from the modulus of a random variable
            </summary>
            <param name="vector">Vector containing samples of a random variable</param>
        </member>
        <member name="M:AI.Statistics.Statistic.СalcVariance">
            <summary>
            Variance calculation
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Std">
            <summary>
            СКО
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.СalcVariance(AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Variance calculation
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CalcStd(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculating standard deviation
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm">
            <summary>
            Pseudo-random number generator с нормальным распределением
            </summary>
            <returns>Возвращает случайные числа</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Rand(System.Int16)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности n на n
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int16)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности n на n
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Histogramm(System.Int32)">
            <summary>
            Строит гистограмму
            </summary>
            <param name="n">Количество разрядов гистограммы</param>
            <returns>возращает вектор длинной nRazr, содержащий отсчеты для построения гистограммы</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.InitialMoment(System.Int32)">
            <summary>
            Initial moment
            </summary>
            <param name="n">Initial moment number 1,2,3 ...</param>
        </member>
        <member name="M:AI.Statistics.Statistic.CentralMoment(System.Int32)">
            <summary>
            Central moment
            </summary>
            <param name="n">Central moment number 1,2,3 ...</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Asymmetry">
            <summary>
            Distribution asymmetry
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Excess">
            <summary>
            Kurtosis, "steepness" of the distribution
            </summary>
            <returns>Returns the kurtosis coefficient</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Cov(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Covariance (correlation moment, linear dependence) of two vectors
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CorrelationCoefficient(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Pearson's correlation coefficient
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CorrelationCoefficient(AI.DataStructs.Algebraic.IAlgebraicStructure,AI.DataStructs.Algebraic.IAlgebraicStructure)">
            <summary>
            Pearson's correlation coefficient
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanVector(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Усреднение по выборке(ансамблю)
            </summary>
            <param name="vectors">Dataset</param>
            <returns>Средний вектор</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanGeom(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднее геометрическое 
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanGarmonic(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднее гармоническое
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RMS(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднeквадратичное значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleDispersion(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Дисперсия по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleStd(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            СКО по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaxEns(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Максимум по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaxEnergeVector(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Возвращает вектор с максимальной энергией
            </summary>
            <param name="ens">Ансамбль векторов</param>
            <returns>Вектор с максимальной энергией</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.SimpleMeanFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Средняя частота (не нормированная, зависит от кол-ва точек)
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanFreq(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Средняя частота сигнала
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Sampling frequency</param>
            <returns>Средняя частота [Гц]</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.DivFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Изменение частоты
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Дивиация средней частоты</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanStep(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Average step, how much x[i] differs from x[i + 1] on average
            </summary>
            <param name="vector">Sequence</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanStep2(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            (Max(vector) - Min(vector))/N + eps
            </summary>
            <param name="vector">Sequence</param>
        </member>
        <member name="T:AI.Convolution">
            <summary>
            A class that implements the folding of sequences
            </summary>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Convolution
            </summary>
            <param name="signal">Signal</param>
            <param name="Ht">Impulse response</param>
        </member>
        <member name="M:AI.Convolution.ConvolutionNormal(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Convolution
            </summary>
            <param name="signal">Signal</param>
            <param name="Ht">Impulse response</param>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Convolution
            </summary>
            <param name="signal">Signal</param>
            <param name="ht">Impulse response</param>
            <param name="fd">Sampling frequency</param>
        </member>
        <member name="M:AI.Convolution.StWithHt(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Creating a new signal reference vector
            </summary>
            <param name="st">Signal</param>
            <param name="htLen">Impulse response length</param>
        </member>
        <member name="M:AI.Convolution.StWithHt(AI.DataStructs.WithComplexElements.ComplexVector,System.Int32)">
            <summary>
            Creating a new signal reference vector
            </summary>
            <param name="st">Signal</param>
            <param name="htLen">Impulse response length</param>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Direct convolution complex vector
            </summary>
        </member>
    </members>
</doc>
